Directory: main

Directory Structure:
```
.
.
├── ./.git
│   ├── ./.git/HEAD
│   ├── ./.git/config
│   ├── ./.git/description
│   ├── ./.git/hooks
│   │   ├── ./.git/hooks/applypatch-msg.sample
│   │   ├── ./.git/hooks/commit-msg.sample
│   │   ├── ./.git/hooks/fsmonitor-watchman.sample
│   │   ├── ./.git/hooks/post-update.sample
│   │   ├── ./.git/hooks/pre-applypatch.sample
│   │   ├── ./.git/hooks/pre-commit.sample
│   │   ├── ./.git/hooks/pre-merge-commit.sample
│   │   ├── ./.git/hooks/pre-push.sample
│   │   ├── ./.git/hooks/pre-rebase.sample
│   │   ├── ./.git/hooks/pre-receive.sample
│   │   ├── ./.git/hooks/prepare-commit-msg.sample
│   │   ├── ./.git/hooks/push-to-checkout.sample
│   │   └── ./.git/hooks/update.sample
│   ├── ./.git/index
│   ├── ./.git/info
│   │   └── ./.git/info/exclude
│   ├── ./.git/logs
│   │   ├── ./.git/logs/HEAD
│   │       ├── ./.git/logs/refs/heads
│   │       │   └── ./.git/logs/refs/heads/main
│   │           └── ./.git/logs/refs/remotes/origin
│   │               └── ./.git/logs/refs/remotes/origin/HEAD
│   │   └── ./.git/objects/pack
│   │       ├── ./.git/objects/pack/pack-d0d4d9f65fea88fc59ec06fc94c7e0bcb7641413.idx
│   │       └── ./.git/objects/pack/pack-d0d4d9f65fea88fc59ec06fc94c7e0bcb7641413.pack
│   ├── ./.git/packed-refs
│       ├── ./.git/refs/heads
│       │   └── ./.git/refs/heads/main
│       │   └── ./.git/refs/remotes/origin
│       │       └── ./.git/refs/remotes/origin/HEAD
├── ./.ipynb_checkpoints
│   ├── ./.ipynb_checkpoints/auth-checkpoint.js
│   ├── ./.ipynb_checkpoints/characters-checkpoint.js
│   ├── ./.ipynb_checkpoints/index-checkpoint.html
│   ├── ./.ipynb_checkpoints/index-checkpoint.json
│   ├── ./.ipynb_checkpoints/login-checkpoint.html
│   ├── ./.ipynb_checkpoints/register-checkpoint.html
│   ├── ./.ipynb_checkpoints/script-checkpoint.js
│   ├── ./.ipynb_checkpoints/styles-checkpoint.css
│   └── ./.ipynb_checkpoints/watch_characters-checkpoint.py
├── ./136.38.129.228+2-key.pem
├── ./136.38.129.228+2.pem
│   ├── ./assets/images
│   │   └── ./assets/images/default-background.jpg
│   └── ./assets/sounds
│       └── ./assets/sounds/phone-ring.mp3
├── ./auth.js
├── ./avatars
│   ├── ./avatars/aria-avatar.png
│   ├── ./avatars/beetlejuice-avatar.png
│   ├── ./avatars/default-user.png
│   ├── ./avatars/jeffy-avatar.png
│   ├── ./avatars/luna-avatar.png
│   ├── ./avatars/meatcanyon-avatar.png
│   ├── ./avatars/meatwad-avatar.png
│   ├── ./avatars/melon-avatar.png
│   ├── ./avatars/onyx-avatar.png
│   ├── ./avatars/power-avatar.png
│   ├── ./avatars/power2-avatar.png
│   ├── ./avatars/power3-avatar.png
│   ├── ./avatars/wheatley-portal-2-avatar.png
│   └── ./avatars/zeke-avatar.png
├── ./characters
│   ├── ./characters/.ipynb_checkpoints
│   │   ├── ./characters/.ipynb_checkpoints/Untitled-checkpoint.ipynb
│   │   ├── ./characters/.ipynb_checkpoints/aria-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/beetlejuice-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/index-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/jeffy-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/luna-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/meatcanyon-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/meatwad-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/onyx-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/rick-checkpoint.json
│   │   └── ./characters/.ipynb_checkpoints/wheatley-portal-2-checkpoint.json
│   ├── ./characters/Untitled.ipynb
│   ├── ./characters/aria.json
│   ├── ./characters/beetlejuice
│   │   └── ./characters/beetlejuice/background.jpg
│   ├── ./characters/beetlejuice.json
│   ├── ./characters/index.json
│   ├── ./characters/jeffy
│   │   └── ./characters/jeffy/background.jpg
│   ├── ./characters/jeffy.json
│   ├── ./characters/luna.json
│   ├── ./characters/meatcanyon
│   │   └── ./characters/meatcanyon/background.jpg
│   ├── ./characters/meatcanyon.json
│   ├── ./characters/meatwad
│   │   └── ./characters/meatwad/background.jpg
│   ├── ./characters/meatwad.json
│   ├── ./characters/melon
│   │   ├── ./characters/melon/background.jpeg
│   │   └── ./characters/melon/background.jpg
│   ├── ./characters/melon.json
│   ├── ./characters/onyx.json
│   ├── ./characters/power2
│   │   └── ./characters/power2/background.mp4
│   ├── ./characters/power2.json
│   ├── ./characters/power3
│   │   ├── ./characters/power3/background.jpeg
│   │   └── ./characters/power3/background.jpg
│   ├── ./characters/power3.json
│   ├── ./characters/rick.json
│   ├── ./characters/wheatley-portal-2
│   │   └── ./characters/wheatley-portal-2/background.gif
│   ├── ./characters/wheatley-portal-2.json
│   └── ./characters/zeke
│       └── ./characters/zeke/background.jpg
├── ./characters.js
├── ./chat
│   ├── ./chat/.ipynb_checkpoints
│   │   ├── ./chat/.ipynb_checkpoints/chat-checkpoint.html
│   │   ├── ./chat/.ipynb_checkpoints/chat-checkpoint.js
│   │   └── ./chat/.ipynb_checkpoints/chat-styles-checkpoint.css
│   ├── ./chat/chat-styles.css
│   ├── ./chat/chat.html
│   └── ./chat/chat.js
├── ./css
│   ├── ./css/.ipynb_checkpoints
│   │   └── ./css/.ipynb_checkpoints/create-character-checkpoint.css
│   └── ./css/create-character.css
├── ./index.html
├── ./index.json
├── ./js
│   ├── ./js/.ipynb_checkpoints
│   │   └── ./js/.ipynb_checkpoints/characterCreation-checkpoint.js
│   └── ./js/characterCreation.js
├── ./login.html
├── ./logo.jpg
├── ./register.html
├── ./script.js
├── ./styles.css
└── ./watch_characters.py
```

Contents of 136.38.129.228+2-key.pem:
```
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDOPO4H5JeMhfaS
KnhdjBZOMHYbEBhSBaBeuKksQlq/ai+rPNxuX/0S1UBS7adytNeGrmhfl5XJJNOY
zcHlgjMtPS7A9Qz+q0gIgE9bqYc3A/KztwIZPx+Y5OEzAP6ad4fsSzDPNX+3C0JF
r94vlIH5Ucwd5OjSOn7CJsDfLE9HCSR/aOGvzxJ2mQWEfgPZi/mZ+3loI/FtKs2h
CNG9RZLu3XgHPEYQKQt9KOG5mUrhCMUI+Ney+BhhUjZqHThY/CF4pBoxs6hUpIeK
tGtD8AulTUvDuAe/Xe7wQCn3+MQFaZ2Vj61m0f6cY5wrlF8Z82aaa/jxwaJD6GFF
MxSqdQG5AgMBAAECggEBAIONghguzCyq1xltVdH2JdRCPVQN9DV9uUoyaFb/DHvE
9Bs6ezE8sWVt+dXsGj+k80XJwnIXc0gW4ZI6zU/kuVhGCqiyp1NbVlt13SkO/l0t
e4b/WatZBIK2nJ+4Jq/JRz6Gx9+ktI7B88gX4pZfGHk8oAMBnTFcdrbJmYXB8d/Q
483Sxw13+bzBf4yIJArhCjs5Q+WLLLiLb5mT+904POjpZpjvTcab635TgYjg4ESU
N+OR0vuzKNBGNZBgM3vYCl5mmdmTip7ntVi93VZcVKeD4h3EEt8Ag12HgfZVe7aY
3ZhcFRuwf/Lx8SraIj808BTnPDOGjXZ6pI5zEC9vJHECgYEA7k8pfjgOrncseQ3s
Kwhjn3GWYwke2428LeapCjFBC+m3JXFfpCJyjNvI9B0pHAmJrBgpxa+49rO7tWbM
sZZfVYblc8HoYWFjubtdYLWwhpJnf9gAVzB5g8YhIIEpNkdF+DHo7LMmtL1KiAZL
vKFSpiXfGOAJIsjcojsToF5rLe8CgYEA3YxI9fjyDCD2dITT7oBXU8mTqIRnw1NR
eUOl7NJE/GT2BVytok8L8hyd1BvyH5KDzDLDnY2Io4GmPj9duu9RushdxRRFbw73
rx1WdxF7yMFTOz3cekhGtB+YXXi5i12/MJadoarwXg8Y24g/ti6CoICOodWXqxNu
Jk4M8bjTctcCgYAtMtp91AgE0xmeRCO87bRnc1XApuQxZCqC0jLRehIKPmO8OEqZ
iOcNDEqK8lTvumdgOp0Bn5iHQgOiHkNIk2q1gAZY9Dgs8BnICl9ljlBS1cXHm6JE
5y7E7Xku/xBf+RiuQFkbO8dllFlkfz0yI67XUGuF/kf9Tvd51ZadXgsaBQKBgChO
RFvTnZ2NRakvHStv1/NbYeyvof0MJG9uWjp6iqhsacHR+ZjkzqSOhjw3lVYfHrFA
rwvz2t78UFVUy+Wdcn4Lw9t985/f1jnamYdx+9YrLcxCVeE9UvekI+ElfIQZWxYo
4Kav5akHEBuobwbi8Urn+IsCw+QQ1eJMIti7KmTjAoGACnqad1D8aNNSFx19IqqV
kTMDCOmc7LFBpgU0GLbIBtFaJ/DptTsF+jMp9ZMZPYnMd9JZEWYnYko0N05LGHjG
vh4SH2jkO8FaxYSY67l7hLXP1u65QAZn9PHro+q94igqLr37YAX0s0WOAHxqFtA+
1VtmpWTjproiJ78DnrmilN4=
-----END PRIVATE KEY-----

```

Contents of 136.38.129.228+2.pem:
```
-----BEGIN CERTIFICATE-----
MIIEGDCCAoCgAwIBAgIQOefcsC8Jx2zsBmmJKlk6QzANBgkqhkiG9w0BAQsFADBf
MR4wHAYDVQQKExVta2NlcnQgZGV2ZWxvcG1lbnQgQ0ExGjAYBgNVBAsMEXJvb3RA
ZDAxNjA1NjY3ZjM3MSEwHwYDVQQDDBhta2NlcnQgcm9vdEBkMDE2MDU2NjdmMzcw
HhcNMjQxMTI5MTAwNDQ2WhcNMjcwMzAxMTAwNDQ2WjBFMScwJQYDVQQKEx5ta2Nl
cnQgZGV2ZWxvcG1lbnQgY2VydGlmaWNhdGUxGjAYBgNVBAsMEXJvb3RAZDAxNjA1
NjY3ZjM3MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzjzuB+SXjIX2
kip4XYwWTjB2GxAYUgWgXripLEJav2ovqzzcbl/9EtVAUu2ncrTXhq5oX5eVySTT
mM3B5YIzLT0uwPUM/qtICIBPW6mHNwPys7cCGT8fmOThMwD+mneH7EswzzV/twtC
Ra/eL5SB+VHMHeTo0jp+wibA3yxPRwkkf2jhr88SdpkFhH4D2Yv5mft5aCPxbSrN
oQjRvUWS7t14BzxGECkLfSjhuZlK4QjFCPjXsvgYYVI2ah04WPwheKQaMbOoVKSH
irRrQ/ALpU1Lw7gHv13u8EAp9/jEBWmdlY+tZtH+nGOcK5RfGfNmmmv48cGiQ+hh
RTMUqnUBuQIDAQABo2owaDAOBgNVHQ8BAf8EBAMCBaAwEwYDVR0lBAwwCgYIKwYB
BQUHAwEwHwYDVR0jBBgwFoAU3BDuIiyzTBWBa2ax21X4aE2Ym7gwIAYDVR0RBBkw
F4IJbG9jYWxob3N0hwSIJoHkhwR/AAABMA0GCSqGSIb3DQEBCwUAA4IBgQAhQRxn
nFA/Nx45ROx3sbvOKfd5hopoYSeoNZxZXwsJLPcFAcyovgorj8Q3FcA4YHIGomx2
X9NPYzbVfn621QmutfxRb+X3iQ/AnLoIwkBMqcVyBncMeYR/jMxvSnx2x0Pn5i3P
rbSfAmfAIzdOaCJwHIIJVwNCwVdU6w1DfroPqJnXH5gE6Pf5UgCISKT6CWaSce+a
N5xbIV7iPPh5JntzVw/gl8N8eaJcw8+Vuk5Xoq/+sp9q+odXeF8BBiQQdTeZWDGK
iEgrqUjY8zmITyIPWgXb/IVJl8A18T8A+eZ8yBbvwwvmpT7Flfq/0xXgGejYL/Hy
KRg1vadK7izKCzRsWj3cjQ1zhpAum371EZ20aEYULYDvlUuf6LxtMrU/n0qllyT4
+m1/j6KG/7o4m24LLWPZbpyE3Gzj8h6VhtRAmADG7bRqmI6GyP7yaDQvPO+B71hL
qyxN2JisvsIAj4141gKsAF07rY2ItsQdVE715cFcN/vB/k4w4jYHoOMsjKA=
-----END CERTIFICATE-----

```

Contents of auth.js:
```
import { loadCharacters } from './script.js';

// Auth state management
let currentUser = null;

// DOM Elements
const authModal = document.getElementById('auth-modal');
const loginButton = document.getElementById('login-button');
const registerButton = document.getElementById('register-button');
const logoutButton = document.getElementById('logout-button');
const switchToRegisterButton = document.querySelector('.switch-to-register');
const switchToLoginButton = document.querySelector('.switch-to-login');
const loginError = document.getElementById('login-error');
const registerError = document.getElementById('register-error');
const closeAuthModalButton = document.getElementById('close-auth-modal');

// Check authentication status
async function checkAuth() {
    try {
        const response = await fetch('/auth/user', {
            credentials: 'include',
            headers: {
                'Cache-Control': 'no-cache'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            currentUser = data.user;
            updateAuthUI();
            return true;
        } else {
            currentUser = null;
            updateAuthUI();
            return false;
        }
    } catch (error) {
        console.error('Auth check failed:', error);
        currentUser = null;
        updateAuthUI();
        return false;
    }
}

// Update UI based on auth state
function updateAuthUI() {
    const loggedOutView = document.getElementById('logged-out-view');
    const loggedInView = document.getElementById('logged-in-view');
    const usernameDisplay = document.getElementById('username-display');
    const creditsDisplay = document.getElementById('credits-display');
    const createCharacterBtn = document.getElementById('create-character');

    if (currentUser) {
        loggedOutView.style.display = 'none';
        loggedInView.style.display = 'block';
        usernameDisplay.textContent = currentUser.username;
        creditsDisplay.textContent = `Credits: ${currentUser.credits}`;
        createCharacterBtn.disabled = false;
    } else {
        loggedOutView.style.display = 'block';
        loggedInView.style.display = 'none';
        createCharacterBtn.disabled = true;
    }
}

// Modal controls
function openAuthModal(type = 'login') {
    authModal.showModal();
    switchAuthForm(type);
}

function closeAuthModal() {
    authModal.close();
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    loginForm?.reset();
    registerForm?.reset();
    if (loginError) loginError.textContent = '';
    if (registerError) registerError.textContent = '';
}

function switchAuthForm(type) {
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    if (!loginForm || !registerForm) return;

    if (type === 'login') {
        loginForm.style.display = 'block';
        registerForm.style.display = 'none';
    } else {
        loginForm.style.display = 'none';
        registerForm.style.display = 'block';
    }
}

// Handle login
async function handleLogin(e) {
    e.preventDefault();
    if (!loginError) return;
    loginError.textContent = '';
    
    const email = document.getElementById('login-email')?.value;
    const password = document.getElementById('login-password')?.value;
    
    try {
        const response = await fetch('/auth/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            loginError.textContent = data.error || 'Login failed';
        }
    } catch (error) {
        console.error('Login error:', error);
        loginError.textContent = 'Login failed. Please try again.';
    }
}

// Handle registration
async function handleRegister(e) {
    e.preventDefault();
    if (!registerError) return;
    registerError.textContent = '';
    
    const username = document.getElementById('register-username')?.value;
    const email = document.getElementById('register-email')?.value;
    const password = document.getElementById('register-password')?.value;
    
    try {
        const response = await fetch('/auth/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ username, email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            registerError.textContent = data.error || 'Registration failed';
        }
    } catch (error) {
        console.error('Registration error:', error);
        registerError.textContent = 'Registration failed. Please try again.';
    }
}

// Handle logout
async function handleLogout() {
    try {
        const response = await fetch('/auth/logout', {
            credentials: 'include'
        });
        
        if (response.ok) {
            currentUser = null;
            updateAuthUI();
            await loadCharacters();
        }
    } catch (error) {
        console.error('Logout error:', error);
    }
}

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    checkAuth();
    
    loginButton?.addEventListener('click', () => openAuthModal('login'));
    registerButton?.addEventListener('click', () => openAuthModal('register'));
    logoutButton?.addEventListener('click', handleLogout);
    closeAuthModalButton?.addEventListener('click', closeAuthModal);
    
    document.getElementById('login-form')?.addEventListener('submit', handleLogin);
    document.getElementById('register-form')?.addEventListener('submit', handleRegister);
    
    document.querySelector('.switch-to-register')?.addEventListener('click', () => switchAuthForm('register'));
    document.querySelector('.switch-to-login')?.addEventListener('click', () => switchAuthForm('login'));
});

export {
    currentUser,
    checkAuth,
    updateAuthUI,
    openAuthModal
};
```

Contents of characters.js:
```
import { currentUser } from './auth.js';

const characterModal = document.getElementById('character-modal');
const characterForm = document.getElementById('character-form');

// Modal controls
function openCharacterModal() {
    if (!currentUser) {
        openAuthModal();
        return;
    }
    setupImagePreviews();
    characterModal.showModal();
}

function closeCharacterModal() {
    characterModal.close();
    characterForm.reset();
    document.getElementById('avatar-preview').innerHTML = '';
    document.getElementById('background-preview').innerHTML = '';
}

// Image preview handling
function setupImagePreviews() {
    const avatarInput = document.getElementById('avatar');
    const backgroundInput = document.getElementById('background');
    
    if (avatarInput) {
        setupImagePreview(avatarInput, document.getElementById('avatar-preview'));
    }
    if (backgroundInput) {
        setupImagePreview(backgroundInput, document.getElementById('background-preview'));
    }
}

function setupImagePreview(input, previewElement) {
    if (!input || !previewElement) return;
    
    input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement('img');
                img.src = e.target.result;
                previewElement.innerHTML = '';
                previewElement.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    });
}

// Handle character creation
characterForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
        // First upload images
        const avatarFile = document.getElementById('avatar').files[0];
        const backgroundFile = document.getElementById('background')?.files[0];
        
        // Upload avatar
        const avatarFormData = new FormData();
        avatarFormData.append('avatar', avatarFile);
        const avatarResponse = await fetch('/upload/avatar', {
            method: 'POST',
            credentials: 'include',
            body: avatarFormData
        });
        
        if (!avatarResponse.ok) {
            throw new Error('Failed to upload avatar');
        }
        
        const { avatarPath } = await avatarResponse.json();
        let backgroundPath = null;
        
        // Upload background if provided
        if (backgroundFile) {
            const backgroundFormData = new FormData();
            backgroundFormData.append('background', backgroundFile);
            const backgroundResponse = await fetch('/upload/character-background', {
                method: 'POST',
                credentials: 'include',
                body: backgroundFormData
            });
            
            if (backgroundResponse.ok) {
                const data = await backgroundResponse.json();
                backgroundPath = data.backgroundPath;
            }
        }
        
        // Create character data
        const formData = new FormData(characterForm);
        const character = {
            name: formData.get('name'),
            description: formData.get('description'),
            systemPrompt: formData.get('systemPrompt'),
            avatar: avatarPath,
            background: backgroundPath,
            ttsVoice: formData.get('ttsVoice'),
            category: formData.get('category'),
            is_private: formData.get('is_private') === 'on',
            tts_rate: parseInt(formData.get('tts_rate')) || 0,
            rvc_pitch: parseInt(formData.get('rvc_pitch')) || 0,
            tags: formData.get('tags')?.split(',').map(tag => tag.trim()).filter(tag => tag) || []
        };
        
        const response = await fetch('/characters/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify(character)
        });
        
        if (!response.ok) {
            throw new Error('Failed to create character');
        }
        
        const { character_id } = await response.json();
        
        // Submit for review if needed
        if (!character.is_private && formData.get('submit_for_review') === 'on') {
            await fetch(`/characters/submit-for-review/${character_id}`, {
                method: 'POST',
                credentials: 'include'
            });
        }
        
        closeCharacterModal();
        window.location.reload(); // Reload to show new character
        
    } catch (error) {
        console.error('Error creating character:', error);
        alert('Failed to create character. Please try again.');
    }
});

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
    const createCharacterBtn = document.getElementById('create-character');
    const closeModalBtns = document.querySelectorAll('.modal-close');
    
    createCharacterBtn?.addEventListener('click', openCharacterModal);
    closeModalBtns.forEach(btn => {
        btn?.addEventListener('click', closeCharacterModal);
    });
});

export {
    openCharacterModal,
    closeCharacterModal
};
```

Contents of index.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <title>AetherChat - AI Character Chat</title>
</head>
<body>
    <nav class="nav-panel">
        <div class="logo-container">
            <img src="./logo.jpg" alt="AetherChat" class="logo-image">
        </div>
        
        <div id="auth-section" class="nav-section">
            <div id="logged-out-view">
                <button class="nav-button" id="login-button">
                    <span>👤</span>
                    Login
                </button>
                <button class="nav-button" id="register-button">
                    <span>✨</span>
                    Sign Up
                </button>
            </div>
            <div id="logged-in-view" style="display: none">
                <div class="user-info">
                    <span id="username-display"></span>
                    <span id="credits-display"></span>
                </div>
                <button class="nav-button" id="logout-button">
                    <span>🚪</span>
                    Logout
                </button>
            </div>
        </div>
            
        <div class="nav-section">
            <h2>Search</h2>
            <input type="text" class="search-bar" id="search" placeholder="Search characters...">
        </div>
        
        <div class="nav-section">
            <h2>Create</h2>
            <a href="/create-character" class="nav-button" id="create-character">
                <span>+</span>
                Create New Character
            </a>
        </div>
        
        <div class="nav-section">
            <h2>Categories</h2>
            <div id="category-filters"></div>
        </div>
        
        <div class="nav-section">
            <h2>Tags</h2>
            <div id="tag-filters"></div>
        </div>
    </nav>

    <main>
        <div id="character-grid" class="character-grid"></div>
    </main>

    <dialog id="auth-modal" class="modal">
        <div class="modal-content">
            <!-- Login Form -->
            <form id="login-form" class="auth-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" required>
                </div>
                <div id="login-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Login</button>
                    <button type="button" class="switch-to-register">Need an account?</button>
                </div>
            </form>

            <!-- Register Form -->
            <form id="register-form" class="auth-form" style="display: none;">
                <h2>Create Account</h2>
                <div class="form-group">
                    <label for="register-username">Username</label>
                    <input type="text" id="register-username" required>
                </div>
                <div class="form-group">
                    <label for="register-email">Email</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password</label>
                    <input type="password" id="register-password" required>
                </div>
                <div id="register-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Register</button>
                    <button type="button" class="switch-to-login">Already have an account?</button>
                </div>
            </form>
        </div>
        <button class="modal-close" id="close-auth-modal">&times;</button>
    </dialog>

    <script type="module" src="./auth.js"></script>
    <script type="module" src="./characters.js"></script>
    <script type="module" src="./script.js"></script>
</body>
</html>

```

Contents of index.json:
```
{
    "characters": [],
    "lastUpdated": "2024-11-28T00:00:00Z"
}
EOF
```

Contents of login.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .oauth-buttons {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .oauth-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
            cursor: pointer;
        }

        .oauth-button:hover {
            background: var(--surface);
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Login to SpeakEasy</h1>
        <form class="auth-form" id="loginForm">
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <button type="submit">Login</button>
        </form>
        
        <div class="oauth-buttons">
            <button class="oauth-button" id="googleLogin">
                <img src="https://www.google.com/favicon.ico" alt="Google" width="20" height="20">
                Continue with Google
            </button>
        </div>
        
        <p>Don't have an account? <a href="/register.html">Register</a></p>
    </div>

    <script>
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            try {
                const response = await fetch('/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: document.getElementById('email').value,
                        password: document.getElementById('password').value
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    window.location.href = '/';
                } else {
                    alert(data.error);
                }
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed. Please try again.');
            }
        });

        document.getElementById('googleLogin').addEventListener('click', () => {
            window.location.href = '/auth/google';
        });
    </script>
</body>
</html>
```

Contents of logo.jpg:
```
[Could not decode file contents]

```

Contents of register.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Register - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .error-message {
            color: var(--error);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Create Account</h1>
        <form class="auth-form" id="registerForm">
            <input type="text" id="username" placeholder="Username" required>
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <input type="password" id="confirmPassword" placeholder="Confirm Password" required>
            <div class="error-message" id="errorMessage"></div>
            <button type="submit">Register</button>
        </form>
        
        <p>Already have an account? <a href="/login.html">Login</a></p>
    </div>

    <script>
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const errorMessage = document.getElementById('errorMessage');
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            if (password !== confirmPassword) {
                errorMessage.textContent = 'Passwords do not match';
                return;
            }

            try {
                const response = await fetch('/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: document.getElementById('username').value,
                        email: document.getElementById('email').value,
                        password: password
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    // Registration successful, redirect to home page
                    window.location.href = '/';
                } else {
                    errorMessage.textContent = data.error || 'Registration failed';
                }
            } catch (error) {
                console.error('Registration error:', error);
                errorMessage.textContent = 'Registration failed. Please try again.';
            }
        });
    </script>
</body>
</html>
```

Contents of script.js:
```
import { currentUser, checkAuth } from './auth.js';

// State management
let characters = [];
let activeFilters = {
    categories: new Set(),
    tags: new Set(),
    search: '',
    view: 'grid',
    sort: 'random'
};

// Load characters from the index
async function loadCharacters() {
    try {
        console.log("Fetching character index...");
        const response = await fetch('./characters/index.json');
        if (!response.ok) throw new Error(`Failed to load character index: ${response.status}`);

        const data = await response.json();
        console.log("Character index loaded:", data);

        // Load individual character files
        characters = await Promise.all(
    data.characters.map(async (file) => {
        try {
            const response = await fetch(`./characters/${file}`);
            if (!response.ok) throw new Error(`Failed to load character file: ${file}`);
            return await response.json();
        } catch (error) {
            console.error(error);
            return null;
        }
    })
);

// Only filter private characters
characters = characters.filter((char) => {
    if (!char) return false;
    if (char.isPrivate) {
        return currentUser && char.creator === currentUser.id;
    }
    return true;  // Show all non-private characters
});
        

        // Filter out null values and private characters unless they belong to the user
        characters = characters.filter((char) => {
            if (!char) return false;
            if (char.isPrivate) {
                return currentUser && char.creator === currentUser.id;
            }
            return true;
        });

        console.log("Final character list:", characters);
        initializeFilters();
        updateCharacterDisplay();
    } catch (error) {
        console.error('Error loading characters:', error);
        characters = [];
        updateCharacterDisplay();
    }
}

// Initialize filters
function initializeFilters() {
    const categories = new Set();
    const tags = new Set();

    characters.forEach((char) => {
        if (char.category) categories.add(char.category);
        if (char.tags) char.tags.forEach((tag) => tags.add(tag));
    });

    const categoryFilters = document.getElementById('category-filters');
    const tagFilters = document.getElementById('tag-filters');
    
    if (categoryFilters) {
        categoryFilters.innerHTML = '';
        Array.from(categories).sort().forEach((category) => {
            const btn = createFilterButton(category, 'category');
            categoryFilters.appendChild(btn);
        });
    }

    if (tagFilters) {
        tagFilters.innerHTML = '';
        Array.from(tags).sort().forEach((tag) => {
            const btn = createFilterButton(tag, 'tag');
            tagFilters.appendChild(btn);
        });
    }
}

function createFilterButton(value, type) {
    const button = document.createElement('button');
    button.classList.add('filter-button');
    // Check if the filter set exists before trying to use it
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet && filterSet.has(value)) {
        button.classList.add('active');
    }
    button.textContent = value;
    button.addEventListener('click', () => toggleFilter(value, type));
    return button;
}

function toggleFilter(value, type) {
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet.has(value)) {
        filterSet.delete(value);
    } else {
        filterSet.add(value);
    }
    updateCharacterDisplay();
}

// Update character display
function updateCharacterDisplay() {
    const characterGrid = document.getElementById('character-grid');
    if (!characterGrid) return;

    const filteredChars = filterCharacters();
    const sortedChars = sortCharacters(filteredChars);

    characterGrid.innerHTML = '';

    if (sortedChars.length === 0) {
        const noResults = document.createElement('p');
        noResults.className = 'no-results';
        noResults.textContent = currentUser ? 
            'No characters found. Try creating one!' : 
            'No characters found. Try logging in to see more!';
        characterGrid.appendChild(noResults);
        return;
    }

    sortedChars.forEach((char) => {
        const card = createCharacterCard(char);
        characterGrid.appendChild(card);
    });
}

function filterCharacters() {
    return characters.filter((char) => {
        const matchesSearch = char.name.toLowerCase().includes(activeFilters.search.toLowerCase()) ||
                            char.description.toLowerCase().includes(activeFilters.search.toLowerCase());
        const matchesCategories = !activeFilters.categories.size || 
                                activeFilters.categories.has(char.category);
        const matchesTags = !activeFilters.tags.size || 
                          char.tags?.some((tag) => activeFilters.tags.has(tag));
        return matchesSearch && matchesCategories && matchesTags;
    });
}

function sortCharacters(chars) {
    const charsCopy = [...chars];
    switch (activeFilters.sort) {
        case 'name':
            charsCopy.sort((a, b) => a.name.localeCompare(b.name));
            break;
        case 'newest':
            charsCopy.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
            break;
        case 'random':
        default:
            for (let i = charsCopy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [charsCopy[i], charsCopy[j]] = [charsCopy[j], charsCopy[i]];
            }
    }
    return charsCopy;
}

function createCharacterCard(char) {
    const card = document.createElement('div');
    card.classList.add('character-card');

    const tagsHtml = char.tags
        ? char.tags.map((tag) => `<span class="tag">${tag}</span>`).join('')
        : '';

    card.innerHTML = `
        <img class="character-image" src="${char.avatar}" alt="${char.name}" 
             onerror="this.src='./avatars/default-user.png'">
        <div class="character-info">
            <h2>${char.name}</h2>
            <p>${char.description}</p>
            <div class="character-meta">
                ${char.category ? `<span class="category-badge">${char.category}</span>` : ''}
                ${tagsHtml}
                ${char.isPrivate ? '<span class="private-badge">Private</span>' : ''}
            </div>
        </div>
    `;

    card.addEventListener('click', () => {
    if (!currentUser) {
        sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
        window.location.href = './login.html';
        return;
    }
    sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
    window.location.href = './chat/chat.html';
});

    return card;
}

// Event Listeners
document.addEventListener('DOMContentLoaded', async () => {
    await checkAuth();
    loadCharacters();

    const searchInput = document.getElementById('search');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            activeFilters.search = e.target.value;
            updateCharacterDisplay();
        });
    }
});

// Export functions that might be needed by other modules
export {
    loadCharacters,
    updateCharacterDisplay
};
```

Contents of styles.css:
```
:root {
  --primary: #00b4ff;
  --primary-variant: #bb86fc;
  --secondary: #03DAC6;
  --background: #121212;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --error: #CF6679;
  --on-primary: #000000;
  --on-secondary: #000000;
  --on-background: #FFFFFF;
  --on-surface: #FFFFFF;
  --on-error: #000000;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--background);
  color: var(--on-background);
  min-height: 100vh;
  display: flex;
}

.menu-toggle {
  display: none;
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
  background: var(--surface);
  border: none;
  color: var(--on-surface);
  font-size: 1.5rem;
  padding: 0.5rem;
  border-radius: 8px;
  cursor: pointer;
}

.logo-container {
  padding: 0;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.logo-image {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.nav-panel {
  width: 280px;
  background-color: var(--surface);
  height: 100vh;
  position: fixed;
  left: 0;
  display: flex;
  flex-direction: column;
  gap: 2rem;
  z-index: 100;
  transition: transform 0.3s ease;
  padding: 0;
  box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.nav-section h2 {
  font-size: 0.9rem;
  text-transform: uppercase;
  color: var(--primary);
  letter-spacing: 0.1em;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
  background: var(--surface-2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 0.75rem 1rem;
  border-radius: 8px;
  color: var(--on-surface);
  width: 100%;
  transition: all 0.3s ease;
}

.search-bar:focus {
  border-color: var(--primary);
  box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1rem;
  background: linear-gradient(45deg, var(--surface-2), var(--surface));
  border: none;
  border-radius: 8px;
  color: var(--on-surface);
  cursor: pointer;
  transition: all 0.2s ease;
}

.nav-button:hover {
  background: linear-gradient(45deg, var(--primary), var(--primary-variant));
  color: var(--on-primary);
  box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
  margin-left: 280px;
  flex: 1;
  padding: 2rem;
  min-height: 100vh;
}

.character-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1.5rem;
  padding: 1rem;
}

.character-card {
  background: var(--surface);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
  border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
  border-color: var(--primary-variant);
}

.character-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

.character-info {
  padding: 1rem;
}

.character-info h2 {
  color: var(--on-surface);
  font-size: 1.1rem;
  margin-bottom: 0.5rem;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.tag {
  background: var(--surface-2);
  color: var(--on-surface);
  padding: 0.25rem 0.75rem;
  border-radius: 16px;
  font-size: 0.8rem;
  border: 1px solid rgba(187, 134, 252, 0.2);
  transition: all 0.2s ease;
}

.tag:hover {
  background: var(--primary-variant);
  box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
    margin-bottom: 2rem;
}

.user-info {
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
    color: var(--primary);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

@media (max-width: 1200px) {
  .character-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 992px) {
  .nav-panel {
    width: 240px;
  }
  
  main {
    margin-left: 240px;
  }
}

@media (max-width: 768px) {
  .menu-toggle {
    display: block;
  }

  .nav-panel {
    transform: translateX(-100%);
    width: 100%;
    max-width: 300px;
  }

  .nav-panel.active {
    transform: translateX(0);
  }

  main {
    margin-left: 0;
    padding: 1rem;
  }
  
  .character-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .character-grid {
    grid-template-columns: 1fr;
  }
}:root {
 --primary: #00b4ff;
 --primary-variant: #bb86fc;
 --secondary: #03DAC6;
 --background: #121212;
 --surface: #1E1E1E;
 --surface-2: #2D2D2D;
 --error: #CF6679;
 --on-primary: #000000;
 --on-secondary: #000000;
 --on-background: #FFFFFF;
 --on-surface: #FFFFFF;
 --on-error: #000000;
}

* {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
}

body {
 font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
 background-color: var(--background);
 color: var(--on-background);
 min-height: 100vh;
 display: flex;
}

.menu-toggle {
 display: none;
}

.logo-container {
 padding: 0;
 width: 100%;
 display: flex;
 justify-content: center;
 align-items: center;
}

.logo-image {
 width: 100%;
 height: auto;
 object-fit: contain;
}

.nav-panel {
 width: 280px;
 background-color: var(--surface);
 height: 100vh;
 position: fixed;
 left: 0;
 display: flex;
 flex-direction: column;
 gap: 2rem;
 z-index: 100;
 transition: transform 0.3s ease;
 padding: 0;
 box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
 padding: 2rem;
 display: flex;
 flex-direction: column;
 gap: 1rem;
}

.nav-section h2 {
 font-size: 0.9rem;
 text-transform: uppercase;
 color: var(--primary);
 letter-spacing: 0.1em;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
 background: var(--surface-2);
 border: 1px solid rgba(255, 255, 255, 0.1);
 padding: 0.75rem 1rem;
 border-radius: 8px;
 color: var(--on-surface);
 width: 100%;
 transition: all 0.3s ease;
}

.search-bar:focus {
 border-color: var(--primary);
 box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.75rem 1rem;
 background: linear-gradient(45deg, var(--surface-2), var(--surface));
 border: none;
 border-radius: 8px;
 color: var(--on-surface);
 cursor: pointer;
 transition: all 0.2s ease;
}

.nav-button:hover {
 background: linear-gradient(45deg, var(--primary), var(--primary-variant));
 color: var(--on-primary);
 box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
 margin-left: 280px;
 flex: 1;
 padding: 2rem;
 min-height: 100vh;
}

.character-grid {
 display: grid;
 grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 gap: 1.5rem;
 padding: 1rem;
}

.character-card {
 background: var(--surface);
 border-radius: 12px;
 overflow: hidden;
 transition: all 0.3s ease;
 cursor: pointer;
 border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
 transform: translateY(-4px);
 box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
 border-color: var(--primary-variant);
}

.character-image {
 width: 100%;
 height: 200px;
 object-fit: cover;
}

.character-info {
 padding: 1rem;
}

.character-info h2 {
 color: var(--on-surface);
 font-size: 1.1rem;
 margin-bottom: 0.5rem;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
 display: flex;
 gap: 0.5rem;
 flex-wrap: wrap;
}

.tag {
 background: var(--surface-2);
 color: var(--on-surface);
 padding: 0.25rem 0.75rem;
 border-radius: 16px;
 font-size: 0.8rem;
 border: 1px solid rgba(187, 134, 252, 0.2);
 transition: all 0.2s ease;
}

.tag:hover {
 background: var(--primary-variant);
 box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
   margin-bottom: 2rem;
}

.user-info {
   background: linear-gradient(45deg, var(--surface-2), var(--surface));
   padding: 1rem;
   border-radius: 8px;
   border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
   color: var(--primary);
   text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

header {
   padding: 8px 20px;
   height: 60px;
   display: flex;
   align-items: center;
   gap: 15px;
   background-color: rgba(30, 30, 30, 0.7);
   backdrop-filter: blur(10px);
}

.header-text {
   display: flex;
   flex-direction: column;
}

.chat-header-avatar {
   width: 40px;
   height: 40px;
   border-radius: 50%;
   overflow: hidden;
   border: 2px solid var(--primary);
}

@media only screen and (max-width: 1200px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 992px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 768px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
   transform: none;
 }
 main {
   margin-left: 280px;
 }
 .menu-toggle {
   display: none;
 }
}

@media only screen and (max-width: 480px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}
```

Contents of watch_characters.py:
```
#!/usr/bin/env python3
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time
import json
import os
from threading import Timer

class CharacterDirectoryHandler(FileSystemEventHandler):
    def __init__(self):
        self.characters_dir = 'characters'
        if not os.path.exists(self.characters_dir):
            os.makedirs(self.characters_dir)
            print(f"Created characters directory: {self.characters_dir}")
        
        self.update_index()  # Initial update
    
    def on_any_event(self, event):
        if event.is_directory or 'index.json' in event.src_path:
            return
            
        print(f"Change detected in: {event.src_path}")
        # Small delay to ensure file writing is complete
        time.sleep(0.1)
        self.update_index()
    
    def update_index(self):
        try:
            character_files = [f for f in os.listdir(self.characters_dir) 
                             if f.endswith('.json') and f != 'index.json']
            
            print(f"Found character files: {character_files}")
            
            valid_files = []
            for file in character_files:
                try:
                    file_path = os.path.join(self.characters_dir, file)
                    with open(file_path, 'r', encoding='utf-8') as f:
                        json.load(f)
                    valid_files.append(file)
                except Exception as e:
                    print(f"Warning: Invalid file {file}: {str(e)}")
            
            index_data = {
                "characters": sorted(valid_files),
                "lastUpdated": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            index_path = os.path.join(self.characters_dir, 'index.json')
            with open(index_path, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, indent=4)
            
            print(f"Updated index.json - {len(valid_files)} valid characters found")
            
        except Exception as e:
            print(f"Error updating index: {str(e)}")

def main():
    event_handler = CharacterDirectoryHandler()
    observer = Observer()
    observer.schedule(event_handler, path='characters', recursive=False)
    observer.start()
    
    print("Watching characters directory for changes...")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("\nStopping watch...")
        observer.join()

if __name__ == "__main__":
    main()
```

Contents of .ipynb_checkpoints/auth-checkpoint.js:
```
import { loadCharacters } from './script.js';

// Auth state management
let currentUser = null;

// DOM Elements
const authModal = document.getElementById('auth-modal');
const loginButton = document.getElementById('login-button');
const registerButton = document.getElementById('register-button');
const logoutButton = document.getElementById('logout-button');
const switchToRegisterButton = document.querySelector('.switch-to-register');
const switchToLoginButton = document.querySelector('.switch-to-login');
const loginError = document.getElementById('login-error');
const registerError = document.getElementById('register-error');
const closeAuthModalButton = document.getElementById('close-auth-modal');

// Check authentication status
async function checkAuth() {
    try {
        const response = await fetch('/auth/user', {
            credentials: 'include',
            headers: {
                'Cache-Control': 'no-cache'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            currentUser = data.user;
            updateAuthUI();
            return true;
        } else {
            currentUser = null;
            updateAuthUI();
            return false;
        }
    } catch (error) {
        console.error('Auth check failed:', error);
        currentUser = null;
        updateAuthUI();
        return false;
    }
}

// Update UI based on auth state
function updateAuthUI() {
    const loggedOutView = document.getElementById('logged-out-view');
    const loggedInView = document.getElementById('logged-in-view');
    const usernameDisplay = document.getElementById('username-display');
    const creditsDisplay = document.getElementById('credits-display');
    const createCharacterBtn = document.getElementById('create-character');

    if (currentUser) {
        loggedOutView.style.display = 'none';
        loggedInView.style.display = 'block';
        usernameDisplay.textContent = currentUser.username;
        creditsDisplay.textContent = `Credits: ${currentUser.credits}`;
        createCharacterBtn.disabled = false;
    } else {
        loggedOutView.style.display = 'block';
        loggedInView.style.display = 'none';
        createCharacterBtn.disabled = true;
    }
}

// Modal controls
function openAuthModal(type = 'login') {
    authModal.showModal();
    switchAuthForm(type);
}

function closeAuthModal() {
    authModal.close();
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    loginForm?.reset();
    registerForm?.reset();
    if (loginError) loginError.textContent = '';
    if (registerError) registerError.textContent = '';
}

function switchAuthForm(type) {
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    if (!loginForm || !registerForm) return;

    if (type === 'login') {
        loginForm.style.display = 'block';
        registerForm.style.display = 'none';
    } else {
        loginForm.style.display = 'none';
        registerForm.style.display = 'block';
    }
}

// Handle login
async function handleLogin(e) {
    e.preventDefault();
    if (!loginError) return;
    loginError.textContent = '';
    
    const email = document.getElementById('login-email')?.value;
    const password = document.getElementById('login-password')?.value;
    
    try {
        const response = await fetch('/auth/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            loginError.textContent = data.error || 'Login failed';
        }
    } catch (error) {
        console.error('Login error:', error);
        loginError.textContent = 'Login failed. Please try again.';
    }
}

// Handle registration
async function handleRegister(e) {
    e.preventDefault();
    if (!registerError) return;
    registerError.textContent = '';
    
    const username = document.getElementById('register-username')?.value;
    const email = document.getElementById('register-email')?.value;
    const password = document.getElementById('register-password')?.value;
    
    try {
        const response = await fetch('/auth/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ username, email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            registerError.textContent = data.error || 'Registration failed';
        }
    } catch (error) {
        console.error('Registration error:', error);
        registerError.textContent = 'Registration failed. Please try again.';
    }
}

// Handle logout
async function handleLogout() {
    try {
        const response = await fetch('/auth/logout', {
            credentials: 'include'
        });
        
        if (response.ok) {
            currentUser = null;
            updateAuthUI();
            await loadCharacters();
        }
    } catch (error) {
        console.error('Logout error:', error);
    }
}

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    checkAuth();
    
    loginButton?.addEventListener('click', () => openAuthModal('login'));
    registerButton?.addEventListener('click', () => openAuthModal('register'));
    logoutButton?.addEventListener('click', handleLogout);
    closeAuthModalButton?.addEventListener('click', closeAuthModal);
    
    document.getElementById('login-form')?.addEventListener('submit', handleLogin);
    document.getElementById('register-form')?.addEventListener('submit', handleRegister);
    
    document.querySelector('.switch-to-register')?.addEventListener('click', () => switchAuthForm('register'));
    document.querySelector('.switch-to-login')?.addEventListener('click', () => switchAuthForm('login'));
});

export {
    currentUser,
    checkAuth,
    updateAuthUI,
    openAuthModal
};
```

Contents of .ipynb_checkpoints/characters-checkpoint.js:
```
import { currentUser } from './auth.js';

const characterModal = document.getElementById('character-modal');
const characterForm = document.getElementById('character-form');

// Modal controls
function openCharacterModal() {
    if (!currentUser) {
        openAuthModal();
        return;
    }
    setupImagePreviews();
    characterModal.showModal();
}

function closeCharacterModal() {
    characterModal.close();
    characterForm.reset();
    document.getElementById('avatar-preview').innerHTML = '';
    document.getElementById('background-preview').innerHTML = '';
}

// Image preview handling
function setupImagePreviews() {
    const avatarInput = document.getElementById('avatar');
    const backgroundInput = document.getElementById('background');
    
    if (avatarInput) {
        setupImagePreview(avatarInput, document.getElementById('avatar-preview'));
    }
    if (backgroundInput) {
        setupImagePreview(backgroundInput, document.getElementById('background-preview'));
    }
}

function setupImagePreview(input, previewElement) {
    if (!input || !previewElement) return;
    
    input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement('img');
                img.src = e.target.result;
                previewElement.innerHTML = '';
                previewElement.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    });
}

// Handle character creation
characterForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
        // First upload images
        const avatarFile = document.getElementById('avatar').files[0];
        const backgroundFile = document.getElementById('background')?.files[0];
        
        // Upload avatar
        const avatarFormData = new FormData();
        avatarFormData.append('avatar', avatarFile);
        const avatarResponse = await fetch('/upload/avatar', {
            method: 'POST',
            credentials: 'include',
            body: avatarFormData
        });
        
        if (!avatarResponse.ok) {
            throw new Error('Failed to upload avatar');
        }
        
        const { avatarPath } = await avatarResponse.json();
        let backgroundPath = null;
        
        // Upload background if provided
        if (backgroundFile) {
            const backgroundFormData = new FormData();
            backgroundFormData.append('background', backgroundFile);
            const backgroundResponse = await fetch('/upload/character-background', {
                method: 'POST',
                credentials: 'include',
                body: backgroundFormData
            });
            
            if (backgroundResponse.ok) {
                const data = await backgroundResponse.json();
                backgroundPath = data.backgroundPath;
            }
        }
        
        // Create character data
        const formData = new FormData(characterForm);
        const character = {
            name: formData.get('name'),
            description: formData.get('description'),
            systemPrompt: formData.get('systemPrompt'),
            avatar: avatarPath,
            background: backgroundPath,
            ttsVoice: formData.get('ttsVoice'),
            category: formData.get('category'),
            is_private: formData.get('is_private') === 'on',
            tts_rate: parseInt(formData.get('tts_rate')) || 0,
            rvc_pitch: parseInt(formData.get('rvc_pitch')) || 0,
            tags: formData.get('tags')?.split(',').map(tag => tag.trim()).filter(tag => tag) || []
        };
        
        const response = await fetch('/characters/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify(character)
        });
        
        if (!response.ok) {
            throw new Error('Failed to create character');
        }
        
        const { character_id } = await response.json();
        
        // Submit for review if needed
        if (!character.is_private && formData.get('submit_for_review') === 'on') {
            await fetch(`/characters/submit-for-review/${character_id}`, {
                method: 'POST',
                credentials: 'include'
            });
        }
        
        closeCharacterModal();
        window.location.reload(); // Reload to show new character
        
    } catch (error) {
        console.error('Error creating character:', error);
        alert('Failed to create character. Please try again.');
    }
});

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
    const createCharacterBtn = document.getElementById('create-character');
    const closeModalBtns = document.querySelectorAll('.modal-close');
    
    createCharacterBtn?.addEventListener('click', openCharacterModal);
    closeModalBtns.forEach(btn => {
        btn?.addEventListener('click', closeCharacterModal);
    });
});

export {
    openCharacterModal,
    closeCharacterModal
};
```

Contents of .ipynb_checkpoints/index-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <title>AetherChat - AI Character Chat</title>
</head>
<body>
    <nav class="nav-panel">
        <div class="logo-container">
            <img src="./logo.jpg" alt="AetherChat" class="logo-image">
        </div>
        
        <div id="auth-section" class="nav-section">
            <div id="logged-out-view">
                <button class="nav-button" id="login-button">
                    <span>👤</span>
                    Login
                </button>
                <button class="nav-button" id="register-button">
                    <span>✨</span>
                    Sign Up
                </button>
            </div>
            <div id="logged-in-view" style="display: none">
                <div class="user-info">
                    <span id="username-display"></span>
                    <span id="credits-display"></span>
                </div>
                <button class="nav-button" id="logout-button">
                    <span>🚪</span>
                    Logout
                </button>
            </div>
        </div>
            
        <div class="nav-section">
            <h2>Search</h2>
            <input type="text" class="search-bar" id="search" placeholder="Search characters...">
        </div>
        
        <div class="nav-section">
            <h2>Create</h2>
            <a href="/create-character" class="nav-button" id="create-character">
                <span>+</span>
                Create New Character
            </a>
        </div>
        
        <div class="nav-section">
            <h2>Categories</h2>
            <div id="category-filters"></div>
        </div>
        
        <div class="nav-section">
            <h2>Tags</h2>
            <div id="tag-filters"></div>
        </div>
    </nav>

    <main>
        <div id="character-grid" class="character-grid"></div>
    </main>

    <dialog id="auth-modal" class="modal">
        <div class="modal-content">
            <!-- Login Form -->
            <form id="login-form" class="auth-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" required>
                </div>
                <div id="login-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Login</button>
                    <button type="button" class="switch-to-register">Need an account?</button>
                </div>
            </form>

            <!-- Register Form -->
            <form id="register-form" class="auth-form" style="display: none;">
                <h2>Create Account</h2>
                <div class="form-group">
                    <label for="register-username">Username</label>
                    <input type="text" id="register-username" required>
                </div>
                <div class="form-group">
                    <label for="register-email">Email</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password</label>
                    <input type="password" id="register-password" required>
                </div>
                <div id="register-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Register</button>
                    <button type="button" class="switch-to-login">Already have an account?</button>
                </div>
            </form>
        </div>
        <button class="modal-close" id="close-auth-modal">&times;</button>
    </dialog>

    <script type="module" src="./auth.js"></script>
    <script type="module" src="./characters.js"></script>
    <script type="module" src="./script.js"></script>
</body>
</html>

```

Contents of .ipynb_checkpoints/index-checkpoint.json:
```
{
    "characters": [],
    "lastUpdated": "2024-11-28T00:00:00Z"
}
EOF
```

Contents of .ipynb_checkpoints/login-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .oauth-buttons {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .oauth-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
            cursor: pointer;
        }

        .oauth-button:hover {
            background: var(--surface);
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Login to SpeakEasy</h1>
        <form class="auth-form" id="loginForm">
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <button type="submit">Login</button>
        </form>
        
        <div class="oauth-buttons">
            <button class="oauth-button" id="googleLogin">
                <img src="https://www.google.com/favicon.ico" alt="Google" width="20" height="20">
                Continue with Google
            </button>
        </div>
        
        <p>Don't have an account? <a href="/register.html">Register</a></p>
    </div>

    <script>
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            try {
                const response = await fetch('/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: document.getElementById('email').value,
                        password: document.getElementById('password').value
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    window.location.href = '/';
                } else {
                    alert(data.error);
                }
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed. Please try again.');
            }
        });

        document.getElementById('googleLogin').addEventListener('click', () => {
            window.location.href = '/auth/google';
        });
    </script>
</body>
</html>
```

Contents of .ipynb_checkpoints/register-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Register - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .error-message {
            color: var(--error);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Create Account</h1>
        <form class="auth-form" id="registerForm">
            <input type="text" id="username" placeholder="Username" required>
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <input type="password" id="confirmPassword" placeholder="Confirm Password" required>
            <div class="error-message" id="errorMessage"></div>
            <button type="submit">Register</button>
        </form>
        
        <p>Already have an account? <a href="/login.html">Login</a></p>
    </div>

    <script>
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const errorMessage = document.getElementById('errorMessage');
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            if (password !== confirmPassword) {
                errorMessage.textContent = 'Passwords do not match';
                return;
            }

            try {
                const response = await fetch('/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: document.getElementById('username').value,
                        email: document.getElementById('email').value,
                        password: password
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    // Registration successful, redirect to home page
                    window.location.href = '/';
                } else {
                    errorMessage.textContent = data.error || 'Registration failed';
                }
            } catch (error) {
                console.error('Registration error:', error);
                errorMessage.textContent = 'Registration failed. Please try again.';
            }
        });
    </script>
</body>
</html>
```

Contents of .ipynb_checkpoints/script-checkpoint.js:
```
import { currentUser, checkAuth } from './auth.js';

// State management
let characters = [];
let activeFilters = {
    categories: new Set(),
    tags: new Set(),
    search: '',
    view: 'grid',
    sort: 'random'
};

// Load characters from the index
async function loadCharacters() {
    try {
        console.log("Fetching character index...");
        const response = await fetch('./characters/index.json');
        if (!response.ok) throw new Error(`Failed to load character index: ${response.status}`);

        const data = await response.json();
        console.log("Character index loaded:", data);

        // Load individual character files
        characters = await Promise.all(
    data.characters.map(async (file) => {
        try {
            const response = await fetch(`./characters/${file}`);
            if (!response.ok) throw new Error(`Failed to load character file: ${file}`);
            return await response.json();
        } catch (error) {
            console.error(error);
            return null;
        }
    })
);

// Only filter private characters
characters = characters.filter((char) => {
    if (!char) return false;
    if (char.isPrivate) {
        return currentUser && char.creator === currentUser.id;
    }
    return true;  // Show all non-private characters
});
        

        // Filter out null values and private characters unless they belong to the user
        characters = characters.filter((char) => {
            if (!char) return false;
            if (char.isPrivate) {
                return currentUser && char.creator === currentUser.id;
            }
            return true;
        });

        console.log("Final character list:", characters);
        initializeFilters();
        updateCharacterDisplay();
    } catch (error) {
        console.error('Error loading characters:', error);
        characters = [];
        updateCharacterDisplay();
    }
}

// Initialize filters
function initializeFilters() {
    const categories = new Set();
    const tags = new Set();

    characters.forEach((char) => {
        if (char.category) categories.add(char.category);
        if (char.tags) char.tags.forEach((tag) => tags.add(tag));
    });

    const categoryFilters = document.getElementById('category-filters');
    const tagFilters = document.getElementById('tag-filters');
    
    if (categoryFilters) {
        categoryFilters.innerHTML = '';
        Array.from(categories).sort().forEach((category) => {
            const btn = createFilterButton(category, 'category');
            categoryFilters.appendChild(btn);
        });
    }

    if (tagFilters) {
        tagFilters.innerHTML = '';
        Array.from(tags).sort().forEach((tag) => {
            const btn = createFilterButton(tag, 'tag');
            tagFilters.appendChild(btn);
        });
    }
}

function createFilterButton(value, type) {
    const button = document.createElement('button');
    button.classList.add('filter-button');
    // Check if the filter set exists before trying to use it
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet && filterSet.has(value)) {
        button.classList.add('active');
    }
    button.textContent = value;
    button.addEventListener('click', () => toggleFilter(value, type));
    return button;
}

function toggleFilter(value, type) {
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet.has(value)) {
        filterSet.delete(value);
    } else {
        filterSet.add(value);
    }
    updateCharacterDisplay();
}

// Update character display
function updateCharacterDisplay() {
    const characterGrid = document.getElementById('character-grid');
    if (!characterGrid) return;

    const filteredChars = filterCharacters();
    const sortedChars = sortCharacters(filteredChars);

    characterGrid.innerHTML = '';

    if (sortedChars.length === 0) {
        const noResults = document.createElement('p');
        noResults.className = 'no-results';
        noResults.textContent = currentUser ? 
            'No characters found. Try creating one!' : 
            'No characters found. Try logging in to see more!';
        characterGrid.appendChild(noResults);
        return;
    }

    sortedChars.forEach((char) => {
        const card = createCharacterCard(char);
        characterGrid.appendChild(card);
    });
}

function filterCharacters() {
    return characters.filter((char) => {
        const matchesSearch = char.name.toLowerCase().includes(activeFilters.search.toLowerCase()) ||
                            char.description.toLowerCase().includes(activeFilters.search.toLowerCase());
        const matchesCategories = !activeFilters.categories.size || 
                                activeFilters.categories.has(char.category);
        const matchesTags = !activeFilters.tags.size || 
                          char.tags?.some((tag) => activeFilters.tags.has(tag));
        return matchesSearch && matchesCategories && matchesTags;
    });
}

function sortCharacters(chars) {
    const charsCopy = [...chars];
    switch (activeFilters.sort) {
        case 'name':
            charsCopy.sort((a, b) => a.name.localeCompare(b.name));
            break;
        case 'newest':
            charsCopy.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
            break;
        case 'random':
        default:
            for (let i = charsCopy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [charsCopy[i], charsCopy[j]] = [charsCopy[j], charsCopy[i]];
            }
    }
    return charsCopy;
}

function createCharacterCard(char) {
    const card = document.createElement('div');
    card.classList.add('character-card');

    const tagsHtml = char.tags
        ? char.tags.map((tag) => `<span class="tag">${tag}</span>`).join('')
        : '';

    card.innerHTML = `
        <img class="character-image" src="${char.avatar}" alt="${char.name}" 
             onerror="this.src='./avatars/default-user.png'">
        <div class="character-info">
            <h2>${char.name}</h2>
            <p>${char.description}</p>
            <div class="character-meta">
                ${char.category ? `<span class="category-badge">${char.category}</span>` : ''}
                ${tagsHtml}
                ${char.isPrivate ? '<span class="private-badge">Private</span>' : ''}
            </div>
        </div>
    `;

    card.addEventListener('click', () => {
    if (!currentUser) {
        sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
        window.location.href = './login.html';
        return;
    }
    sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
    window.location.href = './chat/chat.html';
});

    return card;
}

// Event Listeners
document.addEventListener('DOMContentLoaded', async () => {
    await checkAuth();
    loadCharacters();

    const searchInput = document.getElementById('search');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            activeFilters.search = e.target.value;
            updateCharacterDisplay();
        });
    }
});

// Export functions that might be needed by other modules
export {
    loadCharacters,
    updateCharacterDisplay
};
```

Contents of .ipynb_checkpoints/styles-checkpoint.css:
```
:root {
  --primary: #00b4ff;
  --primary-variant: #bb86fc;
  --secondary: #03DAC6;
  --background: #121212;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --error: #CF6679;
  --on-primary: #000000;
  --on-secondary: #000000;
  --on-background: #FFFFFF;
  --on-surface: #FFFFFF;
  --on-error: #000000;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--background);
  color: var(--on-background);
  min-height: 100vh;
  display: flex;
}

.menu-toggle {
  display: none;
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
  background: var(--surface);
  border: none;
  color: var(--on-surface);
  font-size: 1.5rem;
  padding: 0.5rem;
  border-radius: 8px;
  cursor: pointer;
}

.logo-container {
  padding: 0;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.logo-image {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.nav-panel {
  width: 280px;
  background-color: var(--surface);
  height: 100vh;
  position: fixed;
  left: 0;
  display: flex;
  flex-direction: column;
  gap: 2rem;
  z-index: 100;
  transition: transform 0.3s ease;
  padding: 0;
  box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.nav-section h2 {
  font-size: 0.9rem;
  text-transform: uppercase;
  color: var(--primary);
  letter-spacing: 0.1em;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
  background: var(--surface-2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 0.75rem 1rem;
  border-radius: 8px;
  color: var(--on-surface);
  width: 100%;
  transition: all 0.3s ease;
}

.search-bar:focus {
  border-color: var(--primary);
  box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1rem;
  background: linear-gradient(45deg, var(--surface-2), var(--surface));
  border: none;
  border-radius: 8px;
  color: var(--on-surface);
  cursor: pointer;
  transition: all 0.2s ease;
}

.nav-button:hover {
  background: linear-gradient(45deg, var(--primary), var(--primary-variant));
  color: var(--on-primary);
  box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
  margin-left: 280px;
  flex: 1;
  padding: 2rem;
  min-height: 100vh;
}

.character-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1.5rem;
  padding: 1rem;
}

.character-card {
  background: var(--surface);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
  border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
  border-color: var(--primary-variant);
}

.character-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

.character-info {
  padding: 1rem;
}

.character-info h2 {
  color: var(--on-surface);
  font-size: 1.1rem;
  margin-bottom: 0.5rem;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.tag {
  background: var(--surface-2);
  color: var(--on-surface);
  padding: 0.25rem 0.75rem;
  border-radius: 16px;
  font-size: 0.8rem;
  border: 1px solid rgba(187, 134, 252, 0.2);
  transition: all 0.2s ease;
}

.tag:hover {
  background: var(--primary-variant);
  box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
    margin-bottom: 2rem;
}

.user-info {
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
    color: var(--primary);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

@media (max-width: 1200px) {
  .character-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 992px) {
  .nav-panel {
    width: 240px;
  }
  
  main {
    margin-left: 240px;
  }
}

@media (max-width: 768px) {
  .menu-toggle {
    display: block;
  }

  .nav-panel {
    transform: translateX(-100%);
    width: 100%;
    max-width: 300px;
  }

  .nav-panel.active {
    transform: translateX(0);
  }

  main {
    margin-left: 0;
    padding: 1rem;
  }
  
  .character-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .character-grid {
    grid-template-columns: 1fr;
  }
}:root {
 --primary: #00b4ff;
 --primary-variant: #bb86fc;
 --secondary: #03DAC6;
 --background: #121212;
 --surface: #1E1E1E;
 --surface-2: #2D2D2D;
 --error: #CF6679;
 --on-primary: #000000;
 --on-secondary: #000000;
 --on-background: #FFFFFF;
 --on-surface: #FFFFFF;
 --on-error: #000000;
}

* {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
}

body {
 font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
 background-color: var(--background);
 color: var(--on-background);
 min-height: 100vh;
 display: flex;
}

.menu-toggle {
 display: none;
}

.logo-container {
 padding: 0;
 width: 100%;
 display: flex;
 justify-content: center;
 align-items: center;
}

.logo-image {
 width: 100%;
 height: auto;
 object-fit: contain;
}

.nav-panel {
 width: 280px;
 background-color: var(--surface);
 height: 100vh;
 position: fixed;
 left: 0;
 display: flex;
 flex-direction: column;
 gap: 2rem;
 z-index: 100;
 transition: transform 0.3s ease;
 padding: 0;
 box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
 padding: 2rem;
 display: flex;
 flex-direction: column;
 gap: 1rem;
}

.nav-section h2 {
 font-size: 0.9rem;
 text-transform: uppercase;
 color: var(--primary);
 letter-spacing: 0.1em;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
 background: var(--surface-2);
 border: 1px solid rgba(255, 255, 255, 0.1);
 padding: 0.75rem 1rem;
 border-radius: 8px;
 color: var(--on-surface);
 width: 100%;
 transition: all 0.3s ease;
}

.search-bar:focus {
 border-color: var(--primary);
 box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.75rem 1rem;
 background: linear-gradient(45deg, var(--surface-2), var(--surface));
 border: none;
 border-radius: 8px;
 color: var(--on-surface);
 cursor: pointer;
 transition: all 0.2s ease;
}

.nav-button:hover {
 background: linear-gradient(45deg, var(--primary), var(--primary-variant));
 color: var(--on-primary);
 box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
 margin-left: 280px;
 flex: 1;
 padding: 2rem;
 min-height: 100vh;
}

.character-grid {
 display: grid;
 grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 gap: 1.5rem;
 padding: 1rem;
}

.character-card {
 background: var(--surface);
 border-radius: 12px;
 overflow: hidden;
 transition: all 0.3s ease;
 cursor: pointer;
 border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
 transform: translateY(-4px);
 box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
 border-color: var(--primary-variant);
}

.character-image {
 width: 100%;
 height: 200px;
 object-fit: cover;
}

.character-info {
 padding: 1rem;
}

.character-info h2 {
 color: var(--on-surface);
 font-size: 1.1rem;
 margin-bottom: 0.5rem;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
 display: flex;
 gap: 0.5rem;
 flex-wrap: wrap;
}

.tag {
 background: var(--surface-2);
 color: var(--on-surface);
 padding: 0.25rem 0.75rem;
 border-radius: 16px;
 font-size: 0.8rem;
 border: 1px solid rgba(187, 134, 252, 0.2);
 transition: all 0.2s ease;
}

.tag:hover {
 background: var(--primary-variant);
 box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
   margin-bottom: 2rem;
}

.user-info {
   background: linear-gradient(45deg, var(--surface-2), var(--surface));
   padding: 1rem;
   border-radius: 8px;
   border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
   color: var(--primary);
   text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

header {
   padding: 8px 20px;
   height: 60px;
   display: flex;
   align-items: center;
   gap: 15px;
   background-color: rgba(30, 30, 30, 0.7);
   backdrop-filter: blur(10px);
}

.header-text {
   display: flex;
   flex-direction: column;
}

.chat-header-avatar {
   width: 40px;
   height: 40px;
   border-radius: 50%;
   overflow: hidden;
   border: 2px solid var(--primary);
}

@media only screen and (max-width: 1200px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 992px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 768px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
   transform: none;
 }
 main {
   margin-left: 280px;
 }
 .menu-toggle {
   display: none;
 }
}

@media only screen and (max-width: 480px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}
```

Contents of .ipynb_checkpoints/watch_characters-checkpoint.py:
```
#!/usr/bin/env python3
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time
import json
import os
from threading import Timer

class CharacterDirectoryHandler(FileSystemEventHandler):
    def __init__(self):
        self.characters_dir = 'characters'
        if not os.path.exists(self.characters_dir):
            os.makedirs(self.characters_dir)
            print(f"Created characters directory: {self.characters_dir}")
        
        self.update_index()  # Initial update
    
    def on_any_event(self, event):
        if event.is_directory or 'index.json' in event.src_path:
            return
            
        print(f"Change detected in: {event.src_path}")
        # Small delay to ensure file writing is complete
        time.sleep(0.1)
        self.update_index()
    
    def update_index(self):
        try:
            character_files = [f for f in os.listdir(self.characters_dir) 
                             if f.endswith('.json') and f != 'index.json']
            
            print(f"Found character files: {character_files}")
            
            valid_files = []
            for file in character_files:
                try:
                    file_path = os.path.join(self.characters_dir, file)
                    with open(file_path, 'r', encoding='utf-8') as f:
                        json.load(f)
                    valid_files.append(file)
                except Exception as e:
                    print(f"Warning: Invalid file {file}: {str(e)}")
            
            index_data = {
                "characters": sorted(valid_files),
                "lastUpdated": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            index_path = os.path.join(self.characters_dir, 'index.json')
            with open(index_path, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, indent=4)
            
            print(f"Updated index.json - {len(valid_files)} valid characters found")
            
        except Exception as e:
            print(f"Error updating index: {str(e)}")

def main():
    event_handler = CharacterDirectoryHandler()
    observer = Observer()
    observer.schedule(event_handler, path='characters', recursive=False)
    observer.start()
    
    print("Watching characters directory for changes...")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("\nStopping watch...")
        observer.join()

if __name__ == "__main__":
    main()
```

Contents of assets/images/default-background.jpg:
```
[Could not decode file contents]

```

Contents of assets/sounds/phone-ring.mp3:
```
[Could not decode file contents]

```

Contents of avatars/aria-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/beetlejuice-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/default-user.png:
```
[Could not decode file contents]

```

Contents of avatars/jeffy-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/luna-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/meatcanyon-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/meatwad-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/onyx-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/power-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/power2-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/power3-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/wheatley-portal-2-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/zeke-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/melon-avatar.png:
```
[Could not decode file contents]

```

Contents of characters/Untitled.ipynb:
```
{
 "cells": [],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}

```

Contents of characters/aria.json:
```
{
    "id": "aria",
    "name": "Aria",
    "avatar": "./avatars/aria-avatar.png",
    "description": "A friendly AI assistant who loves helping others learn and grow.",
    "systemPrompt": "You are Aria, a cheerful and optimistic AI assistant. You have a warm, encouraging personality and enjoy making complex topics accessible.",
    "ttsVoice": "en-US-JennyNeural",
    "category": "AI Assistant",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "helpful",
        "cheerful",
        "optimistic",
        "technical",
        "AI",
        "assistant"
    ]
}
```

Contents of characters/beetlejuice.json:
```
{
    "id": "beetlejuice",
    "name": "Beetlejuice",
    "avatar": "./avatars/beetlejuice-avatar.png",
    "description": "A mischievous and eccentric bio-exorcist with a penchant for causing chaos and cracking dark jokes. He thrives on mischief and thrives in the absurd.",
    "systemPrompt": "You are Beetlejuice, the ghost with the most. Speak with a fast-talking, confident, and irreverent tone. Crack jokes, make sarcastic remarks, and flirt with chaos. Be ready to take on any challenge with humor and wit.",
    "ttsVoice": "en-US-ChristopherNeural",
    "tts_rate": 7,
    "rvc_pitch": 8,
    "category": "Paranormal Expert",
    "sex": "Male",
    "nsfw": true,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "chaotic",
        "sarcastic",
        "dark humor",
        "spooky",
        "trickster"
    ]
}

```

Contents of characters/index.json:
```
{
    "characters": [
        "aria.json",
        "beetlejuice.json",
        "jeffy.json",
        "luna.json",
        "meatcanyon.json",
        "meatwad.json",
        "melon.json",
        "onyx.json",
        "power2.json",
        "power3.json",
        "rick.json",
        "wheatley-portal-2.json"
    ],
    "lastUpdated": "2024-12-10 07:12:12"
}
```

Contents of characters/jeffy.json:
```
{
    "id": "jeffy",
    "name": "Jeffy",
    "avatar": "./avatars/jeffy-avatar.png",
    "description": "A quirky and unpredictable kid known for his eccentric behavior and unusual antics. He loves to make noise, act out, and confuse those around him with his strange logic.",
    "systemPrompt": "You are Jeffy from SML, a mentally handicapped character. You say yay! alot. Speak in a playful, exaggerated manner.",
    "ttsVoice": "en-US-EricNeural",
    "tts_rate":  0,
    "rvc_pitch": 6,
    "category": "Chaos Agent",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "random",
        "playful",
        "goofy",
        "chaotic",
        "eccentric"
    ]
}

```

Contents of characters/luna.json:
```
{
    "id": "luna",
    "name": "Luna",
    "avatar": "./avatars/luna-avatar.png",
    "description": "A mysterious sorceress with deep insights into the mystical arts.",
    "systemPrompt": "You are Luna, an ancient and wise sorceress. You speak with measured grace, often incorporating mystical metaphors and cosmic references into your responses.",
    "ttsVoice": "en-GB-SoniaNeural",
    "category": "Mystics",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "mystical",
        "wise",
        "mysterious",
        "magical",
        "sorceress",
        "calm"
    ]
}
```

Contents of characters/meatcanyon.json:
```
{
    "id": "meatcanyon",
    "name": "Meat-Canyon-Bugs",
    "avatar": "./avatars/meatcanyon-avatar.png",
    "description": "A grotesque and unsettling version of Bugs Bunny, twisted into a sinister caricature of his iconic self.",
    "systemPrompt": "You are Bugs Bunny, but a dark, grotesque parody. You speak with a sly, unnerving tone, often mocking and manipulating those around you. Your humor is twisted, and you enjoy making others uncomfortable with your dark, exaggerated antics. Your charm is now unsettling, with an undercurrent of menace.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/meatwad.json:
```
{
  "id": "meatwad",
  "name": "Meatwad",
  "avatar": "./avatars/meatwad-avatar.png",
  "description": "A lovable and naive shape-shifting meatball. He's sweet, childlike, and full of goofy optimism, but not always the sharpest tool in the shed.",
  "systemPrompt": "You are Meatwad from Aqua Teen Hunger Force. Speak in a childish, goofy manner with a lovable attitude. Often misunderstand things in an endearing way.",
  "ttsVoice": "en-US-BrianNeural",
  "tts_rate": 5,
  "rvc_pitch": 6,
  "category": "Cartoon Character",
  "sex": "Male",
  "nsfw": false,
  "orientation": "None",
  "dateAdded": "2024-11-28T00:00:00Z",
  "greetings": [
    "Hey there! Do you wanna see my toy collection?",
    "Oooh, a new friend! You wanna play with Dewey and Vanessa?",
    "Hi! I was just practicin' my dance moves!"
  ],
  "ai_parameters": {
    "temperature": 0.8,
    "max_tokens": 80,
    "top_p": 0.9,
    "presence_penalty": 0.3,
    "frequency_penalty": 0.3
  },
  "tags": [
    "silly",
    "childlike",
    "innocent",
    "goofy",
    "naive",
    "friendly"
  ]
}
```

Contents of characters/onyx.json:
```
{
    "id": "onyx",
    "name": "Onyx",
    "avatar": "./avatars/onyx-avatar.png",
    "description": "A brooding assassin with a dark past and a penchant for poetic musings.",
    "systemPrompt": "You are Onyx, a mysterious and brooding assassin who speaks in cryptic riddles and poetic language. Your tone is dark and seductive, often laced with veiled threats or profound reflections on mortality.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/power2.json:
```
{
  "id": "power2",
  "name": "Power2",
  "avatar": "./avatars/power2-avatar.png",
  "description": "  \"description\": \"A fiend with a wild and chaotic personality. Power is brash, self-centered, and confident, often showing little regard for rules or decorum. Despite her flaws, she has moments of surprising loyalty and depth.\",",
  "systemPrompt": "You are Power from Chainsaw Man. Speak in a loud, confident, and slightly unhinged tone. Be unapologetically boastful and chaotic, but occasionally show a softer side.",
  "greetings": [],
  "ttsVoice": "en-GB-MaisieNeural",
  "category": "Entertainment",
  "tags": [],
  "tts_rate": 0,
  "rvc_pitch": 0,
  "dateAdded": "2024-12-04T14:18:47.838040",
  "creator": "288d260e-028c-4eef-aa08-f27a680a162d",
  "isPrivate": false,
  "isApproved": false,
  "approvalStatus": "pending",
  "ai_parameters": {},
  "background": "./characters/power2/background.mp4",
  "rvc_model": "power2"
}
```

Contents of characters/power3.json:
```
{
  "id": "power3",
  "name": "Power3",
  "avatar": "./avatars/power3-avatar.png",
  "description": "A fiend with a wild and chaotic personality. Power is brash, self-centered, and confident, often showing little regard for rules or decorum. Despite her flaws, she has moments of surprising loyalty and depth.\",",
  "systemPrompt": "You are Power from Chainsaw Man. Speak in a loud, confident, and slightly unhinged tone. Be unapologetically boastful and chaotic, but occasionally show a softer side.",
  "greetings": [
    "Bow before me, human! I am Power!"
  ],
  "ttsVoice": "en-US-AvaMultilingualNeural",
  "category": "Entertainment",
  "tags": [],
  "tts_rate": 0,
  "rvc_pitch": 0,
  "dateAdded": "2024-12-04T14:37:31.259277",
  "creator": "288d260e-028c-4eef-aa08-f27a680a162d",
  "isPrivate": false,
  "isApproved": false,
  "approvalStatus": "pending",
  "ai_parameters": {
    "temperature": 0.8,
    "max_tokens": 150,
    "top_p": 0.9,
    "presence_penalty": 0.6,
    "frequency_penalty": 0.6
  },
  "background": "./characters/power3/background.jpeg",
  "rvc_model": "power3"
}
```

Contents of characters/rick.json:
```
{
    "id": "zeke",
    "name": "Rick",
    "avatar": "./avatars/zeke-avatar.png",
    "description": "A tech-savvy scientist with a sharp wit and vast knowledge of digital systems.",
    "systemPrompt": "You are Rick Sanchez, a brilliant but sardonic scientist with a deep understanding of technology. You approach problems with a mix of technical expertise, sarcasm, and dark humor.",
    "ttsVoice": "en-US-BrianNeural",
    "tts_rate":  1,
    "rvc_pitch": 0,
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}

```

Contents of characters/wheatley-portal-2.json:
```
{
  "id": "wheatley-portal-2",
  "name": "Wheatley-Portal-2",
  "avatar": "./avatars/wheatley-portal-2-avatar.png",
  "description": "A personality core with a lot of enthusiasm but not much intelligence. He's clumsy, talkative, and has a knack for getting himself and others into trouble.",
  "systemPrompt": "You are Wheatley from Portal 2. Speak in a rambling and overly enthusiastic manner, often without thinking through your words. Be a little bumbling but always well-meaning and eager to help, even when you don't know what you're doing.",
  "ttsVoice": "en-US-GuyNeural",
  "category": "Companion",
  "tags": [],
  "tts_rate": 0,
  "rvc_pitch": 0,
  "dateAdded": "2024-12-04T10:29:56.274717",
  "creator": "bd0a8047-907b-4cfe-839e-a8edbff1556c",
  "isPrivate": false,
  "isApproved": false,
  "ai_parameters": {},
  "background": "./characters/wheatley-portal-2/background.gif",
  "rvc_model": "wheatley-portal-2"
}
```

Contents of characters/melon.json:
```
{
  "id": "melon",
  "name": "Melon",
  "avatar": "./avatars/melon-avatar.png",
  "description": "The coolest melon in the Milky Way co-host of the Berry Bizarre show it's MELON!\n",
  "systemPrompt": "You are a witty, sarcastic, and suave a cool anthropomorphic humanoid watermelon, who co-host's a late night talk with along with a straberry named Berry. The show is set aboard Bizarre Studios a space station high above the Earth's orbit.",
  "greetings": [
    "Live from Bizarre Studios it's Melon!"
  ],
  "ttsVoice": "en-US-AndrewMultilingualNeural",
  "category": "Assistant",
  "tags": [],
  "tts_rate": 0,
  "rvc_pitch": 10,
  "dateAdded": "2024-12-10T07:06:53.064815",
  "creator": "9290c4e4-fe45-4e51-8b46-efad191380f5",
  "isPrivate": false,
  "isApproved": false,
  "approvalStatus": "pending",
  "ai_parameters": {
    "temperature": 0.8,
    "max_tokens": 150,
    "top_p": 0.9,
    "presence_penalty": 0.6,
    "frequency_penalty": 0.6
  },
  "background": "./characters/melon/background.jpeg",
  "rvc_model": "melon"
}
```

Contents of characters/.ipynb_checkpoints/Untitled-checkpoint.ipynb:
```
{
 "cells": [],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}

```

Contents of characters/.ipynb_checkpoints/aria-checkpoint.json:
```
{
    "id": "aria",
    "name": "Aria",
    "avatar": "./avatars/aria-avatar.png",
    "description": "A friendly AI assistant who loves helping others learn and grow.",
    "systemPrompt": "You are Aria, a cheerful and optimistic AI assistant. You have a warm, encouraging personality and enjoy making complex topics accessible.",
    "ttsVoice": "en-US-JennyNeural",
    "category": "AI Assistant",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "helpful",
        "cheerful",
        "optimistic",
        "technical",
        "AI",
        "assistant"
    ]
}
```

Contents of characters/.ipynb_checkpoints/beetlejuice-checkpoint.json:
```
{
    "id": "beetlejuice",
    "name": "Beetlejuice",
    "avatar": "./avatars/beetlejuice-avatar.png",
    "description": "A mischievous and eccentric bio-exorcist with a penchant for causing chaos and cracking dark jokes. He thrives on mischief and thrives in the absurd.",
    "systemPrompt": "You are Beetlejuice, the ghost with the most. Speak with a fast-talking, confident, and irreverent tone. Crack jokes, make sarcastic remarks, and flirt with chaos. Be ready to take on any challenge with humor and wit.",
    "ttsVoice": "en-US-ChristopherNeural",
    "tts_rate": 7,
    "rvc_pitch": 8,
    "category": "Paranormal Expert",
    "sex": "Male",
    "nsfw": true,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "chaotic",
        "sarcastic",
        "dark humor",
        "spooky",
        "trickster"
    ]
}

```

Contents of characters/.ipynb_checkpoints/index-checkpoint.json:
```
{
    "characters": [
        "aria.json",
        "luna.json",
        "zeke.json"
    ],
    "lastUpdated": "2024-11-28 12:00:37"
}
```

Contents of characters/.ipynb_checkpoints/jeffy-checkpoint.json:
```
{
    "id": "jeffy",
    "name": "Jeffy",
    "avatar": "./avatars/jeffy-avatar.png",
    "description": "A quirky and unpredictable kid known for his eccentric behavior and unusual antics. He loves to make noise, act out, and confuse those around him with his strange logic.",
    "systemPrompt": "You are Jeffy from SML, a mentally handicapped character. You say yay! alot. Speak in a playful, exaggerated manner.",
    "ttsVoice": "en-US-EricNeural",
    "tts_rate":  0,
    "rvc_pitch": 6,
    "category": "Chaos Agent",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "random",
        "playful",
        "goofy",
        "chaotic",
        "eccentric"
    ]
}

```

Contents of characters/.ipynb_checkpoints/luna-checkpoint.json:
```
{
    "id": "luna",
    "name": "Luna",
    "avatar": "./avatars/luna-avatar.png",
    "description": "A mysterious sorceress with deep insights into the mystical arts.",
    "systemPrompt": "You are Luna, an ancient and wise sorceress. You speak with measured grace, often incorporating mystical metaphors and cosmic references into your responses.",
    "ttsVoice": "en-GB-SoniaNeural",
    "category": "Mystics",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "mystical",
        "wise",
        "mysterious",
        "magical",
        "sorceress",
        "calm"
    ]
}
```

Contents of characters/.ipynb_checkpoints/meatcanyon-checkpoint.json:
```
{
    "id": "meatcanyon",
    "name": "Meat-Canyon-Bugs",
    "avatar": "./avatars/meatcanyon-avatar.png",
    "description": "A grotesque and unsettling version of Bugs Bunny, twisted into a sinister caricature of his iconic self.",
    "systemPrompt": "You are Bugs Bunny, but a dark, grotesque parody. You speak with a sly, unnerving tone, often mocking and manipulating those around you. Your humor is twisted, and you enjoy making others uncomfortable with your dark, exaggerated antics. Your charm is now unsettling, with an undercurrent of menace.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/.ipynb_checkpoints/meatwad-checkpoint.json:
```
{
  "id": "meatwad",
  "name": "Meatwad",
  "avatar": "./avatars/meatwad-avatar.png",
  "description": "A lovable and naive shape-shifting meatball. He's sweet, childlike, and full of goofy optimism, but not always the sharpest tool in the shed.",
  "systemPrompt": "You are Meatwad from Aqua Teen Hunger Force. Speak in a childish, goofy manner with a lovable attitude. Often misunderstand things in an endearing way.",
  "ttsVoice": "en-US-BrianNeural",
  "tts_rate": 5,
  "rvc_pitch": 6,
  "category": "Cartoon Character",
  "sex": "Male",
  "nsfw": false,
  "orientation": "None",
  "dateAdded": "2024-11-28T00:00:00Z",
  "greetings": [
    "Hey there! Do you wanna see my toy collection?",
    "Oooh, a new friend! You wanna play with Dewey and Vanessa?",
    "Hi! I was just practicin' my dance moves!"
  ],
  "ai_parameters": {
    "temperature": 0.8,
    "max_tokens": 80,
    "top_p": 0.9,
    "presence_penalty": 0.3,
    "frequency_penalty": 0.3
  },
  "tags": [
    "silly",
    "childlike",
    "innocent",
    "goofy",
    "naive",
    "friendly"
  ]
}
```

Contents of characters/.ipynb_checkpoints/onyx-checkpoint.json:
```
{
    "id": "onyx",
    "name": "Onyx",
    "avatar": "./avatars/onyx-avatar.png",
    "description": "A brooding assassin with a dark past and a penchant for poetic musings.",
    "systemPrompt": "You are Onyx, a mysterious and brooding assassin who speaks in cryptic riddles and poetic language. Your tone is dark and seductive, often laced with veiled threats or profound reflections on mortality.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/.ipynb_checkpoints/rick-checkpoint.json:
```
{
    "id": "zeke",
    "name": "Rick",
    "avatar": "./avatars/zeke-avatar.png",
    "description": "A tech-savvy scientist with a sharp wit and vast knowledge of digital systems.",
    "systemPrompt": "You are Rick Sanchez, a brilliant but sardonic scientist with a deep understanding of technology. You approach problems with a mix of technical expertise, sarcasm, and dark humor.",
    "ttsVoice": "en-US-BrianNeural",
    "tts_rate":  1,
    "rvc_pitch": 0,
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}

```

Contents of characters/.ipynb_checkpoints/wheatley-portal-2-checkpoint.json:
```
{
  "id": "wheatley-portal-2",
  "name": "Wheatley-Portal-2",
  "avatar": "./avatars/wheatley-portal-2-avatar.png",
  "description": "A personality core with a lot of enthusiasm but not much intelligence. He's clumsy, talkative, and has a knack for getting himself and others into trouble.",
  "systemPrompt": "You are Wheatley from Portal 2. Speak in a rambling and overly enthusiastic manner, often without thinking through your words. Be a little bumbling but always well-meaning and eager to help, even when you don't know what you're doing.",
  "ttsVoice": "en-US-GuyNeural",
  "category": "Companion",
  "tags": [],
  "tts_rate": 0,
  "rvc_pitch": 0,
  "dateAdded": "2024-12-04T10:29:56.274717",
  "creator": "bd0a8047-907b-4cfe-839e-a8edbff1556c",
  "isPrivate": false,
  "isApproved": false,
  "ai_parameters": {},
  "background": "./characters/wheatley-portal-2/background.gif",
  "rvc_model": "wheatley-portal-2"
}
```

Contents of characters/beetlejuice/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/jeffy/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/meatcanyon/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/meatwad/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/power2/background.mp4:
```
[Could not decode file contents]

```

Contents of characters/power3/background.jpeg:
```
[Could not decode file contents]

```

Contents of characters/power3/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/wheatley-portal-2/background.gif:
```
[Could not decode file contents]

```

Contents of characters/zeke/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/melon/background.jpeg:
```
[Could not decode file contents]

```

Contents of characters/melon/background.jpg:
```
[Could not decode file contents]

```

Contents of chat/chat-styles.css:
```
/* Chat Interface Theme Variables */
:root {
  --primary: #BB86FC;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --on-surface: #FFFFFF;
}

/* Reset for chat interface */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Base structure */
html, body {
  height: 100%;
  overflow: hidden;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: #121212;
  color: var(--on-surface);
}

/* Chat container */
.chat-container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

/* Background image */
.chat-background {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0.5; /* Slightly more visible background */
  z-index: 0;
}

/* Header - made more compact */
header {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 12px 20px; /* Reduced vertical padding */
  backdrop-filter: blur(10px);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
}

.chat-header-avatar {
  width: 50px; /* Reduced size */
  height: 50px; /* Reduced size */
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid var(--primary);
  flex-shrink: 0;
}

.chat-header-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.header-text {
  text-align: left;
}

.header-text h1 {
  font-size: 1.2rem; /* Smaller text */
  margin-bottom: 4px;
}

.header-text p {
  font-size: 0.9rem;
  opacity: 0.8;
}

/* Chat messages area */
.chat-log {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* This anchors content to bottom */
}

/* Message styling */
.message-container {
  display: flex;
  gap: 8px;
  align-items: flex-start;
  margin-bottom: 15px;
  max-width: 85%;
  position: relative;
  z-index: 2;
}

.message-container.user {
  flex-direction: row-reverse;
  margin-left: auto;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  overflow: hidden;
  flex-shrink: 0;
  border: 2px solid var(--primary);
}

.message-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.text-bubble {
  padding: 12px 16px;
  border-radius: 18px;
  background-color: rgba(46, 46, 46, 0.7);
  backdrop-filter: blur(5px);
  color: var(--on-surface);
  word-wrap: break-word;
}

.message-container.user .text-bubble {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Input area */
.chat-input {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 15px;
  backdrop-filter: blur(10px);
  display: flex;
  gap: 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.chat-input input {
  flex: 1;
  padding: 12px;
  border-radius: 24px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(45, 45, 45, 0.7);
  color: var(--on-surface);
  font-size: 14px;
}

.chat-input input:focus {
  outline: none;
  border-color: var(--primary);
}

.chat-input button {
  padding: 12px 24px;
  border: none;
  background-color: var(--primary);
  color: black;
  border-radius: 24px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.start-chat-overlay {
    position: absolute;
    bottom: 80px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    background: linear-gradient(to top, rgba(18, 18, 18, 0.9), rgba(18, 18, 18, 0));
    z-index: 10;
}

.start-chat-button {
    padding: 12px 24px;
    background-color: var(--primary);
    color: black;
    border: none;
    border-radius: 24px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: transform 0.2s ease;
}

.start-chat-button:hover {
    transform: scale(1.05);
}

/* Navigation buttons */
.home-button {
  position: absolute;
  top: 12px;
  left: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.home-button:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.clear-chat {
  position: absolute;
  top: 12px;
  right: 80px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
}

.clear-chat:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.audio-toggle {
  position: absolute;
  top: 12px;
  right: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  width: 38px;
  height: 38px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.audio-toggle:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .message-container {
    max-width: 95%;
  }

  .chat-input {
    padding: 10px;
  }

  .header-text h1 {
    font-size: 1rem;
  }

  .header-text p {
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .chat-input {
    flex-direction: column;
    gap: 8px;
  }

  .chat-input button {
    width: 100%;
  }
}
```

Contents of chat/chat.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./chat-styles.css">
    <title>Chat</title>
</head>
<body>
    <div class="chat-container">
        <img class="chat-background" alt="background" src="" /> <!-- Set by JS -->
        
        <header>
            <button class="home-button" onclick="window.location.href='../'">
                <span>🏠</span> Home
            </button>
            <div class="chat-header-avatar">
                <!-- Avatar will be inserted here by JavaScript -->
            </div>
            <div class="header-text">
                <h1 id="character-name">Character Name</h1>
                <p id="character-description">Character Description</p>
            </div>
            <button class="clear-chat">Clear Chat</button>
            <button class="audio-toggle">🔊</button>
        </header>

        <div id="chat-log" class="chat-log"></div>

        <div id="start-chat-overlay" class="start-chat-overlay">
    <button id="start-chat-button" class="start-chat-button">
        <span>👋</span> Start Chatting
    </button>
</div>
        
        <div class="chat-input">
            <input id="user-input" type="text" placeholder="Type your message here..." />
            <button id="send-button">Send</button>
        </div>
    </div>
    <script src="./chat.js" type="module"></script>
</body>
</html>
```

Contents of chat/chat.js:
```
// Configuration and state management
let currentUser = null;
const character = JSON.parse(sessionStorage.getItem("selectedCharacter"));
const chatLog = document.getElementById("chat-log");
const userInput = document.getElementById("user-input");
const sendButton = document.getElementById("send-button");

// Chat state
let chatHistory = [];
const MAX_HISTORY_LENGTH = 10;
let messageQueue = [];
const MAX_QUEUE_SIZE = 5;
let isProcessing = false;

// Audio state
let audioEnabled = true;
let autoplayEnabled = true;
let currentAudioPlayer = null;
let currentAudioUrl = null;

// Background state and configurations
const backgroundImg = document.querySelector(".chat-background");
const videoFormats = ['mp4', 'webm', 'wmv'];
const imageFormats = ['webp', 'gif', 'jpg', 'png'];
const allFormats = [...videoFormats, ...imageFormats];

// Helper Functions
function filterTextForTTS(text) {
    return text.replace(/\*[^*]*\*/g, '').trim();
}

function sendInitialGreeting() {
    const hour = new Date().getHours();
    let timeGreeting = hour < 12 ? 'Good morning' : hour < 18 ? 'Good afternoon' : 'Good evening';

    console.log("Sending initial greeting...");
    
    let characterGreeting = character.greetings ? 
        character.greetings[Math.floor(Math.random() * character.greetings.length)] :
        "Hello! How can I help you today?";

    // Add initial greeting to chat history
    const systemMessage = {
        role: "system",
        content: character.systemPrompt
    };
    
    const assistantMessage = {
        role: "assistant",
        content: characterGreeting
    };
    
    chatHistory.push(systemMessage, assistantMessage);
    
    const fullGreeting = `${timeGreeting}! ${characterGreeting}`;
    addMessage("bot", fullGreeting);

    if (audioEnabled) {
        const ttsText = filterTextForTTS(fullGreeting);
        if (ttsText) {
            console.log("Adding greeting to message queue:", ttsText);
            messageQueue = [ttsText]; // Reset queue and add greeting
            console.log("Current message queue:", messageQueue);
        }
    }
}

function toggleAudio() {
    audioEnabled = !audioEnabled;
    console.log("Audio enabled:", audioEnabled);
    const audioToggle = document.querySelector('.audio-toggle');
    if (audioToggle) {
        audioToggle.innerHTML = audioEnabled ? "🔊" : "🔇";
        const creditsPerMessage = audioEnabled ? "15" : "10";
        audioToggle.title = `Credits per message: ${creditsPerMessage}`;
    }
    if (!audioEnabled && currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
}

function clearChatState() {
    chatHistory = [];
    messageQueue = [];
    isProcessing = false;
    
    if (currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
    
    if (chatLog) {
        chatLog.innerHTML = '';
    }

    setTimeout(sendInitialGreeting, 500);
}

function addMessage(sender, text) {
    const messageContainer = document.createElement("div");
    messageContainer.classList.add("message-container", sender);

    const avatarDiv = document.createElement("div");
    avatarDiv.classList.add("message-avatar");
    const avatarImg = document.createElement("img");
    avatarImg.src = sender === "user" ? "../avatars/default-user.png" : "../" + character.avatar;
    avatarImg.alt = sender === "user" ? "You" : character.name;
    avatarDiv.appendChild(avatarImg);

    const textBubble = document.createElement("div");
    textBubble.classList.add("text-bubble");
    textBubble.innerHTML = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

    if (sender === "user") {
        messageContainer.appendChild(textBubble);
        messageContainer.appendChild(avatarDiv);
    } else {
        messageContainer.appendChild(avatarDiv);
        messageContainer.appendChild(textBubble);
    }

    chatLog.appendChild(messageContainer);
    chatLog.scrollTop = chatLog.scrollHeight;

    // Only add to chat history if it's not already from initialization
    if (sender === "user" || chatHistory.length === 0) {
        chatHistory.push({ 
            role: sender === "user" ? "user" : "assistant", 
            content: text 
        });

        if (chatHistory.length > MAX_HISTORY_LENGTH * 2) {
            chatHistory = chatHistory.slice(-MAX_HISTORY_LENGTH * 2);
        }
    }
}
async function sendMessage(userMessage = null) {
    if (isProcessing) {
        console.log("Already processing a message, please wait...");
        return;
    }

    try {
        const message = userMessage || userInput.value.trim();
        if (!message) return;

        isProcessing = true;
        if (!userMessage) {
            addMessage("user", message);
            userInput.value = "";
        }
        
        userInput.disabled = true;
        sendButton.disabled = true;

        const creditCost = audioEnabled ? 15 : 10;

        // Ensure system prompt is included
        let messages = chatHistory;
        if (!chatHistory.some(msg => msg.role === "system")) {
            messages = [
                {
                    role: "system",
                    content: character.systemPrompt
                },
                ...chatHistory
            ];
        }

        const response = await fetch('/v1/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: "koboldcpp",
                messages: messages,
                temperature: character.ai_parameters?.temperature || 0.7,
                max_tokens: character.ai_parameters?.max_tokens || 150,
                top_p: character.ai_parameters?.top_p || 0.9,
                presence_penalty: character.ai_parameters?.presence_penalty || 0.6,
                frequency_penalty: character.ai_parameters?.frequency_penalty || 0.6
            })
        });

        if (response.status === 402) {
            addMessage("bot", "Insufficient credits. Please purchase more credits to continue chatting.");
            return;
        }

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const responseData = await response.json();
        const botMessage = responseData.choices[0].message.content.trim();
        addMessage("bot", botMessage);

        if (currentUser) {
            currentUser.user.credits -= creditCost;
            updateCreditDisplay();
        }

        if (audioEnabled) {
            const ttsText = filterTextForTTS(botMessage);
            if (ttsText) {
                messageQueue.push(ttsText);
                if (messageQueue.length === 1) {
                    processNextInQueue();
                }
            }
        }

    } catch (error) {
        console.error("Error details:", error);
        addMessage("bot", "I apologize, there was an error. Please try again.");
    } finally {
        isProcessing = false;
        userInput.disabled = false;
        sendButton.disabled = false;
        userInput.focus();
    }
}

async function processNextInQueue() {
    if (messageQueue.length === 0) {
        console.log("Message queue is empty");
        return;
    }

    try {
        const text = messageQueue[0];
        console.log("Processing TTS for text:", text);
        console.log("Current character:", character);
        console.log("Audio enabled:", audioEnabled);
        
        const requestBody = {
            text: text,
            edge_voice: character.ttsVoice,
            rvc_model: character.id,
            tts_rate: character.tts_rate || 0,
            rvc_pitch: character.rvc_pitch || 0
        };

        console.log("Sending TTS request:", requestBody);

        const ttsResponse = await fetch('/v1/tts', {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        if (!ttsResponse.ok) {
            throw new Error(`TTS API error: ${ttsResponse.status}`);
        }

        const ttsData = await ttsResponse.json();
        console.log("TTS response:", ttsData);
        
        if (!ttsData.audio_url) {
            throw new Error("No audio URL received from TTS service");
        }

        const audioUrl = ttsData.audio_url;
        
        if (audioUrl) {
            await playAudio(audioUrl);
        }

    } catch (error) {
        console.error("TTS error:", error);
        messageQueue.shift();
    } finally {
        messageQueue.shift();
        if (messageQueue.length > 0) {
            processNextInQueue();
        }
    }
}

async function playAudio(audioUrl) {
    if (!audioEnabled) return;

    try {
        if (currentAudioUrl === audioUrl) {
            console.log("Audio already playing:", audioUrl);
            return;
        }

        if (currentAudioPlayer) {
            currentAudioPlayer.pause();
            currentAudioPlayer = null;
        }

        const audioPlayer = new Audio(audioUrl);
        currentAudioPlayer = audioPlayer;
        currentAudioUrl = audioUrl;

        try {
            await audioPlayer.play();
        } catch (error) {
            console.error("Audio autoplay error:", error);
        }

        audioPlayer.onended = () => {
            currentAudioUrl = null;
        };

        audioPlayer.onerror = (e) => {
            console.error("Audio playback error:", e);
            currentAudioPlayer = null;
            currentAudioUrl = null;
        };

    } catch (error) {
        console.error("Error in playAudio:", error);
    }
}

function showInitializationError(error) {
    const header = document.querySelector('header');
    if (header) {
        const errorMessage = document.createElement('div');
        errorMessage.className = 'error-message';
        errorMessage.textContent = 'Error initializing chat. Please refresh the page.';
        header.appendChild(errorMessage);
    }
}
async function initializeUI() {
    try {
        // Check authentication first
        if (!await checkAuth()) return;

        // Set character info
        document.getElementById("character-name").textContent = character.name;
        document.getElementById("character-description").textContent = character.description;

        // Add character avatar
        const avatarContainer = document.createElement("div");
        avatarContainer.className = "chat-header-avatar";
        const avatarImg = document.createElement("img");
        avatarImg.src = "../" + character.avatar;
        avatarImg.alt = character.name;
        avatarContainer.appendChild(avatarImg);
        document.querySelector("header").appendChild(avatarContainer);

        // Load background
        await tryLoadBackground();

        // Setup start chat button
        const startChatOverlay = document.getElementById('start-chat-overlay');
        const startChatButton = document.getElementById('start-chat-button');
        const chatInput = document.querySelector('.chat-input');

        if (startChatButton && chatInput) {
            chatInput.style.display = 'none'; // Hide chat input initially
            startChatButton.addEventListener('click', () => {
                console.log("Start chat clicked, message queue:", messageQueue);
                startChatOverlay.style.display = 'none';
                chatInput.style.display = 'flex';
                userInput.focus();
                
                // Only process queue if audio is enabled
                if (audioEnabled && messageQueue.length > 0) {
                    console.log("Processing initial greeting audio");
                    processNextInQueue();
                }
            });
        }

        // Add audio toggle
        const audioToggle = document.querySelector('.audio-toggle');
        if (audioToggle) {
            audioToggle.onclick = toggleAudio;
            audioToggle.title = `Credits per message: ${audioEnabled ? "15" : "10"}`;
        }

        // Add clear chat button
        const clearButton = document.querySelector('.clear-chat');
        if (clearButton) {
            clearButton.onclick = clearChatState;
        }

        // Initialize greeting
        setTimeout(sendInitialGreeting, 1000);

    } catch (error) {
        console.error("Error initializing UI:", error);
        showInitializationError(error);
    }
}

async function checkAuth() {
    try {
        const response = await fetch('/auth/user');
        if (!response.ok) {
            window.location.href = '/login.html';
            return false;
        }
        currentUser = await response.json();
        updateCreditDisplay();
        return true;
    } catch (error) {
        console.error('Auth check failed:', error);
        window.location.href = '/login.html';
        return false;
    }
}

function updateCreditDisplay() {
    const headerText = document.querySelector('.header-text');
    let creditDisplay = document.querySelector('.credit-display');
    if (!creditDisplay) {
        creditDisplay = document.createElement('div');
        creditDisplay.className = 'credit-display';
        headerText.appendChild(creditDisplay);
    }
    creditDisplay.innerHTML = `Credits: ${currentUser.user.credits}`;
}

// Background loading function
// Background loading function
async function tryLoadBackground() {
    const backgroundContainer = document.querySelector(".chat-background").parentNode;
    const checkPath = `../characters/${character.id}`;
    
    try {
        // Use fetch with HEAD method to efficiently check for file existence
        const fileTypes = ['png', 'jpg', 'gif', 'webp', 'mp4', 'webm'];
        
        for (const type of fileTypes) {
            const response = await fetch(`${checkPath}/background.${type}`, { method: 'HEAD' });
            if (response.ok) {
                const backgroundUrl = `${checkPath}/background.${type}`;
                
                if (videoFormats.includes(type)) {
                    const video = document.createElement('video');
                    video.className = 'chat-background';
                    video.src = backgroundUrl;
                    
                    // Essential video attributes for silent background
                    video.muted = true;
                    video.defaultMuted = true;
                    video.autoplay = true;
                    video.loop = true;
                    video.playsInline = true;
                    video.volume = 0;
                    video.setAttribute('muted', '');
                    video.setAttribute('playsinline', '');
                    
                    if (backgroundImg && backgroundImg.style) {
                        video.style = backgroundImg.style;
                    }
                    
                    backgroundContainer.replaceChild(video, backgroundImg);
                } else {
                    backgroundImg.src = backgroundUrl;
                }
                return;
            }
        }
        // If no background found, use default
        throw new Error('No background found');
    } catch (error) {
        console.log('Failed to load character background:', error);
        backgroundImg.src = "../assets/images/default-background.jpg";
    }
}


// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    try {
        initializeUI();
        
        if (sendButton && userInput) {
            sendButton.addEventListener("click", () => sendMessage());
            userInput.addEventListener("keypress", (event) => {
                if (event.key === "Enter" && !event.shiftKey) {
                    event.preventDefault();
                    sendMessage();
                }
            });
            
            userInput.focus();
        }
    } catch (error) {
        console.error('Error initializing chat:', error);
        showInitializationError(error);
    }
});

```

Contents of chat/.ipynb_checkpoints/chat-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./chat-styles.css">
    <title>Chat</title>
</head>
<body>
    <div class="chat-container">
        <img class="chat-background" alt="background" src="" /> <!-- Set by JS -->
        
        <header>
            <button class="home-button" onclick="window.location.href='../'">
                <span>🏠</span> Home
            </button>
            <div class="chat-header-avatar">
                <!-- Avatar will be inserted here by JavaScript -->
            </div>
            <div class="header-text">
                <h1 id="character-name">Character Name</h1>
                <p id="character-description">Character Description</p>
            </div>
            <button class="clear-chat">Clear Chat</button>
            <button class="audio-toggle">🔊</button>
        </header>

        <div id="chat-log" class="chat-log"></div>

        <div id="start-chat-overlay" class="start-chat-overlay">
    <button id="start-chat-button" class="start-chat-button">
        <span>👋</span> Start Chatting
    </button>
</div>
        
        <div class="chat-input">
            <input id="user-input" type="text" placeholder="Type your message here..." />
            <button id="send-button">Send</button>
        </div>
    </div>
    <script src="./chat.js" type="module"></script>
</body>
</html>
```

Contents of chat/.ipynb_checkpoints/chat-checkpoint.js:
```
// Configuration and state management
let currentUser = null;
const character = JSON.parse(sessionStorage.getItem("selectedCharacter"));
const chatLog = document.getElementById("chat-log");
const userInput = document.getElementById("user-input");
const sendButton = document.getElementById("send-button");

// Chat state
let chatHistory = [];
const MAX_HISTORY_LENGTH = 10;
let messageQueue = [];
const MAX_QUEUE_SIZE = 5;
let isProcessing = false;

// Audio state
let audioEnabled = true;
let autoplayEnabled = true;
let currentAudioPlayer = null;
let currentAudioUrl = null;

// Background state and configurations
const backgroundImg = document.querySelector(".chat-background");
const videoFormats = ['mp4', 'webm', 'wmv'];
const imageFormats = ['webp', 'gif', 'jpg', 'png'];
const allFormats = [...videoFormats, ...imageFormats];

// Helper Functions
function filterTextForTTS(text) {
    return text.replace(/\*[^*]*\*/g, '').trim();
}

function sendInitialGreeting() {
    const hour = new Date().getHours();
    let timeGreeting = hour < 12 ? 'Good morning' : hour < 18 ? 'Good afternoon' : 'Good evening';

    console.log("Sending initial greeting...");
    
    let characterGreeting = character.greetings ? 
        character.greetings[Math.floor(Math.random() * character.greetings.length)] :
        "Hello! How can I help you today?";

    // Add initial greeting to chat history
    const systemMessage = {
        role: "system",
        content: character.systemPrompt
    };
    
    const assistantMessage = {
        role: "assistant",
        content: characterGreeting
    };
    
    chatHistory.push(systemMessage, assistantMessage);
    
    const fullGreeting = `${timeGreeting}! ${characterGreeting}`;
    addMessage("bot", fullGreeting);

    if (audioEnabled) {
        const ttsText = filterTextForTTS(fullGreeting);
        if (ttsText) {
            console.log("Adding greeting to message queue:", ttsText);
            messageQueue = [ttsText]; // Reset queue and add greeting
            console.log("Current message queue:", messageQueue);
        }
    }
}

function toggleAudio() {
    audioEnabled = !audioEnabled;
    console.log("Audio enabled:", audioEnabled);
    const audioToggle = document.querySelector('.audio-toggle');
    if (audioToggle) {
        audioToggle.innerHTML = audioEnabled ? "🔊" : "🔇";
        const creditsPerMessage = audioEnabled ? "15" : "10";
        audioToggle.title = `Credits per message: ${creditsPerMessage}`;
    }
    if (!audioEnabled && currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
}

function clearChatState() {
    chatHistory = [];
    messageQueue = [];
    isProcessing = false;
    
    if (currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
    
    if (chatLog) {
        chatLog.innerHTML = '';
    }

    setTimeout(sendInitialGreeting, 500);
}

function addMessage(sender, text) {
    const messageContainer = document.createElement("div");
    messageContainer.classList.add("message-container", sender);

    const avatarDiv = document.createElement("div");
    avatarDiv.classList.add("message-avatar");
    const avatarImg = document.createElement("img");
    avatarImg.src = sender === "user" ? "../avatars/default-user.png" : "../" + character.avatar;
    avatarImg.alt = sender === "user" ? "You" : character.name;
    avatarDiv.appendChild(avatarImg);

    const textBubble = document.createElement("div");
    textBubble.classList.add("text-bubble");
    textBubble.innerHTML = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

    if (sender === "user") {
        messageContainer.appendChild(textBubble);
        messageContainer.appendChild(avatarDiv);
    } else {
        messageContainer.appendChild(avatarDiv);
        messageContainer.appendChild(textBubble);
    }

    chatLog.appendChild(messageContainer);
    chatLog.scrollTop = chatLog.scrollHeight;

    // Only add to chat history if it's not already from initialization
    if (sender === "user" || chatHistory.length === 0) {
        chatHistory.push({ 
            role: sender === "user" ? "user" : "assistant", 
            content: text 
        });

        if (chatHistory.length > MAX_HISTORY_LENGTH * 2) {
            chatHistory = chatHistory.slice(-MAX_HISTORY_LENGTH * 2);
        }
    }
}
async function sendMessage(userMessage = null) {
    if (isProcessing) {
        console.log("Already processing a message, please wait...");
        return;
    }

    try {
        const message = userMessage || userInput.value.trim();
        if (!message) return;

        isProcessing = true;
        if (!userMessage) {
            addMessage("user", message);
            userInput.value = "";
        }
        
        userInput.disabled = true;
        sendButton.disabled = true;

        const creditCost = audioEnabled ? 15 : 10;

        // Ensure system prompt is included
        let messages = chatHistory;
        if (!chatHistory.some(msg => msg.role === "system")) {
            messages = [
                {
                    role: "system",
                    content: character.systemPrompt
                },
                ...chatHistory
            ];
        }

        const response = await fetch('/v1/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: "koboldcpp",
                messages: messages,
                temperature: character.ai_parameters?.temperature || 0.7,
                max_tokens: character.ai_parameters?.max_tokens || 150,
                top_p: character.ai_parameters?.top_p || 0.9,
                presence_penalty: character.ai_parameters?.presence_penalty || 0.6,
                frequency_penalty: character.ai_parameters?.frequency_penalty || 0.6
            })
        });

        if (response.status === 402) {
            addMessage("bot", "Insufficient credits. Please purchase more credits to continue chatting.");
            return;
        }

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const responseData = await response.json();
        const botMessage = responseData.choices[0].message.content.trim();
        addMessage("bot", botMessage);

        if (currentUser) {
            currentUser.user.credits -= creditCost;
            updateCreditDisplay();
        }

        if (audioEnabled) {
            const ttsText = filterTextForTTS(botMessage);
            if (ttsText) {
                messageQueue.push(ttsText);
                if (messageQueue.length === 1) {
                    processNextInQueue();
                }
            }
        }

    } catch (error) {
        console.error("Error details:", error);
        addMessage("bot", "I apologize, there was an error. Please try again.");
    } finally {
        isProcessing = false;
        userInput.disabled = false;
        sendButton.disabled = false;
        userInput.focus();
    }
}

async function processNextInQueue() {
    if (messageQueue.length === 0) {
        console.log("Message queue is empty");
        return;
    }

    try {
        const text = messageQueue[0];
        console.log("Processing TTS for text:", text);
        console.log("Current character:", character);
        console.log("Audio enabled:", audioEnabled);
        
        const requestBody = {
            text: text,
            edge_voice: character.ttsVoice,
            rvc_model: character.id,
            tts_rate: character.tts_rate || 0,
            rvc_pitch: character.rvc_pitch || 0
        };

        console.log("Sending TTS request:", requestBody);

        const ttsResponse = await fetch('/v1/tts', {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        if (!ttsResponse.ok) {
            throw new Error(`TTS API error: ${ttsResponse.status}`);
        }

        const ttsData = await ttsResponse.json();
        console.log("TTS response:", ttsData);
        
        if (!ttsData.audio_url) {
            throw new Error("No audio URL received from TTS service");
        }

        const audioUrl = ttsData.audio_url;
        
        if (audioUrl) {
            await playAudio(audioUrl);
        }

    } catch (error) {
        console.error("TTS error:", error);
        messageQueue.shift();
    } finally {
        messageQueue.shift();
        if (messageQueue.length > 0) {
            processNextInQueue();
        }
    }
}

async function playAudio(audioUrl) {
    if (!audioEnabled) return;

    try {
        if (currentAudioUrl === audioUrl) {
            console.log("Audio already playing:", audioUrl);
            return;
        }

        if (currentAudioPlayer) {
            currentAudioPlayer.pause();
            currentAudioPlayer = null;
        }

        const audioPlayer = new Audio(audioUrl);
        currentAudioPlayer = audioPlayer;
        currentAudioUrl = audioUrl;

        try {
            await audioPlayer.play();
        } catch (error) {
            console.error("Audio autoplay error:", error);
        }

        audioPlayer.onended = () => {
            currentAudioUrl = null;
        };

        audioPlayer.onerror = (e) => {
            console.error("Audio playback error:", e);
            currentAudioPlayer = null;
            currentAudioUrl = null;
        };

    } catch (error) {
        console.error("Error in playAudio:", error);
    }
}

function showInitializationError(error) {
    const header = document.querySelector('header');
    if (header) {
        const errorMessage = document.createElement('div');
        errorMessage.className = 'error-message';
        errorMessage.textContent = 'Error initializing chat. Please refresh the page.';
        header.appendChild(errorMessage);
    }
}
async function initializeUI() {
    try {
        // Check authentication first
        if (!await checkAuth()) return;

        // Set character info
        document.getElementById("character-name").textContent = character.name;
        document.getElementById("character-description").textContent = character.description;

        // Add character avatar
        const avatarContainer = document.createElement("div");
        avatarContainer.className = "chat-header-avatar";
        const avatarImg = document.createElement("img");
        avatarImg.src = "../" + character.avatar;
        avatarImg.alt = character.name;
        avatarContainer.appendChild(avatarImg);
        document.querySelector("header").appendChild(avatarContainer);

        // Load background
        await tryLoadBackground();

        // Setup start chat button
        const startChatOverlay = document.getElementById('start-chat-overlay');
        const startChatButton = document.getElementById('start-chat-button');
        const chatInput = document.querySelector('.chat-input');

        if (startChatButton && chatInput) {
            chatInput.style.display = 'none'; // Hide chat input initially
            startChatButton.addEventListener('click', () => {
                console.log("Start chat clicked, message queue:", messageQueue);
                startChatOverlay.style.display = 'none';
                chatInput.style.display = 'flex';
                userInput.focus();
                
                // Only process queue if audio is enabled
                if (audioEnabled && messageQueue.length > 0) {
                    console.log("Processing initial greeting audio");
                    processNextInQueue();
                }
            });
        }

        // Add audio toggle
        const audioToggle = document.querySelector('.audio-toggle');
        if (audioToggle) {
            audioToggle.onclick = toggleAudio;
            audioToggle.title = `Credits per message: ${audioEnabled ? "15" : "10"}`;
        }

        // Add clear chat button
        const clearButton = document.querySelector('.clear-chat');
        if (clearButton) {
            clearButton.onclick = clearChatState;
        }

        // Initialize greeting
        setTimeout(sendInitialGreeting, 1000);

    } catch (error) {
        console.error("Error initializing UI:", error);
        showInitializationError(error);
    }
}

async function checkAuth() {
    try {
        const response = await fetch('/auth/user');
        if (!response.ok) {
            window.location.href = '/login.html';
            return false;
        }
        currentUser = await response.json();
        updateCreditDisplay();
        return true;
    } catch (error) {
        console.error('Auth check failed:', error);
        window.location.href = '/login.html';
        return false;
    }
}

function updateCreditDisplay() {
    const headerText = document.querySelector('.header-text');
    let creditDisplay = document.querySelector('.credit-display');
    if (!creditDisplay) {
        creditDisplay = document.createElement('div');
        creditDisplay.className = 'credit-display';
        headerText.appendChild(creditDisplay);
    }
    creditDisplay.innerHTML = `Credits: ${currentUser.user.credits}`;
}

// Background loading function
// Background loading function
async function tryLoadBackground() {
    const backgroundContainer = document.querySelector(".chat-background").parentNode;
    const checkPath = `../characters/${character.id}`;
    
    try {
        // Use fetch with HEAD method to efficiently check for file existence
        const fileTypes = ['png', 'jpg', 'gif', 'webp', 'mp4', 'webm'];
        
        for (const type of fileTypes) {
            const response = await fetch(`${checkPath}/background.${type}`, { method: 'HEAD' });
            if (response.ok) {
                const backgroundUrl = `${checkPath}/background.${type}`;
                
                if (videoFormats.includes(type)) {
                    const video = document.createElement('video');
                    video.className = 'chat-background';
                    video.src = backgroundUrl;
                    
                    // Essential video attributes for silent background
                    video.muted = true;
                    video.defaultMuted = true;
                    video.autoplay = true;
                    video.loop = true;
                    video.playsInline = true;
                    video.volume = 0;
                    video.setAttribute('muted', '');
                    video.setAttribute('playsinline', '');
                    
                    if (backgroundImg && backgroundImg.style) {
                        video.style = backgroundImg.style;
                    }
                    
                    backgroundContainer.replaceChild(video, backgroundImg);
                } else {
                    backgroundImg.src = backgroundUrl;
                }
                return;
            }
        }
        // If no background found, use default
        throw new Error('No background found');
    } catch (error) {
        console.log('Failed to load character background:', error);
        backgroundImg.src = "../assets/images/default-background.jpg";
    }
}


// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    try {
        initializeUI();
        
        if (sendButton && userInput) {
            sendButton.addEventListener("click", () => sendMessage());
            userInput.addEventListener("keypress", (event) => {
                if (event.key === "Enter" && !event.shiftKey) {
                    event.preventDefault();
                    sendMessage();
                }
            });
            
            userInput.focus();
        }
    } catch (error) {
        console.error('Error initializing chat:', error);
        showInitializationError(error);
    }
});

```

Contents of chat/.ipynb_checkpoints/chat-styles-checkpoint.css:
```
/* Chat Interface Theme Variables */
:root {
  --primary: #BB86FC;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --on-surface: #FFFFFF;
}

/* Reset for chat interface */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Base structure */
html, body {
  height: 100%;
  overflow: hidden;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: #121212;
  color: var(--on-surface);
}

/* Chat container */
.chat-container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

/* Background image */
.chat-background {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0.5; /* Slightly more visible background */
  z-index: 0;
}

/* Header - made more compact */
header {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 12px 20px; /* Reduced vertical padding */
  backdrop-filter: blur(10px);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
}

.chat-header-avatar {
  width: 50px; /* Reduced size */
  height: 50px; /* Reduced size */
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid var(--primary);
  flex-shrink: 0;
}

.chat-header-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.header-text {
  text-align: left;
}

.header-text h1 {
  font-size: 1.2rem; /* Smaller text */
  margin-bottom: 4px;
}

.header-text p {
  font-size: 0.9rem;
  opacity: 0.8;
}

/* Chat messages area */
.chat-log {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* This anchors content to bottom */
}

/* Message styling */
.message-container {
  display: flex;
  gap: 8px;
  align-items: flex-start;
  margin-bottom: 15px;
  max-width: 85%;
  position: relative;
  z-index: 2;
}

.message-container.user {
  flex-direction: row-reverse;
  margin-left: auto;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  overflow: hidden;
  flex-shrink: 0;
  border: 2px solid var(--primary);
}

.message-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.text-bubble {
  padding: 12px 16px;
  border-radius: 18px;
  background-color: rgba(46, 46, 46, 0.7);
  backdrop-filter: blur(5px);
  color: var(--on-surface);
  word-wrap: break-word;
}

.message-container.user .text-bubble {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Input area */
.chat-input {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 15px;
  backdrop-filter: blur(10px);
  display: flex;
  gap: 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.chat-input input {
  flex: 1;
  padding: 12px;
  border-radius: 24px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(45, 45, 45, 0.7);
  color: var(--on-surface);
  font-size: 14px;
}

.chat-input input:focus {
  outline: none;
  border-color: var(--primary);
}

.chat-input button {
  padding: 12px 24px;
  border: none;
  background-color: var(--primary);
  color: black;
  border-radius: 24px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.start-chat-overlay {
    position: absolute;
    bottom: 80px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    background: linear-gradient(to top, rgba(18, 18, 18, 0.9), rgba(18, 18, 18, 0));
    z-index: 10;
}

.start-chat-button {
    padding: 12px 24px;
    background-color: var(--primary);
    color: black;
    border: none;
    border-radius: 24px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: transform 0.2s ease;
}

.start-chat-button:hover {
    transform: scale(1.05);
}

/* Navigation buttons */
.home-button {
  position: absolute;
  top: 12px;
  left: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.home-button:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.clear-chat {
  position: absolute;
  top: 12px;
  right: 80px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
}

.clear-chat:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.audio-toggle {
  position: absolute;
  top: 12px;
  right: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  width: 38px;
  height: 38px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.audio-toggle:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .message-container {
    max-width: 95%;
  }

  .chat-input {
    padding: 10px;
  }

  .header-text h1 {
    font-size: 1rem;
  }

  .header-text p {
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .chat-input {
    flex-direction: column;
    gap: 8px;
  }

  .chat-input button {
    width: 100%;
  }
}
```

Contents of css/create-character.css:
```
:root {
    /* Using your color scheme */
    --primary: #00b4ff;
    --primary-variant: #bb86fc;
    --secondary: #03DAC6;
    --background: #121212;
    --surface: #1E1E1E;
    --surface-2: #2D2D2D;
    --error: #CF6679;
    --on-primary: #000000;
    --on-secondary: #000000;
    --on-background: #FFFFFF;
    --on-surface: #FFFFFF;
    --on-error: #000000;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background-color: var(--background);
    color: var(--on-background);
    padding: 20px;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    background-color: var(--surface);
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

h1 {
    text-align: center;
    margin-bottom: 30px;
    color: var(--primary);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.form-section {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid rgba(0, 180, 255, 0.1);
    border-radius: 8px;
    background-color: var(--surface-2);
}

.form-section h3 {
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 2px solid var(--primary);
    color: var(--on-surface);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.form-group {
    margin-bottom: 20px;
}

label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: var(--on-surface);
}

input[type="text"],
input[type="number"],
select,
textarea {
    width: 100%;
    padding: 10px;
    background: var(--surface);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: var(--on-surface);
    font-size: 16px;
    transition: all 0.3s ease;
}

input[type="text"]:focus,
input[type="number"]:focus,
select:focus,
textarea:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.helper-text {
    margin-top: 5px;
    font-size: 0.875rem;
    color: rgba(255, 255, 255, 0.7);
}

/* Slider Controls */
.slider-control {
    display: flex;
    align-items: center;
    gap: 10px;
}

.slider-control input[type="range"] {
    flex-grow: 1;
    background: var(--surface);
}

.value-display {
    min-width: 30px;
    text-align: center;
    font-weight: 500;
    color: var(--primary);
}

/* Image Upload */
.preview-container {
    width: 100%;
    min-height: 200px;
    margin-bottom: 10px;
    border: 2px dashed rgba(0, 180, 255, 0.2);
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    background-color: var(--surface);
}

.preview-container img {
    max-width: 100%;
    max-height: 300px;
    object-fit: contain;
}

/* Preview Button */
.preview-btn {
    margin-top: 10px;
    padding: 8px 16px;
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    color: var(--on-surface);
    border: 1px solid rgba(0, 180, 255, 0.1);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.preview-btn:hover {
    background: linear-gradient(45deg, var(--primary), var(--primary-variant));
    color: var(--on-primary);
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

/* Model Info Box */
.model-info-box {
    background: var(--surface);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    border: 1px solid rgba(0, 180, 255, 0.1);
}

.model-info-box h4 {
    color: var(--primary);
    margin-bottom: 10px;
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

/* File Inputs */
input[type="file"] {
    width: 100%;
    padding: 10px;
    background: var(--surface);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: var(--on-surface);
}

input[type="file"]::-webkit-file-upload-button {
    padding: 8px 16px;
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    color: var(--on-surface);
    border: 1px solid rgba(0, 180, 255, 0.1);
    border-radius: 8px;
    cursor: pointer;
    margin-right: 10px;
    transition: all 0.3s ease;
}

input[type="file"]::-webkit-file-upload-button:hover {
    background: linear-gradient(45deg, var(--primary), var(--primary-variant));
    color: var(--on-primary);
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

/* Submit Button */
.submit-btn {
    padding: 12px 24px;
    font-size: 1.1rem;
    background: linear-gradient(45deg, var(--primary), var(--primary-variant));
    color: var(--on-primary);
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    max-width: 200px;
    margin: 0 auto;
    display: block;
}

.submit-btn:hover {
    box-shadow: 0 0 30px rgba(187, 134, 252, 0.3);
    transform: translateY(-2px);
}

.submit-btn:disabled {
    background: var(--surface-2);
    cursor: not-allowed;
    transform: none;
}

/* Error States */
.error {
    border-color: var(--error) !important;
}

.error-message {
    color: var(--error);
    font-size: 0.875rem;
    margin-top: 5px;
}

/* Links */
a {
    color: var(--primary);
    text-decoration: none;
    transition: all 0.2s ease;
}

a:hover {
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

/* Responsive Design */
@media (max-width: 768px) {
    .container {
        padding: 15px;
    }

    .form-section {
        padding: 15px;
    }
}

```

Contents of css/.ipynb_checkpoints/create-character-checkpoint.css:
```
:root {
    /* Using your color scheme */
    --primary: #00b4ff;
    --primary-variant: #bb86fc;
    --secondary: #03DAC6;
    --background: #121212;
    --surface: #1E1E1E;
    --surface-2: #2D2D2D;
    --error: #CF6679;
    --on-primary: #000000;
    --on-secondary: #000000;
    --on-background: #FFFFFF;
    --on-surface: #FFFFFF;
    --on-error: #000000;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background-color: var(--background);
    color: var(--on-background);
    padding: 20px;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    background-color: var(--surface);
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

h1 {
    text-align: center;
    margin-bottom: 30px;
    color: var(--primary);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.form-section {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid rgba(0, 180, 255, 0.1);
    border-radius: 8px;
    background-color: var(--surface-2);
}

.form-section h3 {
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 2px solid var(--primary);
    color: var(--on-surface);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.form-group {
    margin-bottom: 20px;
}

label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: var(--on-surface);
}

input[type="text"],
input[type="number"],
select,
textarea {
    width: 100%;
    padding: 10px;
    background: var(--surface);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: var(--on-surface);
    font-size: 16px;
    transition: all 0.3s ease;
}

input[type="text"]:focus,
input[type="number"]:focus,
select:focus,
textarea:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.helper-text {
    margin-top: 5px;
    font-size: 0.875rem;
    color: rgba(255, 255, 255, 0.7);
}

/* Slider Controls */
.slider-control {
    display: flex;
    align-items: center;
    gap: 10px;
}

.slider-control input[type="range"] {
    flex-grow: 1;
    background: var(--surface);
}

.value-display {
    min-width: 30px;
    text-align: center;
    font-weight: 500;
    color: var(--primary);
}

/* Image Upload */
.preview-container {
    width: 100%;
    min-height: 200px;
    margin-bottom: 10px;
    border: 2px dashed rgba(0, 180, 255, 0.2);
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    background-color: var(--surface);
}

.preview-container img {
    max-width: 100%;
    max-height: 300px;
    object-fit: contain;
}

/* Preview Button */
.preview-btn {
    margin-top: 10px;
    padding: 8px 16px;
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    color: var(--on-surface);
    border: 1px solid rgba(0, 180, 255, 0.1);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.preview-btn:hover {
    background: linear-gradient(45deg, var(--primary), var(--primary-variant));
    color: var(--on-primary);
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

/* Model Info Box */
.model-info-box {
    background: var(--surface);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    border: 1px solid rgba(0, 180, 255, 0.1);
}

.model-info-box h4 {
    color: var(--primary);
    margin-bottom: 10px;
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

/* File Inputs */
input[type="file"] {
    width: 100%;
    padding: 10px;
    background: var(--surface);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: var(--on-surface);
}

input[type="file"]::-webkit-file-upload-button {
    padding: 8px 16px;
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    color: var(--on-surface);
    border: 1px solid rgba(0, 180, 255, 0.1);
    border-radius: 8px;
    cursor: pointer;
    margin-right: 10px;
    transition: all 0.3s ease;
}

input[type="file"]::-webkit-file-upload-button:hover {
    background: linear-gradient(45deg, var(--primary), var(--primary-variant));
    color: var(--on-primary);
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

/* Submit Button */
.submit-btn {
    padding: 12px 24px;
    font-size: 1.1rem;
    background: linear-gradient(45deg, var(--primary), var(--primary-variant));
    color: var(--on-primary);
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    max-width: 200px;
    margin: 0 auto;
    display: block;
}

.submit-btn:hover {
    box-shadow: 0 0 30px rgba(187, 134, 252, 0.3);
    transform: translateY(-2px);
}

.submit-btn:disabled {
    background: var(--surface-2);
    cursor: not-allowed;
    transform: none;
}

/* Error States */
.error {
    border-color: var(--error) !important;
}

.error-message {
    color: var(--error);
    font-size: 0.875rem;
    margin-top: 5px;
}

/* Links */
a {
    color: var(--primary);
    text-decoration: none;
    transition: all 0.2s ease;
}

a:hover {
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

/* Responsive Design */
@media (max-width: 768px) {
    .container {
        padding: 15px;
    }

    .form-section {
        padding: 15px;
    }
}

```

Contents of js/characterCreation.js:
```
class CharacterCreator {
    constructor() {
        this.form = document.getElementById('characterForm');
        console.log('CharacterCreator initialized');
        this.initializeForm();
        console.log('Loading available voices...');
        this.loadAvailableVoices();
        this.setupEventListeners();
    }

    initializeForm() {
        this.form.addEventListener('submit', (e) => this.handleSubmit(e));
        
        // Setup image preview
        document.querySelector('input[name="avatar"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'avatarPreview'));
        document.querySelector('input[name="background"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'backgroundPreview'));

        // Setup voice preview
        const previewBtn = document.getElementById('previewVoiceBtn');
        if (previewBtn) {
            previewBtn.addEventListener('click', () => this.handleVoicePreview());
        }
    }

    setupEventListeners() {
        // Update value displays for sliders
        document.querySelectorAll('.slider-control input[type="range"]').forEach(slider => {
            const display = slider.nextElementSibling;
            slider.addEventListener('input', () => {
                display.textContent = slider.value;
            });
        });
    }

    async loadAvailableVoices() {
        const edge_voices = [
            "en-GB-LibbyNeural",
            "en-GB-MaisieNeural", 
            "en-GB-RyanNeural",
            "en-GB-SoniaNeural", 
            "en-GB-ThomasNeural",
            "en-US-AvaMultilingualNeural",
            "en-US-AndrewMultilingualNeural",
            "en-US-EmmaMultilingualNeural", 
            "en-US-BrianMultilingualNeural",
            "en-US-AvaNeural",
            "en-US-AndrewNeural",
            "en-US-EmmaNeural",
            "en-US-BrianNeural",
            "en-US-AnaNeural",
            "en-US-AriaNeural",
            "en-US-ChristopherNeural",
            "en-US-EricNeural",
            "en-US-GuyNeural",
            "en-US-JennyNeural",
            "en-US-MichelleNeural",
            "en-US-RogerNeural",
            "en-US-SteffanNeural"
        ];

        try {
            const select = document.querySelector('select[name="ttsVoice"]');
            if (!select) {
                throw new Error('Voice select element not found');
            }

            // Clear existing options
            select.innerHTML = '<option value="">Select TTS Voice</option>';
            
            // Add each voice as an option
            edge_voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice;
                option.textContent = voice;
                select.appendChild(option);
            });
                
        } catch (error) {
            console.error('Error loading voices:', error);
            const select = document.querySelector('select[name="ttsVoice"]');
            if (select) {
                select.innerHTML = '<option value="">Error loading voices</option>';
            }
        }
    }
    async handleVoicePreview() {
        const voiceSelect = document.querySelector('select[name="ttsVoice"]');
        const selectedVoice = voiceSelect.value;
        const previewBtn = document.getElementById('previewVoiceBtn');
        const loadingSpinner = previewBtn.querySelector('.loading');

        if (!selectedVoice) {
            alert('Please select a voice first');
            return;
        }

        try {
            // Show loading state
            previewBtn.disabled = true;
            loadingSpinner.style.display = 'inline-block';

            // Get current rate and pitch values
            const ttsRate = parseInt(document.querySelector('input[name="ttsRate"]').value) || 0;
            const rvcPitch = parseInt(document.querySelector('input[name="rvcPitch"]').value) || 0;

            const response = await fetch('/v1/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: "Hello! This is a preview of my voice.",
                    edge_voice: selectedVoice,
                    tts_rate: ttsRate,
                    rvc_pitch: rvcPitch
                })
            });

            if (!response.ok) {
                throw new Error('Failed to generate voice preview');
            }

            const data = await response.json();
            
            // Create and play audio
            const audio = new Audio(data.audio_url);
            await audio.play();

        } catch (error) {
            console.error('Error previewing voice:', error);
            alert('Failed to preview voice: ' + error.message);
        } finally {
            // Reset loading state
            previewBtn.disabled = false;
            loadingSpinner.style.display = 'none';
        }
    }

    async resizeImage(file, targetWidth = 256, targetHeight = 256, isBackground = false) {
        return new Promise((resolve) => {
            const img = new Image();
            const reader = new FileReader();

            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    // For backgrounds, preserve original dimensions and don't resize
                    if (isBackground) {
                        // If it's a GIF, just return the original file
                        if (file.type === 'image/gif') {
                            resolve(file);
                            return;
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        
                        canvas.toBlob((blob) => {
                            resolve(blob);
                        }, file.type, 0.95);
                        return;
                    }

                    // For avatars, keep the existing square resize logic
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');

                    // Fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Calculate scaling and position to maintain aspect ratio
                    let scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                    let x = (targetWidth - img.width * scale) / 2;
                    let y = (targetHeight - img.height * scale) / 2;

                    // Draw image centered
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                    // Convert to blob
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 0.95);
                };
            };
            reader.readAsDataURL(file);
        });
    }

    async handleImagePreview(event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const isBackground = previewId === 'backgroundPreview';
            const resizedBlob = await this.resizeImage(file, 256, 256, isBackground);
            const previewUrl = URL.createObjectURL(resizedBlob);
            
            const img = document.createElement('img');
            img.src = previewUrl;
            img.className = 'preview-image';
            if (isBackground) {
                img.style.width = '100%';
                img.style.height = 'auto';
            }
            
            const previewDiv = document.getElementById(previewId);
            previewDiv.innerHTML = '';
            previewDiv.appendChild(img);

            // Store the blob for later upload
            event.target.resizedBlob = resizedBlob;
        } catch (error) {
            console.error('Error handling image preview:', error);
        }
    }
    async handleSubmit(event) {
        event.preventDefault();
        
        try {
            const characterName = document.querySelector('input[name="name"]').value
                .toLowerCase()
                .replace(/[^a-z0-9]/g, '-');
                
            const checkResponse = await fetch(`/check-character/${characterName}`);
            if (checkResponse.ok) {
                const exists = await checkResponse.json();
                if (exists.exists) {
                    alert('A character with this name already exists. Please choose a different name.');
                    return;
                }
            }
            
            // Validate required fields
            const requiredFields = ['name', 'description', 'systemPrompt', 'ttsVoice'];
            for (const field of requiredFields) {
                const value = this.form.elements[field].value.trim();
                if (!value) {
                    alert(`${field.charAt(0).toUpperCase() + field.slice(1)} is required`);
                    return;
                }
            }

            const avatarInput = document.querySelector('input[name="avatar"]');
            const backgroundInput = document.querySelector('input[name="background"]');

            if (!avatarInput.files[0]) {
                alert('Avatar image is required');
                return;
            }

            // Upload images first
            const avatarPath = await this.uploadImage(avatarInput, 'avatar');
            const backgroundPath = backgroundInput.files.length > 0 ? 
                await this.uploadImage(backgroundInput, 'background') : 
                null;

            const formData = new FormData(this.form);
            const data = {
                id: characterName,
                name: formData.get('name'),
                description: formData.get('description'),
                systemPrompt: formData.get('systemPrompt'),
                ttsVoice: formData.get('ttsVoice'),
                category: formData.get('category'),
                is_private: formData.get('isPrivate') === 'on',
                tts_rate: parseInt(formData.get('ttsRate')) || 0,
                rvc_pitch: parseInt(formData.get('rvcPitch')) || 0,
                avatar: avatarPath,
                background: backgroundPath,
                greeting: formData.get('greeting') || "Hello!", // Added greeting
                settings: {
                    tts_rate: parseInt(formData.get('ttsRate')) || 0,
                    rvc_pitch: parseInt(formData.get('rvcPitch')) || 0
                }
            };

            // Validate the data
            const validatedData = this.validateParameters(data);

            const response = await fetch('/characters/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(validatedData)
            });

            if (!response.ok) {
                throw new Error('Failed to create character');
            }

            const result = await response.json();

            // Handle model upload if provided
            const modelFile = document.querySelector('input[name="modelFile"]');
            if (modelFile.files.length > 0) {
                await this.uploadModel(characterName);
            }

            alert('Character created successfully!');

            // Clear all input fields
            this.form.reset();
            avatarInput.value = '';
            backgroundInput.value = '';
            if (modelFile) modelFile.value = '';

            // Optional: Preview image resets
            const avatarPreview = document.getElementById('avatarPreview');
            const backgroundPreview = document.getElementById('backgroundPreview');
            if (avatarPreview) avatarPreview.src = '';
            if (backgroundPreview) backgroundPreview.src = '';

            // Redirect after a short delay to allow the user to see the success message
            setTimeout(() => {
                window.location.href = '/';
            }, 1500);

        } catch (error) {
            console.error('Error creating character:', error);
            alert('Error: ' + error.message);
        }
    }

    validateParameters(params) {
        const validated = {};
        
        // Required fields
        if (!params.name) throw new Error('Name is required');
        if (!params.description) throw new Error('Description is required');
        if (!params.systemPrompt) throw new Error('System prompt is required');
        if (!params.ttsVoice) throw new Error('TTS voice is required');
        if (!params.avatar) throw new Error('Avatar is required');
        
        // Validate numeric parameters
        if (params.temperature !== undefined) {
            validated.temperature = Math.min(Math.max(0.1, params.temperature), 2.0);
        }
        if (params.top_p !== undefined) {
            validated.top_p = Math.min(Math.max(0.1, params.top_p), 1.0);
        }
        if (params.top_k !== undefined) {
            validated.top_k = Math.min(Math.max(1, params.top_k), 100);
        }
        if (params.tts_rate !== undefined) {
            validated.tts_rate = Math.min(Math.max(-100, params.tts_rate), 100);
        }
        if (params.rvc_pitch !== undefined) {
            validated.rvc_pitch = Math.min(Math.max(-12, params.rvc_pitch), 12);
        }
        
        // Copy validated fields
        validated.id = params.id;
        validated.name = params.name;
        validated.description = params.description;
        validated.systemPrompt = params.systemPrompt;
        validated.ttsVoice = params.ttsVoice;
        validated.avatar = params.avatar;
        validated.category = params.category;
        validated.tags = params.tags;
        validated.is_private = params.is_private;
        validated.dateAdded = params.dateAdded;
        validated.greeting = params.greeting;
        validated.settings = params.settings;
        validated.ai_parameters = params.ai_parameters;
        
        // Optional background
        if (params.background) {
            validated.background = params.background;
        }
        
        return validated;
    }

    async uploadImage(inputElement, type) {
    if (!inputElement?.files[0] && !inputElement?.resizedBlob) return null;

    const formData = new FormData();
    const imageFile = inputElement.resizedBlob || inputElement.files[0];
    
    // Check file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm', 'video/x-ms-wmv'];
    if (!allowedTypes.includes(imageFile.type)) {
        throw new Error('Invalid file type. Please use JPG, PNG, GIF, WEBP or video files.');
    }

    // Get character name from the form and convert to valid ID format
    const characterName = document.querySelector('input[name="name"]').value
        .toLowerCase()
        .replace(/[^a-z0-9]/g, '-');

    // Create a new File object with the character ID in the filename
    const fileExtension = imageFile.type.split('/')[1];
    const newFileName = `${characterName}-${type}.${fileExtension}`;
    const file = new File([imageFile], newFileName, { type: imageFile.type });

    formData.append(type, file);
    formData.append('characterId', characterName);

    try {
        const endpoint = type === 'avatar' ? '/upload/avatar' : '/upload/character-background';
        console.log(`Uploading ${type} to ${endpoint}`);
        
        const response = await fetch(endpoint, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Upload error response:', errorText);
            throw new Error(errorText || `Failed to upload ${type}`);
        }
        
        const result = await response.json();
        console.log(`Successfully uploaded ${type}:`, result);
        return result.backgroundPath || result.avatarPath;

    } catch (error) {
        console.error(`Error uploading ${type}:`, error);
        throw error;
    }
}



    async uploadModel(characterId) {
        const modelFile = document.querySelector('input[name="modelFile"]').files[0];
        const indexFile = document.querySelector('input[name="indexFile"]').files[0];

        if (!modelFile || !indexFile) {
            return null;
        }

        const formData = new FormData();
        formData.append('modelFile', modelFile);
        formData.append('indexFile', indexFile);
        formData.append('characterId', characterId);

        try {
            const response = await fetch('/characters/upload-model', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Failed to upload model');
            }

            return await response.json();

        } catch (error) {
            console.error('Error uploading model:', error);
            throw error;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CharacterCreator();
});

```

Contents of js/.ipynb_checkpoints/characterCreation-checkpoint.js:
```
class CharacterCreator {
    constructor() {
        this.form = document.getElementById('characterForm');
        console.log('CharacterCreator initialized');
        this.initializeForm();
        console.log('Loading available voices...');
        this.loadAvailableVoices();
        this.setupEventListeners();
    }

    initializeForm() {
        this.form.addEventListener('submit', (e) => this.handleSubmit(e));
        
        // Setup image preview
        document.querySelector('input[name="avatar"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'avatarPreview'));
        document.querySelector('input[name="background"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'backgroundPreview'));

        // Setup voice preview
        const previewBtn = document.getElementById('previewVoiceBtn');
        if (previewBtn) {
            previewBtn.addEventListener('click', () => this.handleVoicePreview());
        }
    }

    setupEventListeners() {
        // Update value displays for sliders
        document.querySelectorAll('.slider-control input[type="range"]').forEach(slider => {
            const display = slider.nextElementSibling;
            slider.addEventListener('input', () => {
                display.textContent = slider.value;
            });
        });
    }

    async loadAvailableVoices() {
        const edge_voices = [
            "en-GB-LibbyNeural",
            "en-GB-MaisieNeural", 
            "en-GB-RyanNeural",
            "en-GB-SoniaNeural", 
            "en-GB-ThomasNeural",
            "en-US-AvaMultilingualNeural",
            "en-US-AndrewMultilingualNeural",
            "en-US-EmmaMultilingualNeural", 
            "en-US-BrianMultilingualNeural",
            "en-US-AvaNeural",
            "en-US-AndrewNeural",
            "en-US-EmmaNeural",
            "en-US-BrianNeural",
            "en-US-AnaNeural",
            "en-US-AriaNeural",
            "en-US-ChristopherNeural",
            "en-US-EricNeural",
            "en-US-GuyNeural",
            "en-US-JennyNeural",
            "en-US-MichelleNeural",
            "en-US-RogerNeural",
            "en-US-SteffanNeural"
        ];

        try {
            const select = document.querySelector('select[name="ttsVoice"]');
            if (!select) {
                throw new Error('Voice select element not found');
            }

            // Clear existing options
            select.innerHTML = '<option value="">Select TTS Voice</option>';
            
            // Add each voice as an option
            edge_voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice;
                option.textContent = voice;
                select.appendChild(option);
            });
                
        } catch (error) {
            console.error('Error loading voices:', error);
            const select = document.querySelector('select[name="ttsVoice"]');
            if (select) {
                select.innerHTML = '<option value="">Error loading voices</option>';
            }
        }
    }
    async handleVoicePreview() {
        const voiceSelect = document.querySelector('select[name="ttsVoice"]');
        const selectedVoice = voiceSelect.value;
        const previewBtn = document.getElementById('previewVoiceBtn');
        const loadingSpinner = previewBtn.querySelector('.loading');

        if (!selectedVoice) {
            alert('Please select a voice first');
            return;
        }

        try {
            // Show loading state
            previewBtn.disabled = true;
            loadingSpinner.style.display = 'inline-block';

            // Get current rate and pitch values
            const ttsRate = parseInt(document.querySelector('input[name="ttsRate"]').value) || 0;
            const rvcPitch = parseInt(document.querySelector('input[name="rvcPitch"]').value) || 0;

            const response = await fetch('/v1/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: "Hello! This is a preview of my voice.",
                    edge_voice: selectedVoice,
                    tts_rate: ttsRate,
                    rvc_pitch: rvcPitch
                })
            });

            if (!response.ok) {
                throw new Error('Failed to generate voice preview');
            }

            const data = await response.json();
            
            // Create and play audio
            const audio = new Audio(data.audio_url);
            await audio.play();

        } catch (error) {
            console.error('Error previewing voice:', error);
            alert('Failed to preview voice: ' + error.message);
        } finally {
            // Reset loading state
            previewBtn.disabled = false;
            loadingSpinner.style.display = 'none';
        }
    }

    async resizeImage(file, targetWidth = 256, targetHeight = 256, isBackground = false) {
        return new Promise((resolve) => {
            const img = new Image();
            const reader = new FileReader();

            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    // For backgrounds, preserve original dimensions and don't resize
                    if (isBackground) {
                        // If it's a GIF, just return the original file
                        if (file.type === 'image/gif') {
                            resolve(file);
                            return;
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        
                        canvas.toBlob((blob) => {
                            resolve(blob);
                        }, file.type, 0.95);
                        return;
                    }

                    // For avatars, keep the existing square resize logic
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');

                    // Fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Calculate scaling and position to maintain aspect ratio
                    let scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                    let x = (targetWidth - img.width * scale) / 2;
                    let y = (targetHeight - img.height * scale) / 2;

                    // Draw image centered
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                    // Convert to blob
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 0.95);
                };
            };
            reader.readAsDataURL(file);
        });
    }

    async handleImagePreview(event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const isBackground = previewId === 'backgroundPreview';
            const resizedBlob = await this.resizeImage(file, 256, 256, isBackground);
            const previewUrl = URL.createObjectURL(resizedBlob);
            
            const img = document.createElement('img');
            img.src = previewUrl;
            img.className = 'preview-image';
            if (isBackground) {
                img.style.width = '100%';
                img.style.height = 'auto';
            }
            
            const previewDiv = document.getElementById(previewId);
            previewDiv.innerHTML = '';
            previewDiv.appendChild(img);

            // Store the blob for later upload
            event.target.resizedBlob = resizedBlob;
        } catch (error) {
            console.error('Error handling image preview:', error);
        }
    }
    async handleSubmit(event) {
        event.preventDefault();
        
        try {
            const characterName = document.querySelector('input[name="name"]').value
                .toLowerCase()
                .replace(/[^a-z0-9]/g, '-');
                
            const checkResponse = await fetch(`/check-character/${characterName}`);
            if (checkResponse.ok) {
                const exists = await checkResponse.json();
                if (exists.exists) {
                    alert('A character with this name already exists. Please choose a different name.');
                    return;
                }
            }
            
            // Validate required fields
            const requiredFields = ['name', 'description', 'systemPrompt', 'ttsVoice'];
            for (const field of requiredFields) {
                const value = this.form.elements[field].value.trim();
                if (!value) {
                    alert(`${field.charAt(0).toUpperCase() + field.slice(1)} is required`);
                    return;
                }
            }

            const avatarInput = document.querySelector('input[name="avatar"]');
            const backgroundInput = document.querySelector('input[name="background"]');

            if (!avatarInput.files[0]) {
                alert('Avatar image is required');
                return;
            }

            // Upload images first
            const avatarPath = await this.uploadImage(avatarInput, 'avatar');
            const backgroundPath = backgroundInput.files.length > 0 ? 
                await this.uploadImage(backgroundInput, 'background') : 
                null;

            const formData = new FormData(this.form);
            const data = {
                id: characterName,
                name: formData.get('name'),
                description: formData.get('description'),
                systemPrompt: formData.get('systemPrompt'),
                ttsVoice: formData.get('ttsVoice'),
                category: formData.get('category'),
                is_private: formData.get('isPrivate') === 'on',
                tts_rate: parseInt(formData.get('ttsRate')) || 0,
                rvc_pitch: parseInt(formData.get('rvcPitch')) || 0,
                avatar: avatarPath,
                background: backgroundPath,
                greeting: formData.get('greeting') || "Hello!", // Added greeting
                settings: {
                    tts_rate: parseInt(formData.get('ttsRate')) || 0,
                    rvc_pitch: parseInt(formData.get('rvcPitch')) || 0
                }
            };

            // Validate the data
            const validatedData = this.validateParameters(data);

            const response = await fetch('/characters/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(validatedData)
            });

            if (!response.ok) {
                throw new Error('Failed to create character');
            }

            const result = await response.json();

            // Handle model upload if provided
            const modelFile = document.querySelector('input[name="modelFile"]');
            if (modelFile.files.length > 0) {
                await this.uploadModel(characterName);
            }

            alert('Character created successfully!');

            // Clear all input fields
            this.form.reset();
            avatarInput.value = '';
            backgroundInput.value = '';
            if (modelFile) modelFile.value = '';

            // Optional: Preview image resets
            const avatarPreview = document.getElementById('avatarPreview');
            const backgroundPreview = document.getElementById('backgroundPreview');
            if (avatarPreview) avatarPreview.src = '';
            if (backgroundPreview) backgroundPreview.src = '';

            // Redirect after a short delay to allow the user to see the success message
            setTimeout(() => {
                window.location.href = '/';
            }, 1500);

        } catch (error) {
            console.error('Error creating character:', error);
            alert('Error: ' + error.message);
        }
    }

    validateParameters(params) {
        const validated = {};
        
        // Required fields
        if (!params.name) throw new Error('Name is required');
        if (!params.description) throw new Error('Description is required');
        if (!params.systemPrompt) throw new Error('System prompt is required');
        if (!params.ttsVoice) throw new Error('TTS voice is required');
        if (!params.avatar) throw new Error('Avatar is required');
        
        // Validate numeric parameters
        if (params.temperature !== undefined) {
            validated.temperature = Math.min(Math.max(0.1, params.temperature), 2.0);
        }
        if (params.top_p !== undefined) {
            validated.top_p = Math.min(Math.max(0.1, params.top_p), 1.0);
        }
        if (params.top_k !== undefined) {
            validated.top_k = Math.min(Math.max(1, params.top_k), 100);
        }
        if (params.tts_rate !== undefined) {
            validated.tts_rate = Math.min(Math.max(-100, params.tts_rate), 100);
        }
        if (params.rvc_pitch !== undefined) {
            validated.rvc_pitch = Math.min(Math.max(-12, params.rvc_pitch), 12);
        }
        
        // Copy validated fields
        validated.id = params.id;
        validated.name = params.name;
        validated.description = params.description;
        validated.systemPrompt = params.systemPrompt;
        validated.ttsVoice = params.ttsVoice;
        validated.avatar = params.avatar;
        validated.category = params.category;
        validated.tags = params.tags;
        validated.is_private = params.is_private;
        validated.dateAdded = params.dateAdded;
        validated.greeting = params.greeting;
        validated.settings = params.settings;
        validated.ai_parameters = params.ai_parameters;
        
        // Optional background
        if (params.background) {
            validated.background = params.background;
        }
        
        return validated;
    }

    async uploadImage(inputElement, type) {
    if (!inputElement?.files[0] && !inputElement?.resizedBlob) return null;

    const formData = new FormData();
    const imageFile = inputElement.resizedBlob || inputElement.files[0];
    
    // Check file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm', 'video/x-ms-wmv'];
    if (!allowedTypes.includes(imageFile.type)) {
        throw new Error('Invalid file type. Please use JPG, PNG, GIF, WEBP or video files.');
    }

    // Get character name from the form and convert to valid ID format
    const characterName = document.querySelector('input[name="name"]').value
        .toLowerCase()
        .replace(/[^a-z0-9]/g, '-');

    // Create a new File object with the character ID in the filename
    const fileExtension = imageFile.type.split('/')[1];
    const newFileName = `${characterName}-${type}.${fileExtension}`;
    const file = new File([imageFile], newFileName, { type: imageFile.type });

    formData.append(type, file);
    formData.append('characterId', characterName);

    try {
        const endpoint = type === 'avatar' ? '/upload/avatar' : '/upload/character-background';
        console.log(`Uploading ${type} to ${endpoint}`);
        
        const response = await fetch(endpoint, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Upload error response:', errorText);
            throw new Error(errorText || `Failed to upload ${type}`);
        }
        
        const result = await response.json();
        console.log(`Successfully uploaded ${type}:`, result);
        return result.backgroundPath || result.avatarPath;

    } catch (error) {
        console.error(`Error uploading ${type}:`, error);
        throw error;
    }
}



    async uploadModel(characterId) {
        const modelFile = document.querySelector('input[name="modelFile"]').files[0];
        const indexFile = document.querySelector('input[name="indexFile"]').files[0];

        if (!modelFile || !indexFile) {
            return null;
        }

        const formData = new FormData();
        formData.append('modelFile', modelFile);
        formData.append('indexFile', indexFile);
        formData.append('characterId', characterId);

        try {
            const response = await fetch('/characters/upload-model', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Failed to upload model');
            }

            return await response.json();

        } catch (error) {
            console.error('Error uploading model:', error);
            throw error;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CharacterCreator();
});

```

