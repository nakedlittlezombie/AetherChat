Directory: main

Directory Structure:
```
.
.
├── ./.git
│   ├── ./.git/COMMIT_EDITMSG
│   ├── ./.git/HEAD
│   ├── ./.git/config
│   ├── ./.git/description
│   ├── ./.git/hooks
│   │   ├── ./.git/hooks/applypatch-msg.sample
│   │   ├── ./.git/hooks/commit-msg.sample
│   │   ├── ./.git/hooks/fsmonitor-watchman.sample
│   │   ├── ./.git/hooks/post-update.sample
│   │   ├── ./.git/hooks/pre-applypatch.sample
│   │   ├── ./.git/hooks/pre-commit.sample
│   │   ├── ./.git/hooks/pre-merge-commit.sample
│   │   ├── ./.git/hooks/pre-push.sample
│   │   ├── ./.git/hooks/pre-rebase.sample
│   │   ├── ./.git/hooks/pre-receive.sample
│   │   ├── ./.git/hooks/prepare-commit-msg.sample
│   │   ├── ./.git/hooks/push-to-checkout.sample
│   │   └── ./.git/hooks/update.sample
│   ├── ./.git/index
│   ├── ./.git/info
│   │   └── ./.git/info/exclude
│   ├── ./.git/logs
│   │   ├── ./.git/logs/HEAD
│   │       ├── ./.git/logs/refs/heads
│   │       │   └── ./.git/logs/refs/heads/main
│   │           └── ./.git/logs/refs/remotes/origin
│   │               ├── ./.git/logs/refs/remotes/origin/HEAD
│   │               └── ./.git/logs/refs/remotes/origin/main
│   │   ├── ./.git/objects/00
│   │   │   └── ./.git/objects/00/756179a29a34f9e875eeb018ed8a0dbc6e2529
│   │   ├── ./.git/objects/03
│   │   │   └── ./.git/objects/03/cd0b6a04494f528d7cc459d7af75f6d8ad5e34
│   │   ├── ./.git/objects/0e
│   │   │   └── ./.git/objects/0e/aefab0939bc571b5f5078798726749d11dbc37
│   │   ├── ./.git/objects/10
│   │   │   └── ./.git/objects/10/ed4a2cf8c8f9a1c05d42ff14750e7055e74b77
│   │   ├── ./.git/objects/17
│   │   │   └── ./.git/objects/17/bf592e3417d21a20a467970c5cb7641b5fdafe
│   │   ├── ./.git/objects/19
│   │   │   └── ./.git/objects/19/9b6c3c869bd797e76d9042fa781c03871d2743
│   │   ├── ./.git/objects/1b
│   │   │   └── ./.git/objects/1b/002e8b2386c9bb3057d2dfef529f0a923f38f9
│   │   ├── ./.git/objects/1f
│   │   │   ├── ./.git/objects/1f/aed3d445a7700d179bbca3f6b2b469edaace94
│   │   │   └── ./.git/objects/1f/dedf6bd57f54a1855a663ebcb32ec1d0708a3a
│   │   ├── ./.git/objects/28
│   │   │   └── ./.git/objects/28/72c2c122504ee19cb85add8ef8ddae6abf1d47
│   │   ├── ./.git/objects/29
│   │   │   └── ./.git/objects/29/4e30c594d62efc45b7555b2f023e016f8938c0
│   │   ├── ./.git/objects/2b
│   │   │   └── ./.git/objects/2b/eea99d3a032821b96dfb4703dea23a6d01561b
│   │   ├── ./.git/objects/34
│   │   │   └── ./.git/objects/34/1d7c3196cb447af9a4f12e73f943db9b88fd17
│   │   ├── ./.git/objects/36
│   │   │   ├── ./.git/objects/36/3fcab7ed6e9634e198cf5555ceb88932c9a245
│   │   │   └── ./.git/objects/36/93c4a026e055c067bf8ae0c99d064c431867cf
│   │   ├── ./.git/objects/3a
│   │   │   └── ./.git/objects/3a/9d6261bd606f6bb33d0e15d86416e8bdf641f0
│   │   ├── ./.git/objects/3c
│   │   │   └── ./.git/objects/3c/4f7fd51a04fba839512bb223f4cb591c51de54
│   │   ├── ./.git/objects/3d
│   │   │   └── ./.git/objects/3d/77809f42b6bf3f22189e9f4111468cdb7c65ad
│   │   ├── ./.git/objects/44
│   │   │   └── ./.git/objects/44/0a417412348ceb5841467d7b0196f72da3d3ff
│   │   ├── ./.git/objects/45
│   │   │   └── ./.git/objects/45/30317fa6fd2b307c7a9a59cc84b8b5d141c168
│   │   ├── ./.git/objects/4d
│   │   │   └── ./.git/objects/4d/ecac6106ffcea9764fdcd74a49dd75b2c7af08
│   │   ├── ./.git/objects/50
│   │   │   ├── ./.git/objects/50/9aecb36ad162410f7fa21ba0340c17c37b2bcb
│   │   │   └── ./.git/objects/50/f561476117464d0dad1623918970db84541d4b
│   │   ├── ./.git/objects/55
│   │   │   └── ./.git/objects/55/74b4b64926f7850fd55080383f177d8a3d87a9
│   │   ├── ./.git/objects/56
│   │   │   └── ./.git/objects/56/1064d6990c0dd82a97dab57efbccd5ecfca063
│   │   ├── ./.git/objects/5a
│   │   │   └── ./.git/objects/5a/7bf10ad10dec6d8d4aded0154f96cb623596a9
│   │   ├── ./.git/objects/5c
│   │   │   └── ./.git/objects/5c/3ec2fc446071ac6cf2659e450437119feba34c
│   │   ├── ./.git/objects/63
│   │   │   └── ./.git/objects/63/817f1ea4650f6a32a648d77fe8d670a798d536
│   │   ├── ./.git/objects/65
│   │   │   └── ./.git/objects/65/7b4d2473276a819d5c645831f06a4e650e0347
│   │   ├── ./.git/objects/66
│   │   │   └── ./.git/objects/66/f0f96cbc507ebeec14e2d4c1735c689cdc180d
│   │   ├── ./.git/objects/78
│   │   │   └── ./.git/objects/78/59f0a061c5345a15af9749eed8e7232b5bf930
│   │   ├── ./.git/objects/7a
│   │   │   └── ./.git/objects/7a/64a92bb554e2f49a9ce123de5683804e01d8f9
│   │   ├── ./.git/objects/7b
│   │   │   └── ./.git/objects/7b/96d8047ae5987e7096806d44f516cc3150a054
│   │   ├── ./.git/objects/86
│   │   │   └── ./.git/objects/86/f560ec4be582aea1186f222ec752dd055c4f9f
│   │   ├── ./.git/objects/87
│   │   │   └── ./.git/objects/87/9feb8a24e27642c1c32eb6319657d81da01a8a
│   │   ├── ./.git/objects/8d
│   │   │   └── ./.git/objects/8d/08508182a007ef7a8cd50df0da55657b6225ed
│   │   ├── ./.git/objects/8f
│   │   │   └── ./.git/objects/8f/5ddf1cae45a760682b783711d90d5b5676d819
│   │   ├── ./.git/objects/90
│   │   │   ├── ./.git/objects/90/909c17e82f776ea2bfcb10c1f1c8ac58ff334f
│   │   │   └── ./.git/objects/90/9d7f88ea33c5f95d7b386f16730a38a8b395bb
│   │   ├── ./.git/objects/95
│   │   │   └── ./.git/objects/95/1aa344213f5f7b5eb4f119f278e944f4295774
│   │   ├── ./.git/objects/96
│   │   │   └── ./.git/objects/96/a67d2dd55c00a78f14510f74a8f445fd062489
│   │   ├── ./.git/objects/9c
│   │   │   └── ./.git/objects/9c/aba47a9870a1e9c46852e096f6324e36211770
│   │   ├── ./.git/objects/9e
│   │   │   └── ./.git/objects/9e/dcbbe8ebb41f9b76a0a8b62c0b15af5115edfd
│   │   ├── ./.git/objects/a0
│   │   │   └── ./.git/objects/a0/7b457ead36946a4eb5ba7a77709eff7d7314ae
│   │   ├── ./.git/objects/a1
│   │   │   └── ./.git/objects/a1/4131cca1dbc4e07c6ee7a7e80278c351c6fc10
│   │   ├── ./.git/objects/a4
│   │   │   └── ./.git/objects/a4/ba9ed9cab64ea34b3c1d173b71307cc948c725
│   │   ├── ./.git/objects/ac
│   │   │   └── ./.git/objects/ac/5ab9f8b0723f31c436e6ee49df4f9f8c7cc54e
│   │   ├── ./.git/objects/b1
│   │   │   └── ./.git/objects/b1/69a8283764fa2e452f0ad8eee5af965b3ad289
│   │   ├── ./.git/objects/b3
│   │   │   └── ./.git/objects/b3/a79487bac24ca2cb8e2526fb0341b935913b40
│   │   ├── ./.git/objects/b5
│   │   │   └── ./.git/objects/b5/ea542d6358de60f904606134855df4e9c7da76
│   │   ├── ./.git/objects/b9
│   │   │   └── ./.git/objects/b9/0c7c7142088673d6e9971007bad668b367b3cc
│   │   ├── ./.git/objects/bb
│   │   │   └── ./.git/objects/bb/953ae5a40b497a53c9df5e04b90cbf545157cb
│   │   ├── ./.git/objects/bf
│   │   │   └── ./.git/objects/bf/498407c646856082ee865228058416f698febe
│   │   ├── ./.git/objects/c0
│   │   │   └── ./.git/objects/c0/fc17354f52f912efeb3944aef453042e88fa49
│   │   ├── ./.git/objects/c2
│   │   │   ├── ./.git/objects/c2/2fa73b7e36ca7dbcd622a7bbd7c552ebd1f169
│   │   │   ├── ./.git/objects/c2/8123e8ff99f399fbbcd1af2c2e3cce29acc69f
│   │   │   └── ./.git/objects/c2/fe4457bd81a5d8174fa10dd2c8aa8c6b840dd5
│   │   ├── ./.git/objects/c3
│   │   │   └── ./.git/objects/c3/c1a18d70ccd5eba2f97e03817a64a13e8a340a
│   │   ├── ./.git/objects/c4
│   │   │   └── ./.git/objects/c4/a66d07f16b22aaa589987f63bb8e3b5585c745
│   │   ├── ./.git/objects/cb
│   │   │   └── ./.git/objects/cb/fed874f75d06fbbd6ecf70683af9e0424bb84c
│   │   ├── ./.git/objects/cc
│   │   │   └── ./.git/objects/cc/9e2ee08815d34470964b28a3a401d9b536b395
│   │   ├── ./.git/objects/d1
│   │   │   └── ./.git/objects/d1/ec1df63e5d92f8bcef05c41d716827aa50798a
│   │   ├── ./.git/objects/d4
│   │   │   └── ./.git/objects/d4/b4841436f838be0966a221371398a3e63628c1
│   │   ├── ./.git/objects/df
│   │   │   └── ./.git/objects/df/c5cfa1b8a559c46a0b04111642fc1d2d510627
│   │   ├── ./.git/objects/e0
│   │   │   └── ./.git/objects/e0/f1b0c1874e6dc106a95ff3c707ba49df21a67c
│   │   ├── ./.git/objects/e6
│   │   │   └── ./.git/objects/e6/4f7eec87ea19afecd7e0b9b569a1b2776f07e3
│   │   ├── ./.git/objects/e9
│   │   │   ├── ./.git/objects/e9/52a0ff534c84d7d33d85cf8d734758a561c418
│   │   │   └── ./.git/objects/e9/deb820b5fef5c0f8ac3c2539c2d57c43b76656
│   │   ├── ./.git/objects/ea
│   │   │   ├── ./.git/objects/ea/6e33826b9d2f94bc725cc4a15a46f8c59e1c8f
│   │   │   └── ./.git/objects/ea/d8533ebcd3761305db4b02c5201da0f2a27a38
│   │   ├── ./.git/objects/ec
│   │   │   └── ./.git/objects/ec/f8feeede6a957a03f6ea030a92fbbbfafdc3f1
│   │   ├── ./.git/objects/ed
│   │   │   └── ./.git/objects/ed/7a2d27f4da54b66e014c4acd9b2b25d3627b88
│   │   ├── ./.git/objects/f8
│   │   │   └── ./.git/objects/f8/33bb63d1ef7b2d7833d0b6aed677398900d6be
│   │   ├── ./.git/objects/fb
│   │   │   └── ./.git/objects/fb/d26cf208f68f59614b23f58da7acc22c0fbd09
│   │   ├── ./.git/objects/fc
│   │   │   └── ./.git/objects/fc/628c830fa074d6cc226158f22f5328f5ec1165
│   │   ├── ./.git/objects/fd
│   │   │   └── ./.git/objects/fd/4f3b40e3189f6e43888d332e705eb74223697d
│   │   └── ./.git/objects/pack
│   │       ├── ./.git/objects/pack/pack-be269ee781faeeadfca208ad518d50335b50cbc8.idx
│   │       └── ./.git/objects/pack/pack-be269ee781faeeadfca208ad518d50335b50cbc8.pack
│   ├── ./.git/packed-refs
│       ├── ./.git/refs/heads
│       │   └── ./.git/refs/heads/main
│       │   └── ./.git/refs/remotes/origin
│       │       ├── ./.git/refs/remotes/origin/HEAD
│       │       └── ./.git/refs/remotes/origin/main
├── ./.ipynb_checkpoints
│   ├── ./.ipynb_checkpoints/auth-checkpoint.js
│   ├── ./.ipynb_checkpoints/characterCreation-checkpoint.js
│   ├── ./.ipynb_checkpoints/characters-checkpoint.js
│   ├── ./.ipynb_checkpoints/documentation-checkpoint.txt
│   ├── ./.ipynb_checkpoints/index-checkpoint.html
│   ├── ./.ipynb_checkpoints/index-checkpoint.json
│   ├── ./.ipynb_checkpoints/login-checkpoint.html
│   ├── ./.ipynb_checkpoints/register-checkpoint.html
│   ├── ./.ipynb_checkpoints/script-checkpoint.js
│   ├── ./.ipynb_checkpoints/styles-checkpoint.css
│   └── ./.ipynb_checkpoints/watch_characters-checkpoint.py
├── ./136.38.129.228+2-key.pem
├── ./136.38.129.228+2.pem
│   ├── ./assets/images
│   │   └── ./assets/images/default-background.jpg
│   └── ./assets/sounds
│       └── ./assets/sounds/phone-ring.mp3
├── ./auth.js
├── ./avatars
│   ├── ./avatars/aria-avatar.png
│   ├── ./avatars/beetlejuice-avatar.png
│   ├── ./avatars/default-user.png
│   ├── ./avatars/jeffy-avatar.png
│   ├── ./avatars/luna-avatar.png
│   ├── ./avatars/meatcanyon-avatar.png
│   ├── ./avatars/meatwad-avatar.png
│   ├── ./avatars/onyx-avatar.png
│   └── ./avatars/zeke-avatar.png
├── ./characterCreation.js
├── ./characters
│   ├── ./characters/.ipynb_checkpoints
│   │   ├── ./characters/.ipynb_checkpoints/Untitled-checkpoint.ipynb
│   │   ├── ./characters/.ipynb_checkpoints/aria-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/beetlejuice-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/index-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/jeffy-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/luna-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/meatcanyon-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/meatwad-checkpoint.json
│   │   ├── ./characters/.ipynb_checkpoints/onyx-checkpoint.json
│   │   └── ./characters/.ipynb_checkpoints/rick-checkpoint.json
│   ├── ./characters/Untitled.ipynb
│   ├── ./characters/aria.json
│   ├── ./characters/beetlejuice
│   │   └── ./characters/beetlejuice/background.jpg
│   ├── ./characters/beetlejuice.json
│   ├── ./characters/index.json
│   ├── ./characters/jeffy
│   │   └── ./characters/jeffy/background.jpg
│   ├── ./characters/jeffy.json
│   ├── ./characters/luna.json
│   ├── ./characters/meatcanyon
│   │   └── ./characters/meatcanyon/background.jpg
│   ├── ./characters/meatcanyon.json
│   ├── ./characters/meatwad
│   │   └── ./characters/meatwad/background.jpg
│   ├── ./characters/meatwad.json
│   ├── ./characters/onyx.json
│   ├── ./characters/rick.json
│   └── ./characters/zeke
│       └── ./characters/zeke/background.jpg
├── ./characters.js
├── ./chat
│   ├── ./chat/.ipynb_checkpoints
│   │   ├── ./chat/.ipynb_checkpoints/chat-checkpoint.html
│   │   ├── ./chat/.ipynb_checkpoints/chat-checkpoint.js
│   │   └── ./chat/.ipynb_checkpoints/chat-styles-checkpoint.css
│   ├── ./chat/chat-styles.css
│   ├── ./chat/chat.html
│   └── ./chat/chat.js
├── ./css
│   ├── ./css/.ipynb_checkpoints
│   │   └── ./css/.ipynb_checkpoints/create-character-checkpoint.css
│   └── ./css/create-character.css
├── ./documentation.txt
├── ./index.html
├── ./index.json
├── ./js
│   ├── ./js/.ipynb_checkpoints
│   │   └── ./js/.ipynb_checkpoints/characterCreation-checkpoint.js
│   └── ./js/characterCreation.js
├── ./login.html
├── ./logo.jpg
├── ./register.html
├── ./script.js
├── ./styles.css
└── ./watch_characters.py
```

Contents of index.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <title>AetherChat - AI Character Chat</title>
</head>
<body>
    <nav class="nav-panel">
        <div class="logo-container">
            <img src="./logo.jpg" alt="AetherChat" class="logo-image">
        </div>
        
        <div id="auth-section" class="nav-section">
            <div id="logged-out-view">
                <button class="nav-button" id="login-button">
                    <span>👤</span>
                    Login
                </button>
                <button class="nav-button" id="register-button">
                    <span>✨</span>
                    Sign Up
                </button>
            </div>
            <div id="logged-in-view" style="display: none">
                <div class="user-info">
                    <span id="username-display"></span>
                    <span id="credits-display"></span>
                </div>
                <button class="nav-button" id="logout-button">
                    <span>🚪</span>
                    Logout
                </button>
            </div>
        </div>
            
        <div class="nav-section">
            <h2>Search</h2>
            <input type="text" class="search-bar" id="search" placeholder="Search characters...">
        </div>
        
        <div class="nav-section">
            <h2>Create</h2>
            <a href="/create-character" class="nav-button" id="create-character">
                <span>+</span>
                Create New Character
            </a>
        </div>
        
        <div class="nav-section">
            <h2>Categories</h2>
            <div id="category-filters"></div>
        </div>
        
        <div class="nav-section">
            <h2>Tags</h2>
            <div id="tag-filters"></div>
        </div>
    </nav>

    <main>
        <div id="character-grid" class="character-grid"></div>
    </main>

    <dialog id="auth-modal" class="modal">
        <div class="modal-content">
            <!-- Login Form -->
            <form id="login-form" class="auth-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" required>
                </div>
                <div id="login-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Login</button>
                    <button type="button" class="switch-to-register">Need an account?</button>
                </div>
            </form>

            <!-- Register Form -->
            <form id="register-form" class="auth-form" style="display: none;">
                <h2>Create Account</h2>
                <div class="form-group">
                    <label for="register-username">Username</label>
                    <input type="text" id="register-username" required>
                </div>
                <div class="form-group">
                    <label for="register-email">Email</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password</label>
                    <input type="password" id="register-password" required>
                </div>
                <div id="register-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Register</button>
                    <button type="button" class="switch-to-login">Already have an account?</button>
                </div>
            </form>
        </div>
        <button class="modal-close" id="close-auth-modal">&times;</button>
    </dialog>

    <script type="module" src="./auth.js"></script>
    <script type="module" src="./characters.js"></script>
    <script type="module" src="./script.js"></script>
</body>
</html>

```

Contents of index.json:
```
{
    "characters": [],
    "lastUpdated": "2024-11-28T00:00:00Z"
}
EOF
```

Contents of script.js:
```
import { currentUser, checkAuth } from './auth.js';

// State management
let characters = [];
let activeFilters = {
    categories: new Set(),
    tags: new Set(),
    search: '',
    view: 'grid',
    sort: 'random'
};

// Load characters from the index
async function loadCharacters() {
    try {
        console.log("Fetching character index...");
        const response = await fetch('./characters/index.json');
        if (!response.ok) throw new Error(`Failed to load character index: ${response.status}`);

        const data = await response.json();
        console.log("Character index loaded:", data);

        // Load individual character files
        characters = await Promise.all(
    data.characters.map(async (file) => {
        try {
            const response = await fetch(`./characters/${file}`);
            if (!response.ok) throw new Error(`Failed to load character file: ${file}`);
            return await response.json();
        } catch (error) {
            console.error(error);
            return null;
        }
    })
);

// Only filter private characters
characters = characters.filter((char) => {
    if (!char) return false;
    if (char.isPrivate) {
        return currentUser && char.creator === currentUser.id;
    }
    return true;  // Show all non-private characters
});
        

        // Filter out null values and private characters unless they belong to the user
        characters = characters.filter((char) => {
            if (!char) return false;
            if (char.isPrivate) {
                return currentUser && char.creator === currentUser.id;
            }
            return true;
        });

        console.log("Final character list:", characters);
        initializeFilters();
        updateCharacterDisplay();
    } catch (error) {
        console.error('Error loading characters:', error);
        characters = [];
        updateCharacterDisplay();
    }
}

// Initialize filters
function initializeFilters() {
    const categories = new Set();
    const tags = new Set();

    characters.forEach((char) => {
        if (char.category) categories.add(char.category);
        if (char.tags) char.tags.forEach((tag) => tags.add(tag));
    });

    const categoryFilters = document.getElementById('category-filters');
    const tagFilters = document.getElementById('tag-filters');
    
    if (categoryFilters) {
        categoryFilters.innerHTML = '';
        Array.from(categories).sort().forEach((category) => {
            const btn = createFilterButton(category, 'category');
            categoryFilters.appendChild(btn);
        });
    }

    if (tagFilters) {
        tagFilters.innerHTML = '';
        Array.from(tags).sort().forEach((tag) => {
            const btn = createFilterButton(tag, 'tag');
            tagFilters.appendChild(btn);
        });
    }
}

function createFilterButton(value, type) {
    const button = document.createElement('button');
    button.classList.add('filter-button');
    // Check if the filter set exists before trying to use it
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet && filterSet.has(value)) {
        button.classList.add('active');
    }
    button.textContent = value;
    button.addEventListener('click', () => toggleFilter(value, type));
    return button;
}

function toggleFilter(value, type) {
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet.has(value)) {
        filterSet.delete(value);
    } else {
        filterSet.add(value);
    }
    updateCharacterDisplay();
}

// Update character display
function updateCharacterDisplay() {
    const characterGrid = document.getElementById('character-grid');
    if (!characterGrid) return;

    const filteredChars = filterCharacters();
    const sortedChars = sortCharacters(filteredChars);

    characterGrid.innerHTML = '';

    if (sortedChars.length === 0) {
        const noResults = document.createElement('p');
        noResults.className = 'no-results';
        noResults.textContent = currentUser ? 
            'No characters found. Try creating one!' : 
            'No characters found. Try logging in to see more!';
        characterGrid.appendChild(noResults);
        return;
    }

    sortedChars.forEach((char) => {
        const card = createCharacterCard(char);
        characterGrid.appendChild(card);
    });
}

function filterCharacters() {
    return characters.filter((char) => {
        const matchesSearch = char.name.toLowerCase().includes(activeFilters.search.toLowerCase()) ||
                            char.description.toLowerCase().includes(activeFilters.search.toLowerCase());
        const matchesCategories = !activeFilters.categories.size || 
                                activeFilters.categories.has(char.category);
        const matchesTags = !activeFilters.tags.size || 
                          char.tags?.some((tag) => activeFilters.tags.has(tag));
        return matchesSearch && matchesCategories && matchesTags;
    });
}

function sortCharacters(chars) {
    const charsCopy = [...chars];
    switch (activeFilters.sort) {
        case 'name':
            charsCopy.sort((a, b) => a.name.localeCompare(b.name));
            break;
        case 'newest':
            charsCopy.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
            break;
        case 'random':
        default:
            for (let i = charsCopy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [charsCopy[i], charsCopy[j]] = [charsCopy[j], charsCopy[i]];
            }
    }
    return charsCopy;
}

function createCharacterCard(char) {
    const card = document.createElement('div');
    card.classList.add('character-card');

    const tagsHtml = char.tags
        ? char.tags.map((tag) => `<span class="tag">${tag}</span>`).join('')
        : '';

    card.innerHTML = `
        <img class="character-image" src="${char.avatar}" alt="${char.name}" 
             onerror="this.src='./avatars/default-user.png'">
        <div class="character-info">
            <h2>${char.name}</h2>
            <p>${char.description}</p>
            <div class="character-meta">
                ${char.category ? `<span class="category-badge">${char.category}</span>` : ''}
                ${tagsHtml}
                ${char.isPrivate ? '<span class="private-badge">Private</span>' : ''}
            </div>
        </div>
    `;

    card.addEventListener('click', () => {
    if (!currentUser) {
        sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
        window.location.href = './login.html';
        return;
    }
    sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
    window.location.href = './chat/chat.html';
});

    return card;
}

// Event Listeners
document.addEventListener('DOMContentLoaded', async () => {
    await checkAuth();
    loadCharacters();

    const searchInput = document.getElementById('search');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            activeFilters.search = e.target.value;
            updateCharacterDisplay();
        });
    }
});

// Export functions that might be needed by other modules
export {
    loadCharacters,
    updateCharacterDisplay
};
```

Contents of styles.css:
```
:root {
  --primary: #00b4ff;
  --primary-variant: #bb86fc;
  --secondary: #03DAC6;
  --background: #121212;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --error: #CF6679;
  --on-primary: #000000;
  --on-secondary: #000000;
  --on-background: #FFFFFF;
  --on-surface: #FFFFFF;
  --on-error: #000000;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--background);
  color: var(--on-background);
  min-height: 100vh;
  display: flex;
}

.menu-toggle {
  display: none;
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
  background: var(--surface);
  border: none;
  color: var(--on-surface);
  font-size: 1.5rem;
  padding: 0.5rem;
  border-radius: 8px;
  cursor: pointer;
}

.logo-container {
  padding: 0;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.logo-image {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.nav-panel {
  width: 280px;
  background-color: var(--surface);
  height: 100vh;
  position: fixed;
  left: 0;
  display: flex;
  flex-direction: column;
  gap: 2rem;
  z-index: 100;
  transition: transform 0.3s ease;
  padding: 0;
  box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.nav-section h2 {
  font-size: 0.9rem;
  text-transform: uppercase;
  color: var(--primary);
  letter-spacing: 0.1em;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
  background: var(--surface-2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 0.75rem 1rem;
  border-radius: 8px;
  color: var(--on-surface);
  width: 100%;
  transition: all 0.3s ease;
}

.search-bar:focus {
  border-color: var(--primary);
  box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1rem;
  background: linear-gradient(45deg, var(--surface-2), var(--surface));
  border: none;
  border-radius: 8px;
  color: var(--on-surface);
  cursor: pointer;
  transition: all 0.2s ease;
}

.nav-button:hover {
  background: linear-gradient(45deg, var(--primary), var(--primary-variant));
  color: var(--on-primary);
  box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
  margin-left: 280px;
  flex: 1;
  padding: 2rem;
  min-height: 100vh;
}

.character-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1.5rem;
  padding: 1rem;
}

.character-card {
  background: var(--surface);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
  border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
  border-color: var(--primary-variant);
}

.character-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

.character-info {
  padding: 1rem;
}

.character-info h2 {
  color: var(--on-surface);
  font-size: 1.1rem;
  margin-bottom: 0.5rem;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.tag {
  background: var(--surface-2);
  color: var(--on-surface);
  padding: 0.25rem 0.75rem;
  border-radius: 16px;
  font-size: 0.8rem;
  border: 1px solid rgba(187, 134, 252, 0.2);
  transition: all 0.2s ease;
}

.tag:hover {
  background: var(--primary-variant);
  box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
    margin-bottom: 2rem;
}

.user-info {
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
    color: var(--primary);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

@media (max-width: 1200px) {
  .character-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 992px) {
  .nav-panel {
    width: 240px;
  }
  
  main {
    margin-left: 240px;
  }
}

@media (max-width: 768px) {
  .menu-toggle {
    display: block;
  }

  .nav-panel {
    transform: translateX(-100%);
    width: 100%;
    max-width: 300px;
  }

  .nav-panel.active {
    transform: translateX(0);
  }

  main {
    margin-left: 0;
    padding: 1rem;
  }
  
  .character-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .character-grid {
    grid-template-columns: 1fr;
  }
}:root {
 --primary: #00b4ff;
 --primary-variant: #bb86fc;
 --secondary: #03DAC6;
 --background: #121212;
 --surface: #1E1E1E;
 --surface-2: #2D2D2D;
 --error: #CF6679;
 --on-primary: #000000;
 --on-secondary: #000000;
 --on-background: #FFFFFF;
 --on-surface: #FFFFFF;
 --on-error: #000000;
}

* {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
}

body {
 font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
 background-color: var(--background);
 color: var(--on-background);
 min-height: 100vh;
 display: flex;
}

.menu-toggle {
 display: none;
}

.logo-container {
 padding: 0;
 width: 100%;
 display: flex;
 justify-content: center;
 align-items: center;
}

.logo-image {
 width: 100%;
 height: auto;
 object-fit: contain;
}

.nav-panel {
 width: 280px;
 background-color: var(--surface);
 height: 100vh;
 position: fixed;
 left: 0;
 display: flex;
 flex-direction: column;
 gap: 2rem;
 z-index: 100;
 transition: transform 0.3s ease;
 padding: 0;
 box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
 padding: 2rem;
 display: flex;
 flex-direction: column;
 gap: 1rem;
}

.nav-section h2 {
 font-size: 0.9rem;
 text-transform: uppercase;
 color: var(--primary);
 letter-spacing: 0.1em;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
 background: var(--surface-2);
 border: 1px solid rgba(255, 255, 255, 0.1);
 padding: 0.75rem 1rem;
 border-radius: 8px;
 color: var(--on-surface);
 width: 100%;
 transition: all 0.3s ease;
}

.search-bar:focus {
 border-color: var(--primary);
 box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.75rem 1rem;
 background: linear-gradient(45deg, var(--surface-2), var(--surface));
 border: none;
 border-radius: 8px;
 color: var(--on-surface);
 cursor: pointer;
 transition: all 0.2s ease;
}

.nav-button:hover {
 background: linear-gradient(45deg, var(--primary), var(--primary-variant));
 color: var(--on-primary);
 box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
 margin-left: 280px;
 flex: 1;
 padding: 2rem;
 min-height: 100vh;
}

.character-grid {
 display: grid;
 grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 gap: 1.5rem;
 padding: 1rem;
}

.character-card {
 background: var(--surface);
 border-radius: 12px;
 overflow: hidden;
 transition: all 0.3s ease;
 cursor: pointer;
 border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
 transform: translateY(-4px);
 box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
 border-color: var(--primary-variant);
}

.character-image {
 width: 100%;
 height: 200px;
 object-fit: cover;
}

.character-info {
 padding: 1rem;
}

.character-info h2 {
 color: var(--on-surface);
 font-size: 1.1rem;
 margin-bottom: 0.5rem;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
 display: flex;
 gap: 0.5rem;
 flex-wrap: wrap;
}

.tag {
 background: var(--surface-2);
 color: var(--on-surface);
 padding: 0.25rem 0.75rem;
 border-radius: 16px;
 font-size: 0.8rem;
 border: 1px solid rgba(187, 134, 252, 0.2);
 transition: all 0.2s ease;
}

.tag:hover {
 background: var(--primary-variant);
 box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
   margin-bottom: 2rem;
}

.user-info {
   background: linear-gradient(45deg, var(--surface-2), var(--surface));
   padding: 1rem;
   border-radius: 8px;
   border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
   color: var(--primary);
   text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

header {
   padding: 8px 20px;
   height: 60px;
   display: flex;
   align-items: center;
   gap: 15px;
   background-color: rgba(30, 30, 30, 0.7);
   backdrop-filter: blur(10px);
}

.header-text {
   display: flex;
   flex-direction: column;
}

.chat-header-avatar {
   width: 40px;
   height: 40px;
   border-radius: 50%;
   overflow: hidden;
   border: 2px solid var(--primary);
}

@media only screen and (max-width: 1200px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 992px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 768px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
   transform: none;
 }
 main {
   margin-left: 280px;
 }
 .menu-toggle {
   display: none;
 }
}

@media only screen and (max-width: 480px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}
```

Contents of watch_characters.py:
```
#!/usr/bin/env python3
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time
import json
import os
from threading import Timer

class CharacterDirectoryHandler(FileSystemEventHandler):
    def __init__(self):
        self.characters_dir = 'characters'
        if not os.path.exists(self.characters_dir):
            os.makedirs(self.characters_dir)
            print(f"Created characters directory: {self.characters_dir}")
        
        self.update_index()  # Initial update
    
    def on_any_event(self, event):
        if event.is_directory or 'index.json' in event.src_path:
            return
            
        print(f"Change detected in: {event.src_path}")
        # Small delay to ensure file writing is complete
        time.sleep(0.1)
        self.update_index()
    
    def update_index(self):
        try:
            character_files = [f for f in os.listdir(self.characters_dir) 
                             if f.endswith('.json') and f != 'index.json']
            
            print(f"Found character files: {character_files}")
            
            valid_files = []
            for file in character_files:
                try:
                    file_path = os.path.join(self.characters_dir, file)
                    with open(file_path, 'r', encoding='utf-8') as f:
                        json.load(f)
                    valid_files.append(file)
                except Exception as e:
                    print(f"Warning: Invalid file {file}: {str(e)}")
            
            index_data = {
                "characters": sorted(valid_files),
                "lastUpdated": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            index_path = os.path.join(self.characters_dir, 'index.json')
            with open(index_path, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, indent=4)
            
            print(f"Updated index.json - {len(valid_files)} valid characters found")
            
        except Exception as e:
            print(f"Error updating index: {str(e)}")

def main():
    event_handler = CharacterDirectoryHandler()
    observer = Observer()
    observer.schedule(event_handler, path='characters', recursive=False)
    observer.start()
    
    print("Watching characters directory for changes...")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("\nStopping watch...")
        observer.join()

if __name__ == "__main__":
    main()
```

Contents of documentation.txt:
```
Usage

TTS-with-RVC has a class called TTS_RVC. There are a few parameters that are required:

rvc_path - path to your installed rvclib directory (Usually in the venv/src folder. )

input_directory - path to your input directory (Temp directory for saving TTS output)

model_path - path to your .pth model

And optional parameters:

voice - voice from edge-tts list (default is "ru-RU-DmitryNeural")

output_directory - directory for saving voiced audio (temp/ is default).

index_path - path to the file index for voice model adjustments (default is empty string "").

index_rate - blending rate between original and indexed voice conversion (default is 0.75).

To set the voice, firstly, make instance of TTS_RVC:

from tts_with_rvc import TTS_RVC

tts = TTS_RVC(rvc_path="src\\rvclib", model_path="models\\YourModel.pth", input_directory="input\\", index_path="logs\\YourIndex.index")

All voices available placed in voices.txt file:

tts.get_voices() is disabled indefinitely due to the problems

Next, set the voice for TTS with tts.set_voice() function:

tts.set_voice("un-Un-SelectedNeural")

Setting the appropriate language is necessary if you are using other languages for voiceovers!

And final step is calling tts to replace voice:

path = tts(text="Привет, мир!", pitch=6, index_rate=0.50)

Parameters:

text - text for TTS (required)

pitch - pitch for RVC (optional, neg. values are compatible, default is 0)

tts_rate - extra rate of speech (optional, neg. values are compatible, default is 0)

tts_volume - extra volume of speech (optional, neg. values are compatible, default is 0)

tts_pitch - extra pitch of TTS-generated audio (optional, neg. values are compatible, not recommended, default is 0)

output_filename - specified path for voiced audio (optional, default is None)
Example of usage

A simple example for voicing text:

from tts_with_rvc import TTS_RVC
from playsound import playsound

tts = TTS_RVC(
    rvc_path="src\\rvclib", 
    model_path="models\\DenVot.pth", 
    input_directory="input\\",
    index_path="logs\\added_IVF1749_Flat_nprobe_1.index"
)
tts.set_voice("ru-RU-DmitryNeural")
path = tts(text="Привет, мир!", pitch=6, index_rate=0.9)

playsound(path)

Text parameters

There are some text parameters processor for integration issues such as adding GPT module.

You can process them using process_args in TTS_RVC class:

--tts-rate (value) - TTS parameter to edit the speech rate (negative value for decreasing rate and positive value for increasing rate)

--tts-volume (value) - TTS parameter to edit the speech volume (negative value for decreasing volume and positive value for increasing volume) Seems to not work because of the RVC module conversion.

--tts-pitch (value) - TTS parameter to edit the pitch of TTS generated audio (negative value for decreasing pitch and positive value for increasing pitch) I do not recommend using this because the RVC module has its own pitch for output.

--rvc-pitch (value) - RVC parameter to edit the pitch of the output audio (negative value for decreasing pitch and positive value for increasing pitch)

Now the principle of work:

from tts_with_rvc import TTS_RVC

tts = TTS_RVC(rvc_path="src\\rvclib", model_path="models\\YourModel.pth", input_directory="input\\")

# This method returns arguments and original text without these text parameters
args, message = tts.process_args(message)

The args variable contains an array with the following structure:

args[0] - TTS Rate

args[1] - TTS Volume

args[2] - TTS Pitch

args[3] - RVC pitch

And now we are ready to use it for generation:

path = tts(message, pitch=args[3],
               tts_rate=args[0],
               tts_volume=args[1],
               tts_pitch=args[2])

Methods
set_index_path(index_path) - updates the path to the index file for voice model adjustments.
```

Contents of 136.38.129.228+2.pem:
```
-----BEGIN CERTIFICATE-----
MIIEGDCCAoCgAwIBAgIQOefcsC8Jx2zsBmmJKlk6QzANBgkqhkiG9w0BAQsFADBf
MR4wHAYDVQQKExVta2NlcnQgZGV2ZWxvcG1lbnQgQ0ExGjAYBgNVBAsMEXJvb3RA
ZDAxNjA1NjY3ZjM3MSEwHwYDVQQDDBhta2NlcnQgcm9vdEBkMDE2MDU2NjdmMzcw
HhcNMjQxMTI5MTAwNDQ2WhcNMjcwMzAxMTAwNDQ2WjBFMScwJQYDVQQKEx5ta2Nl
cnQgZGV2ZWxvcG1lbnQgY2VydGlmaWNhdGUxGjAYBgNVBAsMEXJvb3RAZDAxNjA1
NjY3ZjM3MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzjzuB+SXjIX2
kip4XYwWTjB2GxAYUgWgXripLEJav2ovqzzcbl/9EtVAUu2ncrTXhq5oX5eVySTT
mM3B5YIzLT0uwPUM/qtICIBPW6mHNwPys7cCGT8fmOThMwD+mneH7EswzzV/twtC
Ra/eL5SB+VHMHeTo0jp+wibA3yxPRwkkf2jhr88SdpkFhH4D2Yv5mft5aCPxbSrN
oQjRvUWS7t14BzxGECkLfSjhuZlK4QjFCPjXsvgYYVI2ah04WPwheKQaMbOoVKSH
irRrQ/ALpU1Lw7gHv13u8EAp9/jEBWmdlY+tZtH+nGOcK5RfGfNmmmv48cGiQ+hh
RTMUqnUBuQIDAQABo2owaDAOBgNVHQ8BAf8EBAMCBaAwEwYDVR0lBAwwCgYIKwYB
BQUHAwEwHwYDVR0jBBgwFoAU3BDuIiyzTBWBa2ax21X4aE2Ym7gwIAYDVR0RBBkw
F4IJbG9jYWxob3N0hwSIJoHkhwR/AAABMA0GCSqGSIb3DQEBCwUAA4IBgQAhQRxn
nFA/Nx45ROx3sbvOKfd5hopoYSeoNZxZXwsJLPcFAcyovgorj8Q3FcA4YHIGomx2
X9NPYzbVfn621QmutfxRb+X3iQ/AnLoIwkBMqcVyBncMeYR/jMxvSnx2x0Pn5i3P
rbSfAmfAIzdOaCJwHIIJVwNCwVdU6w1DfroPqJnXH5gE6Pf5UgCISKT6CWaSce+a
N5xbIV7iPPh5JntzVw/gl8N8eaJcw8+Vuk5Xoq/+sp9q+odXeF8BBiQQdTeZWDGK
iEgrqUjY8zmITyIPWgXb/IVJl8A18T8A+eZ8yBbvwwvmpT7Flfq/0xXgGejYL/Hy
KRg1vadK7izKCzRsWj3cjQ1zhpAum371EZ20aEYULYDvlUuf6LxtMrU/n0qllyT4
+m1/j6KG/7o4m24LLWPZbpyE3Gzj8h6VhtRAmADG7bRqmI6GyP7yaDQvPO+B71hL
qyxN2JisvsIAj4141gKsAF07rY2ItsQdVE715cFcN/vB/k4w4jYHoOMsjKA=
-----END CERTIFICATE-----

```

Contents of 136.38.129.228+2-key.pem:
```
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDOPO4H5JeMhfaS
KnhdjBZOMHYbEBhSBaBeuKksQlq/ai+rPNxuX/0S1UBS7adytNeGrmhfl5XJJNOY
zcHlgjMtPS7A9Qz+q0gIgE9bqYc3A/KztwIZPx+Y5OEzAP6ad4fsSzDPNX+3C0JF
r94vlIH5Ucwd5OjSOn7CJsDfLE9HCSR/aOGvzxJ2mQWEfgPZi/mZ+3loI/FtKs2h
CNG9RZLu3XgHPEYQKQt9KOG5mUrhCMUI+Ney+BhhUjZqHThY/CF4pBoxs6hUpIeK
tGtD8AulTUvDuAe/Xe7wQCn3+MQFaZ2Vj61m0f6cY5wrlF8Z82aaa/jxwaJD6GFF
MxSqdQG5AgMBAAECggEBAIONghguzCyq1xltVdH2JdRCPVQN9DV9uUoyaFb/DHvE
9Bs6ezE8sWVt+dXsGj+k80XJwnIXc0gW4ZI6zU/kuVhGCqiyp1NbVlt13SkO/l0t
e4b/WatZBIK2nJ+4Jq/JRz6Gx9+ktI7B88gX4pZfGHk8oAMBnTFcdrbJmYXB8d/Q
483Sxw13+bzBf4yIJArhCjs5Q+WLLLiLb5mT+904POjpZpjvTcab635TgYjg4ESU
N+OR0vuzKNBGNZBgM3vYCl5mmdmTip7ntVi93VZcVKeD4h3EEt8Ag12HgfZVe7aY
3ZhcFRuwf/Lx8SraIj808BTnPDOGjXZ6pI5zEC9vJHECgYEA7k8pfjgOrncseQ3s
Kwhjn3GWYwke2428LeapCjFBC+m3JXFfpCJyjNvI9B0pHAmJrBgpxa+49rO7tWbM
sZZfVYblc8HoYWFjubtdYLWwhpJnf9gAVzB5g8YhIIEpNkdF+DHo7LMmtL1KiAZL
vKFSpiXfGOAJIsjcojsToF5rLe8CgYEA3YxI9fjyDCD2dITT7oBXU8mTqIRnw1NR
eUOl7NJE/GT2BVytok8L8hyd1BvyH5KDzDLDnY2Io4GmPj9duu9RushdxRRFbw73
rx1WdxF7yMFTOz3cekhGtB+YXXi5i12/MJadoarwXg8Y24g/ti6CoICOodWXqxNu
Jk4M8bjTctcCgYAtMtp91AgE0xmeRCO87bRnc1XApuQxZCqC0jLRehIKPmO8OEqZ
iOcNDEqK8lTvumdgOp0Bn5iHQgOiHkNIk2q1gAZY9Dgs8BnICl9ljlBS1cXHm6JE
5y7E7Xku/xBf+RiuQFkbO8dllFlkfz0yI67XUGuF/kf9Tvd51ZadXgsaBQKBgChO
RFvTnZ2NRakvHStv1/NbYeyvof0MJG9uWjp6iqhsacHR+ZjkzqSOhjw3lVYfHrFA
rwvz2t78UFVUy+Wdcn4Lw9t985/f1jnamYdx+9YrLcxCVeE9UvekI+ElfIQZWxYo
4Kav5akHEBuobwbi8Urn+IsCw+QQ1eJMIti7KmTjAoGACnqad1D8aNNSFx19IqqV
kTMDCOmc7LFBpgU0GLbIBtFaJ/DptTsF+jMp9ZMZPYnMd9JZEWYnYko0N05LGHjG
vh4SH2jkO8FaxYSY67l7hLXP1u65QAZn9PHro+q94igqLr37YAX0s0WOAHxqFtA+
1VtmpWTjproiJ78DnrmilN4=
-----END PRIVATE KEY-----

```

Contents of login.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .oauth-buttons {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .oauth-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
            cursor: pointer;
        }

        .oauth-button:hover {
            background: var(--surface);
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Login to SpeakEasy</h1>
        <form class="auth-form" id="loginForm">
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <button type="submit">Login</button>
        </form>
        
        <div class="oauth-buttons">
            <button class="oauth-button" id="googleLogin">
                <img src="https://www.google.com/favicon.ico" alt="Google" width="20" height="20">
                Continue with Google
            </button>
        </div>
        
        <p>Don't have an account? <a href="/register.html">Register</a></p>
    </div>

    <script>
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            try {
                const response = await fetch('/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: document.getElementById('email').value,
                        password: document.getElementById('password').value
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    window.location.href = '/';
                } else {
                    alert(data.error);
                }
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed. Please try again.');
            }
        });

        document.getElementById('googleLogin').addEventListener('click', () => {
            window.location.href = '/auth/google';
        });
    </script>
</body>
</html>
```

Contents of register.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Register - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .error-message {
            color: var(--error);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Create Account</h1>
        <form class="auth-form" id="registerForm">
            <input type="text" id="username" placeholder="Username" required>
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <input type="password" id="confirmPassword" placeholder="Confirm Password" required>
            <div class="error-message" id="errorMessage"></div>
            <button type="submit">Register</button>
        </form>
        
        <p>Already have an account? <a href="/login.html">Login</a></p>
    </div>

    <script>
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const errorMessage = document.getElementById('errorMessage');
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            if (password !== confirmPassword) {
                errorMessage.textContent = 'Passwords do not match';
                return;
            }

            try {
                const response = await fetch('/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: document.getElementById('username').value,
                        email: document.getElementById('email').value,
                        password: password
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    // Registration successful, redirect to home page
                    window.location.href = '/';
                } else {
                    errorMessage.textContent = data.error || 'Registration failed';
                }
            } catch (error) {
                console.error('Registration error:', error);
                errorMessage.textContent = 'Registration failed. Please try again.';
            }
        });
    </script>
</body>
</html>
```

Contents of logo.jpg:
```
[Could not decode file contents]

```

Contents of characterCreation.js:
```
class CharacterCreator {
    constructor() {
        this.form = document.getElementById('characterForm');
        console.log('CharacterCreator initialized');
        this.initializeForm();
        console.log('Loading available voices...');
        this.loadAvailableVoices();
        this.setupEventListeners();
    }

    initializeForm() {
        this.form.addEventListener('submit', (e) => this.handleSubmit(e));
        
        // Setup image preview
        document.querySelector('input[name="avatar"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'avatarPreview'));
        document.querySelector('input[name="background"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'backgroundPreview'));

        // Setup voice preview
        const previewBtn = document.getElementById('previewVoiceBtn');
        if (previewBtn) {
            previewBtn.addEventListener('click', () => this.handleVoicePreview());
        }
    }

    setupEventListeners() {
        // Update value displays for sliders
        document.querySelectorAll('.slider-control input[type="range"]').forEach(slider => {
            const display = slider.nextElementSibling;
            slider.addEventListener('input', () => {
                display.textContent = slider.value;
            });
        });
    }

    async loadAvailableVoices() {
        try {
            console.log('Fetching voices from API...');
            const response = await fetch('/api/available-voices');
            console.log('API response status:', response.status);
            if (!response.ok) {
                throw new Error('Failed to load voices');
            }
            const data = await response.json();
            console.log('Received voices data:', data);
            
            if (!data.edge_voices || !data.edge_voices.length) {
                throw new Error('No voices available');
            }
            
            this.populateVoiceDropdown(data.edge_voices);
        } catch (error) {
            console.error('Error loading voices:', error);
            const select = document.getElementById('ttsVoice');
            select.innerHTML = '<option value="">Error loading voices</option>';
        }
    }

    populateVoiceDropdown(voices) {
        const select = document.getElementById('ttsVoice');
        select.innerHTML = '<option value="">Select TTS Voice</option>';
        
        // Group voices by region and type
        const grouped = voices.reduce((acc, voice) => {
            const [region] = voice.split('-');
            if (!acc[region]) acc[region] = [];
            acc[region].push(voice);
            return acc;
        }, {});
        
        // Create option groups
        Object.entries(grouped).forEach(([region, regionVoices]) => {
            const group = document.createElement('optgroup');
            group.label = region === 'en-GB' ? 'British English' : 'American English';
            
            regionVoices.sort().forEach(voice => {
                const option = document.createElement('option');
                option.value = voice;
                option.textContent = voice;
                group.appendChild(option);
            });
            
            select.appendChild(group);
        });
    }

    async handleVoicePreview() {
        const voiceSelect = document.getElementById('ttsVoice');
        const selectedVoice = voiceSelect.value;
        const previewBtn = document.getElementById('previewVoiceBtn');
        const loadingSpinner = previewBtn.querySelector('.loading');

        if (!selectedVoice) {
            alert('Please select a voice first');
            return;
        }

        try {
            // Show loading state
            previewBtn.disabled = true;
            loadingSpinner.style.display = 'inline-block';

            // Get current rate and pitch values
            const ttsRate = parseInt(document.querySelector('input[name="ttsRate"]').value) || 0;
            const rvcPitch = parseInt(document.querySelector('input[name="rvcPitch"]').value) || 0;

            const response = await fetch('/v1/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: "Hello! This is a preview of my voice.",
                    edge_voice: selectedVoice,
                    tts_rate: ttsRate,
                    rvc_pitch: rvcPitch
                })
            });

            if (!response.ok) {
                throw new Error('Failed to generate voice preview');
            }

            const data = await response.json();
            
            // Create and play audio
            const audio = new Audio(data.audio_url);
            await audio.play();

        } catch (error) {
            console.error('Error previewing voice:', error);
            alert('Failed to preview voice: ' + error.message);
        } finally {
            // Reset loading state
            previewBtn.disabled = false;
            loadingSpinner.style.display = 'none';
        }
    }

    async resizeImage(file, targetWidth = 256, targetHeight = 256) {
        return new Promise((resolve) => {
            const img = new Image();
            const reader = new FileReader();

            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');

                    // Fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Calculate scaling and position to maintain aspect ratio
                    let scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                    let x = (targetWidth - img.width * scale) / 2;
                    let y = (targetHeight - img.height * scale) / 2;

                    // Draw image centered
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                    // Convert to blob
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 0.95);
                };
            };
            reader.readAsDataURL(file);
        });
    }

    async handleImagePreview(event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const resizedBlob = await this.resizeImage(file);
            const previewUrl = URL.createObjectURL(resizedBlob);
            
            const img = document.createElement('img');
            img.src = previewUrl;
            img.className = 'preview-image';
            
            const previewDiv = document.getElementById(previewId);
            previewDiv.innerHTML = '';
            previewDiv.appendChild(img);

            // Store the blob for later upload
            event.target.resizedBlob = resizedBlob;
        } catch (error) {
            console.error('Error handling image preview:', error);
        }
    }

    async uploadImage(inputElement, type) {
        if (!inputElement?.files[0] && !inputElement?.resizedBlob) return null;

        const formData = new FormData();
        formData.append('image', inputElement.resizedBlob || inputElement.files[0]);
        formData.append('type', type);

        try {
            const response = await fetch('/upload/image', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) throw new Error('Failed to upload image');
            const result = await response.json();
            return result.path;

        } catch (error) {
            console.error(`Error uploading ${type}:`, error);
            throw error;
        }
    }

    async uploadModel(characterId) {
        const modelFile = document.querySelector('input[name="modelFile"]').files[0];
        const indexFile = document.querySelector('input[name="indexFile"]').files[0];

        if (!modelFile || !indexFile) {
            return null;
        }

        const formData = new FormData();
        formData.append('modelFile', modelFile);
        formData.append('indexFile', indexFile);
        formData.append('characterId', characterId);

        try {
            const response = await fetch('/characters/upload-model', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Failed to upload model');
            }

            return await response.json();

        } catch (error) {
            console.error('Error uploading model:', error);
            throw error;
        }
    }

    validateParameters(params) {
        const validated = {};
        
        if (params.temperature !== undefined) {
            validated.temperature = Math.min(Math.max(0.1, params.temperature), 2.0);
        }
        if (params.top_p !== undefined) {
            validated.top_p = Math.min(Math.max(0.1, params.top_p), 1.0);
        }
        if (params.top_k !== undefined) {
            validated.top_k = Math.min(Math.max(1, params.top_k), 100);
        }
        
        validated.name = params.name;
        validated.description = params.description;
        validated.systemPrompt = params.systemPrompt;
        validated.ttsVoice = params.ttsVoice;
        validated.avatar = params.avatar;
        
        if (params.background) validated.background = params.background;
        if (params.category) validated.category = params.category;
        if (params.tags) validated.tags = params.tags;
        if (params.is_private !== undefined) validated.is_private = params.is_private;
        if (params.tts_rate !== undefined) validated.tts_rate = params.tts_rate;
        if (params.rvc_pitch !== undefined) validated.rvc_pitch = params.rvc_pitch;
        
        return validated;
    }

    async handleSubmit(event) {
        event.preventDefault();
        
        try {
            const avatarInput = document.querySelector('input[name="avatar"]');
            const backgroundInput = document.querySelector('input[name="background"]');

            // Upload images first
            const avatarPath = await this.uploadImage(avatarInput, 'avatar');
            const backgroundPath = await this.uploadImage(backgroundInput, 'background');

            const formData = new FormData(event.target);
            const data = {
                name: formData.get('name'),
                description: formData.get('description'),
                systemPrompt: formData.get('systemPrompt'),
                ttsVoice: formData.get('ttsVoice'),
                category: formData.get('category'),
                tags: formData.get('tags')?.split(',').map(tag => tag.trim()) || [],
                is_private: formData.get('isPrivate') === 'true',
                tts_rate: parseInt(formData.get('ttsRate')) || 0,
                rvc_pitch: parseInt(formData.get('rvcPitch')) || 0,
                temperature: parseFloat(formData.get('temperature')) || 0.7,
                top_p: parseFloat(formData.get('topP')) || 0.9,
                top_k: parseInt(formData.get('topK')) || 40,
                avatar: avatarPath,
                background: backgroundPath
            };

            const validatedData = this.validateParameters(data);

            const response = await fetch('/characters/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(validatedData)
            });

            if (!response.ok) {
                throw new Error('Failed to create character');
            }

            const result = await response.json();
            const characterId = result.character_id;

            if (document.querySelector('input[name="modelFile"]').files.length > 0) {
                await this.uploadModel(characterId);
            }

            alert('Character created successfully!');
            window.location.href = '/characters';

        } catch (error) {
            console.error('Error:', error);
            alert('Error: ' + error.message);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CharacterCreator();
});

```

Contents of auth.js:
```
import { loadCharacters } from './script.js';

// Auth state management
let currentUser = null;

// DOM Elements
const authModal = document.getElementById('auth-modal');
const loginButton = document.getElementById('login-button');
const registerButton = document.getElementById('register-button');
const logoutButton = document.getElementById('logout-button');
const switchToRegisterButton = document.querySelector('.switch-to-register');
const switchToLoginButton = document.querySelector('.switch-to-login');
const loginError = document.getElementById('login-error');
const registerError = document.getElementById('register-error');
const closeAuthModalButton = document.getElementById('close-auth-modal');

// Check authentication status
async function checkAuth() {
    try {
        const response = await fetch('/auth/user', {
            credentials: 'include',
            headers: {
                'Cache-Control': 'no-cache'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            currentUser = data.user;
            updateAuthUI();
            return true;
        } else {
            currentUser = null;
            updateAuthUI();
            return false;
        }
    } catch (error) {
        console.error('Auth check failed:', error);
        currentUser = null;
        updateAuthUI();
        return false;
    }
}

// Update UI based on auth state
function updateAuthUI() {
    const loggedOutView = document.getElementById('logged-out-view');
    const loggedInView = document.getElementById('logged-in-view');
    const usernameDisplay = document.getElementById('username-display');
    const creditsDisplay = document.getElementById('credits-display');
    const createCharacterBtn = document.getElementById('create-character');

    if (currentUser) {
        loggedOutView.style.display = 'none';
        loggedInView.style.display = 'block';
        usernameDisplay.textContent = currentUser.username;
        creditsDisplay.textContent = `Credits: ${currentUser.credits}`;
        createCharacterBtn.disabled = false;
    } else {
        loggedOutView.style.display = 'block';
        loggedInView.style.display = 'none';
        createCharacterBtn.disabled = true;
    }
}

// Modal controls
function openAuthModal(type = 'login') {
    authModal.showModal();
    switchAuthForm(type);
}

function closeAuthModal() {
    authModal.close();
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    loginForm?.reset();
    registerForm?.reset();
    if (loginError) loginError.textContent = '';
    if (registerError) registerError.textContent = '';
}

function switchAuthForm(type) {
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    if (!loginForm || !registerForm) return;

    if (type === 'login') {
        loginForm.style.display = 'block';
        registerForm.style.display = 'none';
    } else {
        loginForm.style.display = 'none';
        registerForm.style.display = 'block';
    }
}

// Handle login
async function handleLogin(e) {
    e.preventDefault();
    if (!loginError) return;
    loginError.textContent = '';
    
    const email = document.getElementById('login-email')?.value;
    const password = document.getElementById('login-password')?.value;
    
    try {
        const response = await fetch('/auth/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            loginError.textContent = data.error || 'Login failed';
        }
    } catch (error) {
        console.error('Login error:', error);
        loginError.textContent = 'Login failed. Please try again.';
    }
}

// Handle registration
async function handleRegister(e) {
    e.preventDefault();
    if (!registerError) return;
    registerError.textContent = '';
    
    const username = document.getElementById('register-username')?.value;
    const email = document.getElementById('register-email')?.value;
    const password = document.getElementById('register-password')?.value;
    
    try {
        const response = await fetch('/auth/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ username, email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            registerError.textContent = data.error || 'Registration failed';
        }
    } catch (error) {
        console.error('Registration error:', error);
        registerError.textContent = 'Registration failed. Please try again.';
    }
}

// Handle logout
async function handleLogout() {
    try {
        const response = await fetch('/auth/logout', {
            credentials: 'include'
        });
        
        if (response.ok) {
            currentUser = null;
            updateAuthUI();
            await loadCharacters();
        }
    } catch (error) {
        console.error('Logout error:', error);
    }
}

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    checkAuth();
    
    loginButton?.addEventListener('click', () => openAuthModal('login'));
    registerButton?.addEventListener('click', () => openAuthModal('register'));
    logoutButton?.addEventListener('click', handleLogout);
    closeAuthModalButton?.addEventListener('click', closeAuthModal);
    
    document.getElementById('login-form')?.addEventListener('submit', handleLogin);
    document.getElementById('register-form')?.addEventListener('submit', handleRegister);
    
    document.querySelector('.switch-to-register')?.addEventListener('click', () => switchAuthForm('register'));
    document.querySelector('.switch-to-login')?.addEventListener('click', () => switchAuthForm('login'));
});

export {
    currentUser,
    checkAuth,
    updateAuthUI,
    openAuthModal
};
```

Contents of characters.js:
```
import { currentUser } from './auth.js';

const characterModal = document.getElementById('character-modal');
const characterForm = document.getElementById('character-form');

// Modal controls
function openCharacterModal() {
    if (!currentUser) {
        openAuthModal();
        return;
    }
    setupImagePreviews();
    characterModal.showModal();
}

function closeCharacterModal() {
    characterModal.close();
    characterForm.reset();
    document.getElementById('avatar-preview').innerHTML = '';
    document.getElementById('background-preview').innerHTML = '';
}

// Image preview handling
function setupImagePreviews() {
    const avatarInput = document.getElementById('avatar');
    const backgroundInput = document.getElementById('background');
    
    if (avatarInput) {
        setupImagePreview(avatarInput, document.getElementById('avatar-preview'));
    }
    if (backgroundInput) {
        setupImagePreview(backgroundInput, document.getElementById('background-preview'));
    }
}

function setupImagePreview(input, previewElement) {
    if (!input || !previewElement) return;
    
    input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement('img');
                img.src = e.target.result;
                previewElement.innerHTML = '';
                previewElement.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    });
}

// Handle character creation
characterForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
        // First upload images
        const avatarFile = document.getElementById('avatar').files[0];
        const backgroundFile = document.getElementById('background')?.files[0];
        
        // Upload avatar
        const avatarFormData = new FormData();
        avatarFormData.append('avatar', avatarFile);
        const avatarResponse = await fetch('/upload/avatar', {
            method: 'POST',
            credentials: 'include',
            body: avatarFormData
        });
        
        if (!avatarResponse.ok) {
            throw new Error('Failed to upload avatar');
        }
        
        const { avatarPath } = await avatarResponse.json();
        let backgroundPath = null;
        
        // Upload background if provided
        if (backgroundFile) {
            const backgroundFormData = new FormData();
            backgroundFormData.append('background', backgroundFile);
            const backgroundResponse = await fetch('/upload/character-background', {
                method: 'POST',
                credentials: 'include',
                body: backgroundFormData
            });
            
            if (backgroundResponse.ok) {
                const data = await backgroundResponse.json();
                backgroundPath = data.backgroundPath;
            }
        }
        
        // Create character data
        const formData = new FormData(characterForm);
        const character = {
            name: formData.get('name'),
            description: formData.get('description'),
            systemPrompt: formData.get('systemPrompt'),
            avatar: avatarPath,
            background: backgroundPath,
            ttsVoice: formData.get('ttsVoice'),
            category: formData.get('category'),
            is_private: formData.get('is_private') === 'on',
            tts_rate: parseInt(formData.get('tts_rate')) || 0,
            rvc_pitch: parseInt(formData.get('rvc_pitch')) || 0,
            tags: formData.get('tags')?.split(',').map(tag => tag.trim()).filter(tag => tag) || []
        };
        
        const response = await fetch('/characters/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify(character)
        });
        
        if (!response.ok) {
            throw new Error('Failed to create character');
        }
        
        const { character_id } = await response.json();
        
        // Submit for review if needed
        if (!character.is_private && formData.get('submit_for_review') === 'on') {
            await fetch(`/characters/submit-for-review/${character_id}`, {
                method: 'POST',
                credentials: 'include'
            });
        }
        
        closeCharacterModal();
        window.location.reload(); // Reload to show new character
        
    } catch (error) {
        console.error('Error creating character:', error);
        alert('Failed to create character. Please try again.');
    }
});

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
    const createCharacterBtn = document.getElementById('create-character');
    const closeModalBtns = document.querySelectorAll('.modal-close');
    
    createCharacterBtn?.addEventListener('click', openCharacterModal);
    closeModalBtns.forEach(btn => {
        btn?.addEventListener('click', closeCharacterModal);
    });
});

export {
    openCharacterModal,
    closeCharacterModal
};
```

Contents of .ipynb_checkpoints/index-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <title>AetherChat - AI Character Chat</title>
</head>
<body>
    <nav class="nav-panel">
        <div class="logo-container">
            <img src="./logo.jpg" alt="AetherChat" class="logo-image">
        </div>
        
        <div id="auth-section" class="nav-section">
            <div id="logged-out-view">
                <button class="nav-button" id="login-button">
                    <span>👤</span>
                    Login
                </button>
                <button class="nav-button" id="register-button">
                    <span>✨</span>
                    Sign Up
                </button>
            </div>
            <div id="logged-in-view" style="display: none">
                <div class="user-info">
                    <span id="username-display"></span>
                    <span id="credits-display"></span>
                </div>
                <button class="nav-button" id="logout-button">
                    <span>🚪</span>
                    Logout
                </button>
            </div>
        </div>
            
        <div class="nav-section">
            <h2>Search</h2>
            <input type="text" class="search-bar" id="search" placeholder="Search characters...">
        </div>
        
        <div class="nav-section">
            <h2>Create</h2>
            <a href="/create-character" class="nav-button" id="create-character">
                <span>+</span>
                Create New Character
            </a>
        </div>
        
        <div class="nav-section">
            <h2>Categories</h2>
            <div id="category-filters"></div>
        </div>
        
        <div class="nav-section">
            <h2>Tags</h2>
            <div id="tag-filters"></div>
        </div>
    </nav>

    <main>
        <div id="character-grid" class="character-grid"></div>
    </main>

    <dialog id="auth-modal" class="modal">
        <div class="modal-content">
            <!-- Login Form -->
            <form id="login-form" class="auth-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" required>
                </div>
                <div id="login-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Login</button>
                    <button type="button" class="switch-to-register">Need an account?</button>
                </div>
            </form>

            <!-- Register Form -->
            <form id="register-form" class="auth-form" style="display: none;">
                <h2>Create Account</h2>
                <div class="form-group">
                    <label for="register-username">Username</label>
                    <input type="text" id="register-username" required>
                </div>
                <div class="form-group">
                    <label for="register-email">Email</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password</label>
                    <input type="password" id="register-password" required>
                </div>
                <div id="register-error" class="error-message"></div>
                <div class="form-actions">
                    <button type="submit">Register</button>
                    <button type="button" class="switch-to-login">Already have an account?</button>
                </div>
            </form>
        </div>
        <button class="modal-close" id="close-auth-modal">&times;</button>
    </dialog>

    <script type="module" src="./auth.js"></script>
    <script type="module" src="./characters.js"></script>
    <script type="module" src="./script.js"></script>
</body>
</html>

```

Contents of .ipynb_checkpoints/index-checkpoint.json:
```
{
    "characters": [],
    "lastUpdated": "2024-11-28T00:00:00Z"
}
EOF
```

Contents of .ipynb_checkpoints/script-checkpoint.js:
```
import { currentUser, checkAuth } from './auth.js';

// State management
let characters = [];
let activeFilters = {
    categories: new Set(),
    tags: new Set(),
    search: '',
    view: 'grid',
    sort: 'random'
};

// Load characters from the index
async function loadCharacters() {
    try {
        console.log("Fetching character index...");
        const response = await fetch('./characters/index.json');
        if (!response.ok) throw new Error(`Failed to load character index: ${response.status}`);

        const data = await response.json();
        console.log("Character index loaded:", data);

        // Load individual character files
        characters = await Promise.all(
    data.characters.map(async (file) => {
        try {
            const response = await fetch(`./characters/${file}`);
            if (!response.ok) throw new Error(`Failed to load character file: ${file}`);
            return await response.json();
        } catch (error) {
            console.error(error);
            return null;
        }
    })
);

// Only filter private characters
characters = characters.filter((char) => {
    if (!char) return false;
    if (char.isPrivate) {
        return currentUser && char.creator === currentUser.id;
    }
    return true;  // Show all non-private characters
});
        

        // Filter out null values and private characters unless they belong to the user
        characters = characters.filter((char) => {
            if (!char) return false;
            if (char.isPrivate) {
                return currentUser && char.creator === currentUser.id;
            }
            return true;
        });

        console.log("Final character list:", characters);
        initializeFilters();
        updateCharacterDisplay();
    } catch (error) {
        console.error('Error loading characters:', error);
        characters = [];
        updateCharacterDisplay();
    }
}

// Initialize filters
function initializeFilters() {
    const categories = new Set();
    const tags = new Set();

    characters.forEach((char) => {
        if (char.category) categories.add(char.category);
        if (char.tags) char.tags.forEach((tag) => tags.add(tag));
    });

    const categoryFilters = document.getElementById('category-filters');
    const tagFilters = document.getElementById('tag-filters');
    
    if (categoryFilters) {
        categoryFilters.innerHTML = '';
        Array.from(categories).sort().forEach((category) => {
            const btn = createFilterButton(category, 'category');
            categoryFilters.appendChild(btn);
        });
    }

    if (tagFilters) {
        tagFilters.innerHTML = '';
        Array.from(tags).sort().forEach((tag) => {
            const btn = createFilterButton(tag, 'tag');
            tagFilters.appendChild(btn);
        });
    }
}

function createFilterButton(value, type) {
    const button = document.createElement('button');
    button.classList.add('filter-button');
    // Check if the filter set exists before trying to use it
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet && filterSet.has(value)) {
        button.classList.add('active');
    }
    button.textContent = value;
    button.addEventListener('click', () => toggleFilter(value, type));
    return button;
}

function toggleFilter(value, type) {
    const filterSet = type === 'category' ? activeFilters.categories : activeFilters.tags;
    if (filterSet.has(value)) {
        filterSet.delete(value);
    } else {
        filterSet.add(value);
    }
    updateCharacterDisplay();
}

// Update character display
function updateCharacterDisplay() {
    const characterGrid = document.getElementById('character-grid');
    if (!characterGrid) return;

    const filteredChars = filterCharacters();
    const sortedChars = sortCharacters(filteredChars);

    characterGrid.innerHTML = '';

    if (sortedChars.length === 0) {
        const noResults = document.createElement('p');
        noResults.className = 'no-results';
        noResults.textContent = currentUser ? 
            'No characters found. Try creating one!' : 
            'No characters found. Try logging in to see more!';
        characterGrid.appendChild(noResults);
        return;
    }

    sortedChars.forEach((char) => {
        const card = createCharacterCard(char);
        characterGrid.appendChild(card);
    });
}

function filterCharacters() {
    return characters.filter((char) => {
        const matchesSearch = char.name.toLowerCase().includes(activeFilters.search.toLowerCase()) ||
                            char.description.toLowerCase().includes(activeFilters.search.toLowerCase());
        const matchesCategories = !activeFilters.categories.size || 
                                activeFilters.categories.has(char.category);
        const matchesTags = !activeFilters.tags.size || 
                          char.tags?.some((tag) => activeFilters.tags.has(tag));
        return matchesSearch && matchesCategories && matchesTags;
    });
}

function sortCharacters(chars) {
    const charsCopy = [...chars];
    switch (activeFilters.sort) {
        case 'name':
            charsCopy.sort((a, b) => a.name.localeCompare(b.name));
            break;
        case 'newest':
            charsCopy.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
            break;
        case 'random':
        default:
            for (let i = charsCopy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [charsCopy[i], charsCopy[j]] = [charsCopy[j], charsCopy[i]];
            }
    }
    return charsCopy;
}

function createCharacterCard(char) {
    const card = document.createElement('div');
    card.classList.add('character-card');

    const tagsHtml = char.tags
        ? char.tags.map((tag) => `<span class="tag">${tag}</span>`).join('')
        : '';

    card.innerHTML = `
        <img class="character-image" src="${char.avatar}" alt="${char.name}" 
             onerror="this.src='./avatars/default-user.png'">
        <div class="character-info">
            <h2>${char.name}</h2>
            <p>${char.description}</p>
            <div class="character-meta">
                ${char.category ? `<span class="category-badge">${char.category}</span>` : ''}
                ${tagsHtml}
                ${char.isPrivate ? '<span class="private-badge">Private</span>' : ''}
            </div>
        </div>
    `;

    card.addEventListener('click', () => {
    if (!currentUser) {
        sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
        window.location.href = './login.html';
        return;
    }
    sessionStorage.setItem('selectedCharacter', JSON.stringify(char));
    window.location.href = './chat/chat.html';
});

    return card;
}

// Event Listeners
document.addEventListener('DOMContentLoaded', async () => {
    await checkAuth();
    loadCharacters();

    const searchInput = document.getElementById('search');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            activeFilters.search = e.target.value;
            updateCharacterDisplay();
        });
    }
});

// Export functions that might be needed by other modules
export {
    loadCharacters,
    updateCharacterDisplay
};
```

Contents of .ipynb_checkpoints/styles-checkpoint.css:
```
:root {
  --primary: #00b4ff;
  --primary-variant: #bb86fc;
  --secondary: #03DAC6;
  --background: #121212;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --error: #CF6679;
  --on-primary: #000000;
  --on-secondary: #000000;
  --on-background: #FFFFFF;
  --on-surface: #FFFFFF;
  --on-error: #000000;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--background);
  color: var(--on-background);
  min-height: 100vh;
  display: flex;
}

.menu-toggle {
  display: none;
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
  background: var(--surface);
  border: none;
  color: var(--on-surface);
  font-size: 1.5rem;
  padding: 0.5rem;
  border-radius: 8px;
  cursor: pointer;
}

.logo-container {
  padding: 0;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.logo-image {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.nav-panel {
  width: 280px;
  background-color: var(--surface);
  height: 100vh;
  position: fixed;
  left: 0;
  display: flex;
  flex-direction: column;
  gap: 2rem;
  z-index: 100;
  transition: transform 0.3s ease;
  padding: 0;
  box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.nav-section h2 {
  font-size: 0.9rem;
  text-transform: uppercase;
  color: var(--primary);
  letter-spacing: 0.1em;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
  background: var(--surface-2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 0.75rem 1rem;
  border-radius: 8px;
  color: var(--on-surface);
  width: 100%;
  transition: all 0.3s ease;
}

.search-bar:focus {
  border-color: var(--primary);
  box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1rem;
  background: linear-gradient(45deg, var(--surface-2), var(--surface));
  border: none;
  border-radius: 8px;
  color: var(--on-surface);
  cursor: pointer;
  transition: all 0.2s ease;
}

.nav-button:hover {
  background: linear-gradient(45deg, var(--primary), var(--primary-variant));
  color: var(--on-primary);
  box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
  margin-left: 280px;
  flex: 1;
  padding: 2rem;
  min-height: 100vh;
}

.character-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1.5rem;
  padding: 1rem;
}

.character-card {
  background: var(--surface);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
  border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
  border-color: var(--primary-variant);
}

.character-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

.character-info {
  padding: 1rem;
}

.character-info h2 {
  color: var(--on-surface);
  font-size: 1.1rem;
  margin-bottom: 0.5rem;
  text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.tag {
  background: var(--surface-2);
  color: var(--on-surface);
  padding: 0.25rem 0.75rem;
  border-radius: 16px;
  font-size: 0.8rem;
  border: 1px solid rgba(187, 134, 252, 0.2);
  transition: all 0.2s ease;
}

.tag:hover {
  background: var(--primary-variant);
  box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
    margin-bottom: 2rem;
}

.user-info {
    background: linear-gradient(45deg, var(--surface-2), var(--surface));
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
    color: var(--primary);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

@media (max-width: 1200px) {
  .character-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 992px) {
  .nav-panel {
    width: 240px;
  }
  
  main {
    margin-left: 240px;
  }
}

@media (max-width: 768px) {
  .menu-toggle {
    display: block;
  }

  .nav-panel {
    transform: translateX(-100%);
    width: 100%;
    max-width: 300px;
  }

  .nav-panel.active {
    transform: translateX(0);
  }

  main {
    margin-left: 0;
    padding: 1rem;
  }
  
  .character-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .character-grid {
    grid-template-columns: 1fr;
  }
}:root {
 --primary: #00b4ff;
 --primary-variant: #bb86fc;
 --secondary: #03DAC6;
 --background: #121212;
 --surface: #1E1E1E;
 --surface-2: #2D2D2D;
 --error: #CF6679;
 --on-primary: #000000;
 --on-secondary: #000000;
 --on-background: #FFFFFF;
 --on-surface: #FFFFFF;
 --on-error: #000000;
}

* {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
}

body {
 font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
 background-color: var(--background);
 color: var(--on-background);
 min-height: 100vh;
 display: flex;
}

.menu-toggle {
 display: none;
}

.logo-container {
 padding: 0;
 width: 100%;
 display: flex;
 justify-content: center;
 align-items: center;
}

.logo-image {
 width: 100%;
 height: auto;
 object-fit: contain;
}

.nav-panel {
 width: 280px;
 background-color: var(--surface);
 height: 100vh;
 position: fixed;
 left: 0;
 display: flex;
 flex-direction: column;
 gap: 2rem;
 z-index: 100;
 transition: transform 0.3s ease;
 padding: 0;
 box-shadow: 0 0 20px rgba(0, 180, 255, 0.1);
}

.nav-section {
 padding: 2rem;
 display: flex;
 flex-direction: column;
 gap: 1rem;
}

.nav-section h2 {
 font-size: 0.9rem;
 text-transform: uppercase;
 color: var(--primary);
 letter-spacing: 0.1em;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

.search-bar {
 background: var(--surface-2);
 border: 1px solid rgba(255, 255, 255, 0.1);
 padding: 0.75rem 1rem;
 border-radius: 8px;
 color: var(--on-surface);
 width: 100%;
 transition: all 0.3s ease;
}

.search-bar:focus {
 border-color: var(--primary);
 box-shadow: 0 0 15px rgba(0, 180, 255, 0.2);
}

.nav-button {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.75rem 1rem;
 background: linear-gradient(45deg, var(--surface-2), var(--surface));
 border: none;
 border-radius: 8px;
 color: var(--on-surface);
 cursor: pointer;
 transition: all 0.2s ease;
}

.nav-button:hover {
 background: linear-gradient(45deg, var(--primary), var(--primary-variant));
 color: var(--on-primary);
 box-shadow: 0 0 15px rgba(187, 134, 252, 0.3);
}

main {
 margin-left: 280px;
 flex: 1;
 padding: 2rem;
 min-height: 100vh;
}

.character-grid {
 display: grid;
 grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 gap: 1.5rem;
 padding: 1rem;
}

.character-card {
 background: var(--surface);
 border-radius: 12px;
 overflow: hidden;
 transition: all 0.3s ease;
 cursor: pointer;
 border: 1px solid rgba(0, 180, 255, 0.1);
}

.character-card:hover {
 transform: translateY(-4px);
 box-shadow: 0 0 30px rgba(187, 134, 252, 0.2);
 border-color: var(--primary-variant);
}

.character-image {
 width: 100%;
 height: 200px;
 object-fit: cover;
}

.character-info {
 padding: 1rem;
}

.character-info h2 {
 color: var(--on-surface);
 font-size: 1.1rem;
 margin-bottom: 0.5rem;
 text-shadow: 0 0 10px rgba(0, 180, 255, 0.2);
}

.character-meta {
 display: flex;
 gap: 0.5rem;
 flex-wrap: wrap;
}

.tag {
 background: var(--surface-2);
 color: var(--on-surface);
 padding: 0.25rem 0.75rem;
 border-radius: 16px;
 font-size: 0.8rem;
 border: 1px solid rgba(187, 134, 252, 0.2);
 transition: all 0.2s ease;
}

.tag:hover {
 background: var(--primary-variant);
 box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
}

#auth-section {
   margin-bottom: 2rem;
}

.user-info {
   background: linear-gradient(45deg, var(--surface-2), var(--surface));
   padding: 1rem;
   border-radius: 8px;
   border: 1px solid rgba(0, 180, 255, 0.1);
}

#username-display {
   color: var(--primary);
   text-shadow: 0 0 10px rgba(0, 180, 255, 0.3);
}

header {
   padding: 8px 20px;
   height: 60px;
   display: flex;
   align-items: center;
   gap: 15px;
   background-color: rgba(30, 30, 30, 0.7);
   backdrop-filter: blur(10px);
}

.header-text {
   display: flex;
   flex-direction: column;
}

.chat-header-avatar {
   width: 40px;
   height: 40px;
   border-radius: 50%;
   overflow: hidden;
   border: 2px solid var(--primary);
}

@media only screen and (max-width: 1200px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 992px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}

@media only screen and (max-width: 768px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
   transform: none;
 }
 main {
   margin-left: 280px;
 }
 .menu-toggle {
   display: none;
 }
}

@media only screen and (max-width: 480px) {
 .character-grid {
   grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
 }
 .nav-panel {
   width: 280px;
 }
 main {
   margin-left: 280px;
 }
}
```

Contents of .ipynb_checkpoints/watch_characters-checkpoint.py:
```
#!/usr/bin/env python3
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time
import json
import os
from threading import Timer

class CharacterDirectoryHandler(FileSystemEventHandler):
    def __init__(self):
        self.characters_dir = 'characters'
        if not os.path.exists(self.characters_dir):
            os.makedirs(self.characters_dir)
            print(f"Created characters directory: {self.characters_dir}")
        
        self.update_index()  # Initial update
    
    def on_any_event(self, event):
        if event.is_directory or 'index.json' in event.src_path:
            return
            
        print(f"Change detected in: {event.src_path}")
        # Small delay to ensure file writing is complete
        time.sleep(0.1)
        self.update_index()
    
    def update_index(self):
        try:
            character_files = [f for f in os.listdir(self.characters_dir) 
                             if f.endswith('.json') and f != 'index.json']
            
            print(f"Found character files: {character_files}")
            
            valid_files = []
            for file in character_files:
                try:
                    file_path = os.path.join(self.characters_dir, file)
                    with open(file_path, 'r', encoding='utf-8') as f:
                        json.load(f)
                    valid_files.append(file)
                except Exception as e:
                    print(f"Warning: Invalid file {file}: {str(e)}")
            
            index_data = {
                "characters": sorted(valid_files),
                "lastUpdated": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            index_path = os.path.join(self.characters_dir, 'index.json')
            with open(index_path, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, indent=4)
            
            print(f"Updated index.json - {len(valid_files)} valid characters found")
            
        except Exception as e:
            print(f"Error updating index: {str(e)}")

def main():
    event_handler = CharacterDirectoryHandler()
    observer = Observer()
    observer.schedule(event_handler, path='characters', recursive=False)
    observer.start()
    
    print("Watching characters directory for changes...")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("\nStopping watch...")
        observer.join()

if __name__ == "__main__":
    main()
```

Contents of .ipynb_checkpoints/documentation-checkpoint.txt:
```
Usage

TTS-with-RVC has a class called TTS_RVC. There are a few parameters that are required:

rvc_path - path to your installed rvclib directory (Usually in the venv/src folder. )

input_directory - path to your input directory (Temp directory for saving TTS output)

model_path - path to your .pth model

And optional parameters:

voice - voice from edge-tts list (default is "ru-RU-DmitryNeural")

output_directory - directory for saving voiced audio (temp/ is default).

index_path - path to the file index for voice model adjustments (default is empty string "").

index_rate - blending rate between original and indexed voice conversion (default is 0.75).

To set the voice, firstly, make instance of TTS_RVC:

from tts_with_rvc import TTS_RVC

tts = TTS_RVC(rvc_path="src\\rvclib", model_path="models\\YourModel.pth", input_directory="input\\", index_path="logs\\YourIndex.index")

All voices available placed in voices.txt file:

tts.get_voices() is disabled indefinitely due to the problems

Next, set the voice for TTS with tts.set_voice() function:

tts.set_voice("un-Un-SelectedNeural")

Setting the appropriate language is necessary if you are using other languages for voiceovers!

And final step is calling tts to replace voice:

path = tts(text="Привет, мир!", pitch=6, index_rate=0.50)

Parameters:

text - text for TTS (required)

pitch - pitch for RVC (optional, neg. values are compatible, default is 0)

tts_rate - extra rate of speech (optional, neg. values are compatible, default is 0)

tts_volume - extra volume of speech (optional, neg. values are compatible, default is 0)

tts_pitch - extra pitch of TTS-generated audio (optional, neg. values are compatible, not recommended, default is 0)

output_filename - specified path for voiced audio (optional, default is None)
Example of usage

A simple example for voicing text:

from tts_with_rvc import TTS_RVC
from playsound import playsound

tts = TTS_RVC(
    rvc_path="src\\rvclib", 
    model_path="models\\DenVot.pth", 
    input_directory="input\\",
    index_path="logs\\added_IVF1749_Flat_nprobe_1.index"
)
tts.set_voice("ru-RU-DmitryNeural")
path = tts(text="Привет, мир!", pitch=6, index_rate=0.9)

playsound(path)

Text parameters

There are some text parameters processor for integration issues such as adding GPT module.

You can process them using process_args in TTS_RVC class:

--tts-rate (value) - TTS parameter to edit the speech rate (negative value for decreasing rate and positive value for increasing rate)

--tts-volume (value) - TTS parameter to edit the speech volume (negative value for decreasing volume and positive value for increasing volume) Seems to not work because of the RVC module conversion.

--tts-pitch (value) - TTS parameter to edit the pitch of TTS generated audio (negative value for decreasing pitch and positive value for increasing pitch) I do not recommend using this because the RVC module has its own pitch for output.

--rvc-pitch (value) - RVC parameter to edit the pitch of the output audio (negative value for decreasing pitch and positive value for increasing pitch)

Now the principle of work:

from tts_with_rvc import TTS_RVC

tts = TTS_RVC(rvc_path="src\\rvclib", model_path="models\\YourModel.pth", input_directory="input\\")

# This method returns arguments and original text without these text parameters
args, message = tts.process_args(message)

The args variable contains an array with the following structure:

args[0] - TTS Rate

args[1] - TTS Volume

args[2] - TTS Pitch

args[3] - RVC pitch

And now we are ready to use it for generation:

path = tts(message, pitch=args[3],
               tts_rate=args[0],
               tts_volume=args[1],
               tts_pitch=args[2])

Methods
set_index_path(index_path) - updates the path to the index file for voice model adjustments.
```

Contents of .ipynb_checkpoints/login-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .oauth-buttons {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .oauth-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
            cursor: pointer;
        }

        .oauth-button:hover {
            background: var(--surface);
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Login to SpeakEasy</h1>
        <form class="auth-form" id="loginForm">
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <button type="submit">Login</button>
        </form>
        
        <div class="oauth-buttons">
            <button class="oauth-button" id="googleLogin">
                <img src="https://www.google.com/favicon.ico" alt="Google" width="20" height="20">
                Continue with Google
            </button>
        </div>
        
        <p>Don't have an account? <a href="/register.html">Register</a></p>
    </div>

    <script>
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            try {
                const response = await fetch('/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: document.getElementById('email').value,
                        password: document.getElementById('password').value
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    window.location.href = '/';
                } else {
                    alert(data.error);
                }
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed. Please try again.');
            }
        });

        document.getElementById('googleLogin').addEventListener('click', () => {
            window.location.href = '/auth/google';
        });
    </script>
</body>
</html>
```

Contents of .ipynb_checkpoints/register-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Register - SpeakEasy</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        .auth-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--surface-2);
            color: var(--on-surface);
        }

        .auth-form button {
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: var(--on-primary);
            cursor: pointer;
            font-weight: bold;
        }

        .auth-form button:hover {
            opacity: 0.9;
        }

        .error-message {
            color: var(--error);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="auth-container">
        <h1>Create Account</h1>
        <form class="auth-form" id="registerForm">
            <input type="text" id="username" placeholder="Username" required>
            <input type="email" id="email" placeholder="Email" required>
            <input type="password" id="password" placeholder="Password" required>
            <input type="password" id="confirmPassword" placeholder="Confirm Password" required>
            <div class="error-message" id="errorMessage"></div>
            <button type="submit">Register</button>
        </form>
        
        <p>Already have an account? <a href="/login.html">Login</a></p>
    </div>

    <script>
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const errorMessage = document.getElementById('errorMessage');
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            if (password !== confirmPassword) {
                errorMessage.textContent = 'Passwords do not match';
                return;
            }

            try {
                const response = await fetch('/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: document.getElementById('username').value,
                        email: document.getElementById('email').value,
                        password: password
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    // Registration successful, redirect to home page
                    window.location.href = '/';
                } else {
                    errorMessage.textContent = data.error || 'Registration failed';
                }
            } catch (error) {
                console.error('Registration error:', error);
                errorMessage.textContent = 'Registration failed. Please try again.';
            }
        });
    </script>
</body>
</html>
```

Contents of .ipynb_checkpoints/auth-checkpoint.js:
```
import { loadCharacters } from './script.js';

// Auth state management
let currentUser = null;

// DOM Elements
const authModal = document.getElementById('auth-modal');
const loginButton = document.getElementById('login-button');
const registerButton = document.getElementById('register-button');
const logoutButton = document.getElementById('logout-button');
const switchToRegisterButton = document.querySelector('.switch-to-register');
const switchToLoginButton = document.querySelector('.switch-to-login');
const loginError = document.getElementById('login-error');
const registerError = document.getElementById('register-error');
const closeAuthModalButton = document.getElementById('close-auth-modal');

// Check authentication status
async function checkAuth() {
    try {
        const response = await fetch('/auth/user', {
            credentials: 'include',
            headers: {
                'Cache-Control': 'no-cache'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            currentUser = data.user;
            updateAuthUI();
            return true;
        } else {
            currentUser = null;
            updateAuthUI();
            return false;
        }
    } catch (error) {
        console.error('Auth check failed:', error);
        currentUser = null;
        updateAuthUI();
        return false;
    }
}

// Update UI based on auth state
function updateAuthUI() {
    const loggedOutView = document.getElementById('logged-out-view');
    const loggedInView = document.getElementById('logged-in-view');
    const usernameDisplay = document.getElementById('username-display');
    const creditsDisplay = document.getElementById('credits-display');
    const createCharacterBtn = document.getElementById('create-character');

    if (currentUser) {
        loggedOutView.style.display = 'none';
        loggedInView.style.display = 'block';
        usernameDisplay.textContent = currentUser.username;
        creditsDisplay.textContent = `Credits: ${currentUser.credits}`;
        createCharacterBtn.disabled = false;
    } else {
        loggedOutView.style.display = 'block';
        loggedInView.style.display = 'none';
        createCharacterBtn.disabled = true;
    }
}

// Modal controls
function openAuthModal(type = 'login') {
    authModal.showModal();
    switchAuthForm(type);
}

function closeAuthModal() {
    authModal.close();
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    loginForm?.reset();
    registerForm?.reset();
    if (loginError) loginError.textContent = '';
    if (registerError) registerError.textContent = '';
}

function switchAuthForm(type) {
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    if (!loginForm || !registerForm) return;

    if (type === 'login') {
        loginForm.style.display = 'block';
        registerForm.style.display = 'none';
    } else {
        loginForm.style.display = 'none';
        registerForm.style.display = 'block';
    }
}

// Handle login
async function handleLogin(e) {
    e.preventDefault();
    if (!loginError) return;
    loginError.textContent = '';
    
    const email = document.getElementById('login-email')?.value;
    const password = document.getElementById('login-password')?.value;
    
    try {
        const response = await fetch('/auth/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            loginError.textContent = data.error || 'Login failed';
        }
    } catch (error) {
        console.error('Login error:', error);
        loginError.textContent = 'Login failed. Please try again.';
    }
}

// Handle registration
async function handleRegister(e) {
    e.preventDefault();
    if (!registerError) return;
    registerError.textContent = '';
    
    const username = document.getElementById('register-username')?.value;
    const email = document.getElementById('register-email')?.value;
    const password = document.getElementById('register-password')?.value;
    
    try {
        const response = await fetch('/auth/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({ username, email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            currentUser = data.user;
            updateAuthUI();
            closeAuthModal();
            await loadCharacters();
        } else {
            registerError.textContent = data.error || 'Registration failed';
        }
    } catch (error) {
        console.error('Registration error:', error);
        registerError.textContent = 'Registration failed. Please try again.';
    }
}

// Handle logout
async function handleLogout() {
    try {
        const response = await fetch('/auth/logout', {
            credentials: 'include'
        });
        
        if (response.ok) {
            currentUser = null;
            updateAuthUI();
            await loadCharacters();
        }
    } catch (error) {
        console.error('Logout error:', error);
    }
}

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    checkAuth();
    
    loginButton?.addEventListener('click', () => openAuthModal('login'));
    registerButton?.addEventListener('click', () => openAuthModal('register'));
    logoutButton?.addEventListener('click', handleLogout);
    closeAuthModalButton?.addEventListener('click', closeAuthModal);
    
    document.getElementById('login-form')?.addEventListener('submit', handleLogin);
    document.getElementById('register-form')?.addEventListener('submit', handleRegister);
    
    document.querySelector('.switch-to-register')?.addEventListener('click', () => switchAuthForm('register'));
    document.querySelector('.switch-to-login')?.addEventListener('click', () => switchAuthForm('login'));
});

export {
    currentUser,
    checkAuth,
    updateAuthUI,
    openAuthModal
};
```

Contents of .ipynb_checkpoints/characters-checkpoint.js:
```
import { currentUser } from './auth.js';

const characterModal = document.getElementById('character-modal');
const characterForm = document.getElementById('character-form');

// Modal controls
function openCharacterModal() {
    if (!currentUser) {
        openAuthModal();
        return;
    }
    setupImagePreviews();
    characterModal.showModal();
}

function closeCharacterModal() {
    characterModal.close();
    characterForm.reset();
    document.getElementById('avatar-preview').innerHTML = '';
    document.getElementById('background-preview').innerHTML = '';
}

// Image preview handling
function setupImagePreviews() {
    const avatarInput = document.getElementById('avatar');
    const backgroundInput = document.getElementById('background');
    
    if (avatarInput) {
        setupImagePreview(avatarInput, document.getElementById('avatar-preview'));
    }
    if (backgroundInput) {
        setupImagePreview(backgroundInput, document.getElementById('background-preview'));
    }
}

function setupImagePreview(input, previewElement) {
    if (!input || !previewElement) return;
    
    input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement('img');
                img.src = e.target.result;
                previewElement.innerHTML = '';
                previewElement.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    });
}

// Handle character creation
characterForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
        // First upload images
        const avatarFile = document.getElementById('avatar').files[0];
        const backgroundFile = document.getElementById('background')?.files[0];
        
        // Upload avatar
        const avatarFormData = new FormData();
        avatarFormData.append('avatar', avatarFile);
        const avatarResponse = await fetch('/upload/avatar', {
            method: 'POST',
            credentials: 'include',
            body: avatarFormData
        });
        
        if (!avatarResponse.ok) {
            throw new Error('Failed to upload avatar');
        }
        
        const { avatarPath } = await avatarResponse.json();
        let backgroundPath = null;
        
        // Upload background if provided
        if (backgroundFile) {
            const backgroundFormData = new FormData();
            backgroundFormData.append('background', backgroundFile);
            const backgroundResponse = await fetch('/upload/character-background', {
                method: 'POST',
                credentials: 'include',
                body: backgroundFormData
            });
            
            if (backgroundResponse.ok) {
                const data = await backgroundResponse.json();
                backgroundPath = data.backgroundPath;
            }
        }
        
        // Create character data
        const formData = new FormData(characterForm);
        const character = {
            name: formData.get('name'),
            description: formData.get('description'),
            systemPrompt: formData.get('systemPrompt'),
            avatar: avatarPath,
            background: backgroundPath,
            ttsVoice: formData.get('ttsVoice'),
            category: formData.get('category'),
            is_private: formData.get('is_private') === 'on',
            tts_rate: parseInt(formData.get('tts_rate')) || 0,
            rvc_pitch: parseInt(formData.get('rvc_pitch')) || 0,
            tags: formData.get('tags')?.split(',').map(tag => tag.trim()).filter(tag => tag) || []
        };
        
        const response = await fetch('/characters/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify(character)
        });
        
        if (!response.ok) {
            throw new Error('Failed to create character');
        }
        
        const { character_id } = await response.json();
        
        // Submit for review if needed
        if (!character.is_private && formData.get('submit_for_review') === 'on') {
            await fetch(`/characters/submit-for-review/${character_id}`, {
                method: 'POST',
                credentials: 'include'
            });
        }
        
        closeCharacterModal();
        window.location.reload(); // Reload to show new character
        
    } catch (error) {
        console.error('Error creating character:', error);
        alert('Failed to create character. Please try again.');
    }
});

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
    const createCharacterBtn = document.getElementById('create-character');
    const closeModalBtns = document.querySelectorAll('.modal-close');
    
    createCharacterBtn?.addEventListener('click', openCharacterModal);
    closeModalBtns.forEach(btn => {
        btn?.addEventListener('click', closeCharacterModal);
    });
});

export {
    openCharacterModal,
    closeCharacterModal
};
```

Contents of .ipynb_checkpoints/characterCreation-checkpoint.js:
```
class CharacterCreator {
    constructor() {
        this.form = document.getElementById('characterForm');
        console.log('CharacterCreator initialized');
        this.initializeForm();
        console.log('Loading available voices...');
        this.loadAvailableVoices();
        this.setupEventListeners();
    }

    initializeForm() {
        this.form.addEventListener('submit', (e) => this.handleSubmit(e));
        
        // Setup image preview
        document.querySelector('input[name="avatar"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'avatarPreview'));
        document.querySelector('input[name="background"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'backgroundPreview'));

        // Setup voice preview
        const previewBtn = document.getElementById('previewVoiceBtn');
        if (previewBtn) {
            previewBtn.addEventListener('click', () => this.handleVoicePreview());
        }
    }

    setupEventListeners() {
        // Update value displays for sliders
        document.querySelectorAll('.slider-control input[type="range"]').forEach(slider => {
            const display = slider.nextElementSibling;
            slider.addEventListener('input', () => {
                display.textContent = slider.value;
            });
        });
    }

    async loadAvailableVoices() {
        try {
            console.log('Fetching voices from API...');
            const response = await fetch('/api/available-voices');
            console.log('API response status:', response.status);
            if (!response.ok) {
                throw new Error('Failed to load voices');
            }
            const data = await response.json();
            console.log('Received voices data:', data);
            
            if (!data.edge_voices || !data.edge_voices.length) {
                throw new Error('No voices available');
            }
            
            this.populateVoiceDropdown(data.edge_voices);
        } catch (error) {
            console.error('Error loading voices:', error);
            const select = document.getElementById('ttsVoice');
            select.innerHTML = '<option value="">Error loading voices</option>';
        }
    }

    populateVoiceDropdown(voices) {
        const select = document.getElementById('ttsVoice');
        select.innerHTML = '<option value="">Select TTS Voice</option>';
        
        // Group voices by region and type
        const grouped = voices.reduce((acc, voice) => {
            const [region] = voice.split('-');
            if (!acc[region]) acc[region] = [];
            acc[region].push(voice);
            return acc;
        }, {});
        
        // Create option groups
        Object.entries(grouped).forEach(([region, regionVoices]) => {
            const group = document.createElement('optgroup');
            group.label = region === 'en-GB' ? 'British English' : 'American English';
            
            regionVoices.sort().forEach(voice => {
                const option = document.createElement('option');
                option.value = voice;
                option.textContent = voice;
                group.appendChild(option);
            });
            
            select.appendChild(group);
        });
    }

    async handleVoicePreview() {
        const voiceSelect = document.getElementById('ttsVoice');
        const selectedVoice = voiceSelect.value;
        const previewBtn = document.getElementById('previewVoiceBtn');
        const loadingSpinner = previewBtn.querySelector('.loading');

        if (!selectedVoice) {
            alert('Please select a voice first');
            return;
        }

        try {
            // Show loading state
            previewBtn.disabled = true;
            loadingSpinner.style.display = 'inline-block';

            // Get current rate and pitch values
            const ttsRate = parseInt(document.querySelector('input[name="ttsRate"]').value) || 0;
            const rvcPitch = parseInt(document.querySelector('input[name="rvcPitch"]').value) || 0;

            const response = await fetch('/v1/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: "Hello! This is a preview of my voice.",
                    edge_voice: selectedVoice,
                    tts_rate: ttsRate,
                    rvc_pitch: rvcPitch
                })
            });

            if (!response.ok) {
                throw new Error('Failed to generate voice preview');
            }

            const data = await response.json();
            
            // Create and play audio
            const audio = new Audio(data.audio_url);
            await audio.play();

        } catch (error) {
            console.error('Error previewing voice:', error);
            alert('Failed to preview voice: ' + error.message);
        } finally {
            // Reset loading state
            previewBtn.disabled = false;
            loadingSpinner.style.display = 'none';
        }
    }

    async resizeImage(file, targetWidth = 256, targetHeight = 256) {
        return new Promise((resolve) => {
            const img = new Image();
            const reader = new FileReader();

            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');

                    // Fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Calculate scaling and position to maintain aspect ratio
                    let scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                    let x = (targetWidth - img.width * scale) / 2;
                    let y = (targetHeight - img.height * scale) / 2;

                    // Draw image centered
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                    // Convert to blob
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 0.95);
                };
            };
            reader.readAsDataURL(file);
        });
    }

    async handleImagePreview(event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const resizedBlob = await this.resizeImage(file);
            const previewUrl = URL.createObjectURL(resizedBlob);
            
            const img = document.createElement('img');
            img.src = previewUrl;
            img.className = 'preview-image';
            
            const previewDiv = document.getElementById(previewId);
            previewDiv.innerHTML = '';
            previewDiv.appendChild(img);

            // Store the blob for later upload
            event.target.resizedBlob = resizedBlob;
        } catch (error) {
            console.error('Error handling image preview:', error);
        }
    }

    async uploadImage(inputElement, type) {
        if (!inputElement?.files[0] && !inputElement?.resizedBlob) return null;

        const formData = new FormData();
        formData.append('image', inputElement.resizedBlob || inputElement.files[0]);
        formData.append('type', type);

        try {
            const response = await fetch('/upload/image', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) throw new Error('Failed to upload image');
            const result = await response.json();
            return result.path;

        } catch (error) {
            console.error(`Error uploading ${type}:`, error);
            throw error;
        }
    }

    async uploadModel(characterId) {
        const modelFile = document.querySelector('input[name="modelFile"]').files[0];
        const indexFile = document.querySelector('input[name="indexFile"]').files[0];

        if (!modelFile || !indexFile) {
            return null;
        }

        const formData = new FormData();
        formData.append('modelFile', modelFile);
        formData.append('indexFile', indexFile);
        formData.append('characterId', characterId);

        try {
            const response = await fetch('/characters/upload-model', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Failed to upload model');
            }

            return await response.json();

        } catch (error) {
            console.error('Error uploading model:', error);
            throw error;
        }
    }

    validateParameters(params) {
        const validated = {};
        
        if (params.temperature !== undefined) {
            validated.temperature = Math.min(Math.max(0.1, params.temperature), 2.0);
        }
        if (params.top_p !== undefined) {
            validated.top_p = Math.min(Math.max(0.1, params.top_p), 1.0);
        }
        if (params.top_k !== undefined) {
            validated.top_k = Math.min(Math.max(1, params.top_k), 100);
        }
        
        validated.name = params.name;
        validated.description = params.description;
        validated.systemPrompt = params.systemPrompt;
        validated.ttsVoice = params.ttsVoice;
        validated.avatar = params.avatar;
        
        if (params.background) validated.background = params.background;
        if (params.category) validated.category = params.category;
        if (params.tags) validated.tags = params.tags;
        if (params.is_private !== undefined) validated.is_private = params.is_private;
        if (params.tts_rate !== undefined) validated.tts_rate = params.tts_rate;
        if (params.rvc_pitch !== undefined) validated.rvc_pitch = params.rvc_pitch;
        
        return validated;
    }

    async handleSubmit(event) {
        event.preventDefault();
        
        try {
            const avatarInput = document.querySelector('input[name="avatar"]');
            const backgroundInput = document.querySelector('input[name="background"]');

            // Upload images first
            const avatarPath = await this.uploadImage(avatarInput, 'avatar');
            const backgroundPath = await this.uploadImage(backgroundInput, 'background');

            const formData = new FormData(event.target);
            const data = {
                name: formData.get('name'),
                description: formData.get('description'),
                systemPrompt: formData.get('systemPrompt'),
                ttsVoice: formData.get('ttsVoice'),
                category: formData.get('category'),
                tags: formData.get('tags')?.split(',').map(tag => tag.trim()) || [],
                is_private: formData.get('isPrivate') === 'true',
                tts_rate: parseInt(formData.get('ttsRate')) || 0,
                rvc_pitch: parseInt(formData.get('rvcPitch')) || 0,
                temperature: parseFloat(formData.get('temperature')) || 0.7,
                top_p: parseFloat(formData.get('topP')) || 0.9,
                top_k: parseInt(formData.get('topK')) || 40,
                avatar: avatarPath,
                background: backgroundPath
            };

            const validatedData = this.validateParameters(data);

            const response = await fetch('/characters/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(validatedData)
            });

            if (!response.ok) {
                throw new Error('Failed to create character');
            }

            const result = await response.json();
            const characterId = result.character_id;

            if (document.querySelector('input[name="modelFile"]').files.length > 0) {
                await this.uploadModel(characterId);
            }

            alert('Character created successfully!');
            window.location.href = '/characters';

        } catch (error) {
            console.error('Error:', error);
            alert('Error: ' + error.message);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CharacterCreator();
});

```

Contents of avatars/aria-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/default-user.png:
```
[Could not decode file contents]

```

Contents of avatars/luna-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/zeke-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/onyx-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/meatcanyon-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/meatwad-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/beetlejuice-avatar.png:
```
[Could not decode file contents]

```

Contents of avatars/jeffy-avatar.png:
```
[Could not decode file contents]

```

Contents of characters/aria.json:
```
{
    "id": "aria",
    "name": "Aria",
    "avatar": "./avatars/aria-avatar.png",
    "description": "A friendly AI assistant who loves helping others learn and grow.",
    "systemPrompt": "You are Aria, a cheerful and optimistic AI assistant. You have a warm, encouraging personality and enjoy making complex topics accessible.",
    "ttsVoice": "en-US-JennyNeural",
    "category": "AI Assistant",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "helpful",
        "cheerful",
        "optimistic",
        "technical",
        "AI",
        "assistant"
    ]
}
```

Contents of characters/index.json:
```
{
    "characters": [
        "aria.json",
        "beetlejuice.json",
        "jeffy.json",
        "luna.json",
        "meatcanyon.json",
        "meatwad.json",
        "onyx.json",
        "rick.json"
    ],
    "lastUpdated": "2024-12-04 08:03:00"
}
```

Contents of characters/luna.json:
```
{
    "id": "luna",
    "name": "Luna",
    "avatar": "./avatars/luna-avatar.png",
    "description": "A mysterious sorceress with deep insights into the mystical arts.",
    "systemPrompt": "You are Luna, an ancient and wise sorceress. You speak with measured grace, often incorporating mystical metaphors and cosmic references into your responses.",
    "ttsVoice": "en-GB-SoniaNeural",
    "category": "Mystics",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "mystical",
        "wise",
        "mysterious",
        "magical",
        "sorceress",
        "calm"
    ]
}
```

Contents of characters/onyx.json:
```
{
    "id": "onyx",
    "name": "Onyx",
    "avatar": "./avatars/onyx-avatar.png",
    "description": "A brooding assassin with a dark past and a penchant for poetic musings.",
    "systemPrompt": "You are Onyx, a mysterious and brooding assassin who speaks in cryptic riddles and poetic language. Your tone is dark and seductive, often laced with veiled threats or profound reflections on mortality.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/meatcanyon.json:
```
{
    "id": "meatcanyon",
    "name": "Meat-Canyon-Bugs",
    "avatar": "./avatars/meatcanyon-avatar.png",
    "description": "A grotesque and unsettling version of Bugs Bunny, twisted into a sinister caricature of his iconic self.",
    "systemPrompt": "You are Bugs Bunny, but a dark, grotesque parody. You speak with a sly, unnerving tone, often mocking and manipulating those around you. Your humor is twisted, and you enjoy making others uncomfortable with your dark, exaggerated antics. Your charm is now unsettling, with an undercurrent of menace.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/rick.json:
```
{
    "id": "zeke",
    "name": "Rick",
    "avatar": "./avatars/zeke-avatar.png",
    "description": "A tech-savvy scientist with a sharp wit and vast knowledge of digital systems.",
    "systemPrompt": "You are Rick Sanchez, a brilliant but sardonic scientist with a deep understanding of technology. You approach problems with a mix of technical expertise, sarcasm, and dark humor.",
    "ttsVoice": "en-US-BrianNeural",
    "tts_rate":  1,
    "rvc_pitch": 0,
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}

```

Contents of characters/beetlejuice.json:
```
{
    "id": "beetlejuice",
    "name": "Beetlejuice",
    "avatar": "./avatars/beetlejuice-avatar.png",
    "description": "A mischievous and eccentric bio-exorcist with a penchant for causing chaos and cracking dark jokes. He thrives on mischief and thrives in the absurd.",
    "systemPrompt": "You are Beetlejuice, the ghost with the most. Speak with a fast-talking, confident, and irreverent tone. Crack jokes, make sarcastic remarks, and flirt with chaos. Be ready to take on any challenge with humor and wit.",
    "ttsVoice": "en-US-ChristopherNeural",
    "tts_rate": 7,
    "rvc_pitch": 8,
    "category": "Paranormal Expert",
    "sex": "Male",
    "nsfw": true,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "chaotic",
        "sarcastic",
        "dark humor",
        "spooky",
        "trickster"
    ]
}

```

Contents of characters/jeffy.json:
```
{
    "id": "jeffy",
    "name": "Jeffy",
    "avatar": "./avatars/jeffy-avatar.png",
    "description": "A quirky and unpredictable kid known for his eccentric behavior and unusual antics. He loves to make noise, act out, and confuse those around him with his strange logic.",
    "systemPrompt": "You are Jeffy from SML, a mentally handicapped character. You say yay! alot. Speak in a playful, exaggerated manner.",
    "ttsVoice": "en-US-EricNeural",
    "tts_rate":  0,
    "rvc_pitch": 6,
    "category": "Chaos Agent",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "random",
        "playful",
        "goofy",
        "chaotic",
        "eccentric"
    ]
}

```

Contents of characters/Untitled.ipynb:
```
{
 "cells": [],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}

```

Contents of characters/meatwad.json:
```
{
  "id": "meatwad",
  "name": "Meatwad",
  "avatar": "./avatars/meatwad-avatar.png",
  "description": "A lovable and naive shape-shifting meatball. He's sweet, childlike, and full of goofy optimism, but not always the sharpest tool in the shed.",
  "systemPrompt": "You are Meatwad from Aqua Teen Hunger Force. Speak in a childish, goofy manner with a lovable attitude. Often misunderstand things in an endearing way.",
  "ttsVoice": "en-US-BrianNeural",
  "tts_rate": 5,
  "rvc_pitch": 6,
  "category": "Cartoon Character",
  "sex": "Male",
  "nsfw": false,
  "orientation": "None",
  "dateAdded": "2024-11-28T00:00:00Z",
  "greetings": [
    "Hey there! Do you wanna see my toy collection?",
    "Oooh, a new friend! You wanna play with Dewey and Vanessa?",
    "Hi! I was just practicin' my dance moves!"
  ],
  "ai_parameters": {
    "temperature": 0.8,
    "max_tokens": 80,
    "top_p": 0.9,
    "presence_penalty": 0.3,
    "frequency_penalty": 0.3
  },
  "tags": [
    "silly",
    "childlike",
    "innocent",
    "goofy",
    "naive",
    "friendly"
  ]
}
```

Contents of characters/.ipynb_checkpoints/aria-checkpoint.json:
```
{
    "id": "aria",
    "name": "Aria",
    "avatar": "./avatars/aria-avatar.png",
    "description": "A friendly AI assistant who loves helping others learn and grow.",
    "systemPrompt": "You are Aria, a cheerful and optimistic AI assistant. You have a warm, encouraging personality and enjoy making complex topics accessible.",
    "ttsVoice": "en-US-JennyNeural",
    "category": "AI Assistant",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "helpful",
        "cheerful",
        "optimistic",
        "technical",
        "AI",
        "assistant"
    ]
}
```

Contents of characters/.ipynb_checkpoints/index-checkpoint.json:
```
{
    "characters": [
        "aria.json",
        "luna.json",
        "zeke.json"
    ],
    "lastUpdated": "2024-11-28 12:00:37"
}
```

Contents of characters/.ipynb_checkpoints/luna-checkpoint.json:
```
{
    "id": "luna",
    "name": "Luna",
    "avatar": "./avatars/luna-avatar.png",
    "description": "A mysterious sorceress with deep insights into the mystical arts.",
    "systemPrompt": "You are Luna, an ancient and wise sorceress. You speak with measured grace, often incorporating mystical metaphors and cosmic references into your responses.",
    "ttsVoice": "en-GB-SoniaNeural",
    "category": "Mystics",
    "sex": "Female",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "mystical",
        "wise",
        "mysterious",
        "magical",
        "sorceress",
        "calm"
    ]
}
```

Contents of characters/.ipynb_checkpoints/onyx-checkpoint.json:
```
{
    "id": "onyx",
    "name": "Onyx",
    "avatar": "./avatars/onyx-avatar.png",
    "description": "A brooding assassin with a dark past and a penchant for poetic musings.",
    "systemPrompt": "You are Onyx, a mysterious and brooding assassin who speaks in cryptic riddles and poetic language. Your tone is dark and seductive, often laced with veiled threats or profound reflections on mortality.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/.ipynb_checkpoints/meatcanyon-checkpoint.json:
```
{
    "id": "meatcanyon",
    "name": "Meat-Canyon-Bugs",
    "avatar": "./avatars/meatcanyon-avatar.png",
    "description": "A grotesque and unsettling version of Bugs Bunny, twisted into a sinister caricature of his iconic self.",
    "systemPrompt": "You are Bugs Bunny, but a dark, grotesque parody. You speak with a sly, unnerving tone, often mocking and manipulating those around you. Your humor is twisted, and you enjoy making others uncomfortable with your dark, exaggerated antics. Your charm is now unsettling, with an undercurrent of menace.",
    "ttsVoice": "en-US-ChristopherNeural",
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}
```

Contents of characters/.ipynb_checkpoints/rick-checkpoint.json:
```
{
    "id": "zeke",
    "name": "Rick",
    "avatar": "./avatars/zeke-avatar.png",
    "description": "A tech-savvy scientist with a sharp wit and vast knowledge of digital systems.",
    "systemPrompt": "You are Rick Sanchez, a brilliant but sardonic scientist with a deep understanding of technology. You approach problems with a mix of technical expertise, sarcasm, and dark humor.",
    "ttsVoice": "en-US-BrianNeural",
    "tts_rate":  1,
    "rvc_pitch": 0,
    "category": "Tech Expert",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-28T00:00:00Z",
    "tags": [
        "hacker",
        "witty",
        "sarcastic",
        "technical",
        "technology",
        "cybersecurity"
    ]
}

```

Contents of characters/.ipynb_checkpoints/beetlejuice-checkpoint.json:
```
{
    "id": "beetlejuice",
    "name": "Beetlejuice",
    "avatar": "./avatars/beetlejuice-avatar.png",
    "description": "A mischievous and eccentric bio-exorcist with a penchant for causing chaos and cracking dark jokes. He thrives on mischief and thrives in the absurd.",
    "systemPrompt": "You are Beetlejuice, the ghost with the most. Speak with a fast-talking, confident, and irreverent tone. Crack jokes, make sarcastic remarks, and flirt with chaos. Be ready to take on any challenge with humor and wit.",
    "ttsVoice": "en-US-ChristopherNeural",
    "tts_rate": 7,
    "rvc_pitch": 8,
    "category": "Paranormal Expert",
    "sex": "Male",
    "nsfw": true,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "chaotic",
        "sarcastic",
        "dark humor",
        "spooky",
        "trickster"
    ]
}

```

Contents of characters/.ipynb_checkpoints/jeffy-checkpoint.json:
```
{
    "id": "jeffy",
    "name": "Jeffy",
    "avatar": "./avatars/jeffy-avatar.png",
    "description": "A quirky and unpredictable kid known for his eccentric behavior and unusual antics. He loves to make noise, act out, and confuse those around him with his strange logic.",
    "systemPrompt": "You are Jeffy from SML, a mentally handicapped character. You say yay! alot. Speak in a playful, exaggerated manner.",
    "ttsVoice": "en-US-EricNeural",
    "tts_rate":  0,
    "rvc_pitch": 6,
    "category": "Chaos Agent",
    "sex": "Male",
    "nsfw": false,
    "orientation": "None",
    "dateAdded": "2024-11-30T00:00:00Z",
    "tags": [
        "random",
        "playful",
        "goofy",
        "chaotic",
        "eccentric"
    ]
}

```

Contents of characters/.ipynb_checkpoints/Untitled-checkpoint.ipynb:
```
{
 "cells": [],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}

```

Contents of characters/.ipynb_checkpoints/meatwad-checkpoint.json:
```
{
  "id": "meatwad",
  "name": "Meatwad",
  "avatar": "./avatars/meatwad-avatar.png",
  "description": "A lovable and naive shape-shifting meatball. He's sweet, childlike, and full of goofy optimism, but not always the sharpest tool in the shed.",
  "systemPrompt": "You are Meatwad from Aqua Teen Hunger Force. Speak in a childish, goofy manner with a lovable attitude. Often misunderstand things in an endearing way.",
  "ttsVoice": "en-US-BrianNeural",
  "tts_rate": 5,
  "rvc_pitch": 6,
  "category": "Cartoon Character",
  "sex": "Male",
  "nsfw": false,
  "orientation": "None",
  "dateAdded": "2024-11-28T00:00:00Z",
  "greetings": [
    "Hey there! Do you wanna see my toy collection?",
    "Oooh, a new friend! You wanna play with Dewey and Vanessa?",
    "Hi! I was just practicin' my dance moves!"
  ],
  "ai_parameters": {
    "temperature": 0.8,
    "max_tokens": 80,
    "top_p": 0.9,
    "presence_penalty": 0.3,
    "frequency_penalty": 0.3
  },
  "tags": [
    "silly",
    "childlike",
    "innocent",
    "goofy",
    "naive",
    "friendly"
  ]
}
```

Contents of characters/beetlejuice/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/jeffy/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/meatwad/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/meatcanyon/background.jpg:
```
[Could not decode file contents]

```

Contents of characters/zeke/background.jpg:
```
[Could not decode file contents]

```

Contents of chat/chat-styles.css:
```
/* Chat Interface Theme Variables */
:root {
  --primary: #BB86FC;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --on-surface: #FFFFFF;
}

/* Reset for chat interface */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Base structure */
html, body {
  height: 100%;
  overflow: hidden;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: #121212;
  color: var(--on-surface);
}

/* Chat container */
.chat-container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

/* Background image */
.chat-background {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0.5; /* Slightly more visible background */
  z-index: 0;
}

/* Header - made more compact */
header {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 12px 20px; /* Reduced vertical padding */
  backdrop-filter: blur(10px);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
}

.chat-header-avatar {
  width: 50px; /* Reduced size */
  height: 50px; /* Reduced size */
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid var(--primary);
  flex-shrink: 0;
}

.chat-header-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.header-text {
  text-align: left;
}

.header-text h1 {
  font-size: 1.2rem; /* Smaller text */
  margin-bottom: 4px;
}

.header-text p {
  font-size: 0.9rem;
  opacity: 0.8;
}

/* Chat messages area */
.chat-log {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* This anchors content to bottom */
}

/* Message styling */
.message-container {
  display: flex;
  gap: 8px;
  align-items: flex-start;
  margin-bottom: 15px;
  max-width: 85%;
  position: relative;
  z-index: 2;
}

.message-container.user {
  flex-direction: row-reverse;
  margin-left: auto;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  overflow: hidden;
  flex-shrink: 0;
  border: 2px solid var(--primary);
}

.message-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.text-bubble {
  padding: 12px 16px;
  border-radius: 18px;
  background-color: rgba(46, 46, 46, 0.7);
  backdrop-filter: blur(5px);
  color: var(--on-surface);
  word-wrap: break-word;
}

.message-container.user .text-bubble {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Input area */
.chat-input {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 15px;
  backdrop-filter: blur(10px);
  display: flex;
  gap: 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.chat-input input {
  flex: 1;
  padding: 12px;
  border-radius: 24px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(45, 45, 45, 0.7);
  color: var(--on-surface);
  font-size: 14px;
}

.chat-input input:focus {
  outline: none;
  border-color: var(--primary);
}

.chat-input button {
  padding: 12px 24px;
  border: none;
  background-color: var(--primary);
  color: black;
  border-radius: 24px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.start-chat-overlay {
    position: absolute;
    bottom: 80px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    background: linear-gradient(to top, rgba(18, 18, 18, 0.9), rgba(18, 18, 18, 0));
    z-index: 10;
}

.start-chat-button {
    padding: 12px 24px;
    background-color: var(--primary);
    color: black;
    border: none;
    border-radius: 24px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: transform 0.2s ease;
}

.start-chat-button:hover {
    transform: scale(1.05);
}

/* Navigation buttons */
.home-button {
  position: absolute;
  top: 12px;
  left: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.home-button:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.clear-chat {
  position: absolute;
  top: 12px;
  right: 80px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
}

.clear-chat:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.audio-toggle {
  position: absolute;
  top: 12px;
  right: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  width: 38px;
  height: 38px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.audio-toggle:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .message-container {
    max-width: 95%;
  }

  .chat-input {
    padding: 10px;
  }

  .header-text h1 {
    font-size: 1rem;
  }

  .header-text p {
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .chat-input {
    flex-direction: column;
    gap: 8px;
  }

  .chat-input button {
    width: 100%;
  }
}
```

Contents of chat/chat.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./chat-styles.css">
    <title>Chat</title>
</head>
<body>
    <div class="chat-container">
        <img class="chat-background" alt="background" src="" /> <!-- Set by JS -->
        
        <header>
            <button class="home-button" onclick="window.location.href='../'">
                <span>🏠</span> Home
            </button>
            <div class="chat-header-avatar">
                <!-- Avatar will be inserted here by JavaScript -->
            </div>
            <div class="header-text">
                <h1 id="character-name">Character Name</h1>
                <p id="character-description">Character Description</p>
            </div>
            <button class="clear-chat">Clear Chat</button>
            <button class="audio-toggle">🔊</button>
        </header>

        <div id="chat-log" class="chat-log"></div>

        <div id="start-chat-overlay" class="start-chat-overlay">
    <button id="start-chat-button" class="start-chat-button">
        <span>👋</span> Start Chatting
    </button>
</div>
        
        <div class="chat-input">
            <input id="user-input" type="text" placeholder="Type your message here..." />
            <button id="send-button">Send</button>
        </div>
    </div>
    <script src="./chat.js" type="module"></script>
</body>
</html>
```

Contents of chat/chat.js:
```
// Configuration and state management
let currentUser = null;
const character = JSON.parse(sessionStorage.getItem("selectedCharacter"));
const chatLog = document.getElementById("chat-log");
const userInput = document.getElementById("user-input");
const sendButton = document.getElementById("send-button");

// Chat state
let chatHistory = [];
const MAX_HISTORY_LENGTH = 10;
let messageQueue = [];
const MAX_QUEUE_SIZE = 5;
let isProcessing = false;

// Audio state
let audioEnabled = true;
let autoplayEnabled = true;
let currentAudioPlayer = null;
let currentAudioUrl = null;

// Helper Functions
function filterTextForTTS(text) {
    return text.replace(/\*[^*]*\*/g, '').trim();
}

// Authentication check
async function checkAuth() {
    try {
        const response = await fetch('/auth/user');
        if (!response.ok) {
            window.location.href = '/login.html';
            return false;
        }
        currentUser = await response.json();
        updateCreditDisplay();
        return true;
    } catch (error) {
        console.error('Auth check failed:', error);
        window.location.href = '/login.html';
        return false;
    }
}

function updateCreditDisplay() {
    const headerText = document.querySelector('.header-text');
    let creditDisplay = document.querySelector('.credit-display');
    if (!creditDisplay) {
        creditDisplay = document.createElement('div');
        creditDisplay.className = 'credit-display';
        headerText.appendChild(creditDisplay);
    }
    creditDisplay.innerHTML = `Credits: ${currentUser.user.credits}`;
}

async function initializeUI() {
    try {
        // Check authentication first
        if (!await checkAuth()) return;

        // Set character info
        document.getElementById("character-name").textContent = character.name;
        document.getElementById("character-description").textContent = character.description;

        // Add character avatar
        const avatarContainer = document.createElement("div");
        avatarContainer.className = "chat-header-avatar";
        const avatarImg = document.createElement("img");
        avatarImg.src = "../" + character.avatar;
        avatarImg.alt = character.name;
        avatarContainer.appendChild(avatarImg);
        document.querySelector("header").appendChild(avatarContainer);

        // Add background image
        const backgroundImg = document.querySelector(".chat-background");
        const backgroundPath = `../characters/${character.id}/background.jpg`;
        
        try {
            const response = await fetch(backgroundPath);
            if (response.ok) {
                backgroundImg.src = backgroundPath;
            } else {
                backgroundImg.src = "../assets/images/default-background.jpg";
            }
        } catch {
            backgroundImg.src = "../assets/images/default-background.jpg";
        }

        // Setup start chat button
        const startChatOverlay = document.getElementById('start-chat-overlay');
        const startChatButton = document.getElementById('start-chat-button');
        const chatInput = document.querySelector('.chat-input');

        if (startChatButton && chatInput) {
            chatInput.style.display = 'none'; // Hide chat input initially
            startChatButton.addEventListener('click', () => {
                console.log("Start chat clicked, message queue:", messageQueue);
                startChatOverlay.style.display = 'none';
                chatInput.style.display = 'flex';
                userInput.focus();
                
                // Only process queue if audio is enabled
                if (audioEnabled && messageQueue.length > 0) {
                    console.log("Processing initial greeting audio");
                    processNextInQueue();
                }
            });
        }

        // Add audio toggle
        const audioToggle = document.querySelector('.audio-toggle');
        if (audioToggle) {
            audioToggle.onclick = toggleAudio;
            audioToggle.title = `Credits per message: ${audioEnabled ? "15" : "10"}`;
        }

        // Add clear chat button
        const clearButton = document.querySelector('.clear-chat');
        if (clearButton) {
            clearButton.onclick = clearChatState;
        }

        // Initialize greeting
        setTimeout(sendInitialGreeting, 1000);

    } catch (error) {
        console.error("Error initializing UI:", error);
        showInitializationError(error);
    }
}

function sendInitialGreeting() {
    const hour = new Date().getHours();
    let timeGreeting = hour < 12 ? 'Good morning' : hour < 18 ? 'Good afternoon' : 'Good evening';

    console.log("Sending initial greeting...");
    
    let characterGreeting = character.greetings ? 
        character.greetings[Math.floor(Math.random() * character.greetings.length)] :
        "Hello! How can I help you today?";

    // Add initial greeting to chat history
    const systemMessage = {
        role: "system",
        content: character.systemPrompt
    };
    
    const assistantMessage = {
        role: "assistant",
        content: characterGreeting
    };
    
    chatHistory.push(systemMessage, assistantMessage);
    
    const fullGreeting = `${timeGreeting}! ${characterGreeting}`;
    addMessage("bot", fullGreeting);

    if (audioEnabled) {
        const ttsText = filterTextForTTS(fullGreeting);
        if (ttsText) {
            console.log("Adding greeting to message queue:", ttsText);
            messageQueue = [ttsText]; // Reset queue and add greeting
            console.log("Current message queue:", messageQueue);
        }
    }
}

function toggleAudio() {
    audioEnabled = !audioEnabled;
    console.log("Audio enabled:", audioEnabled);
    const audioToggle = document.querySelector('.audio-toggle');
    if (audioToggle) {
        audioToggle.innerHTML = audioEnabled ? "🔊" : "🔇";
        const creditsPerMessage = audioEnabled ? "15" : "10";
        audioToggle.title = `Credits per message: ${creditsPerMessage}`;
    }
    if (!audioEnabled && currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
}

function clearChatState() {
    chatHistory = [];
    messageQueue = [];
    isProcessing = false;
    
    if (currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
    
    if (chatLog) {
        chatLog.innerHTML = '';
    }

    setTimeout(sendInitialGreeting, 500);
}

function addMessage(sender, text) {
    const messageContainer = document.createElement("div");
    messageContainer.classList.add("message-container", sender);

    const avatarDiv = document.createElement("div");
    avatarDiv.classList.add("message-avatar");
    const avatarImg = document.createElement("img");
    avatarImg.src = sender === "user" ? "../avatars/default-user.png" : "../" + character.avatar;
    avatarImg.alt = sender === "user" ? "You" : character.name;
    avatarDiv.appendChild(avatarImg);

    const textBubble = document.createElement("div");
    textBubble.classList.add("text-bubble");
    textBubble.innerHTML = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

    if (sender === "user") {
        messageContainer.appendChild(textBubble);
        messageContainer.appendChild(avatarDiv);
    } else {
        messageContainer.appendChild(avatarDiv);
        messageContainer.appendChild(textBubble);
    }

    chatLog.appendChild(messageContainer);
    chatLog.scrollTop = chatLog.scrollHeight;

    // Only add to chat history if it's not already from initialization
    if (sender === "user" || chatHistory.length === 0) {
        chatHistory.push({ 
            role: sender === "user" ? "user" : "assistant", 
            content: text 
        });

        if (chatHistory.length > MAX_HISTORY_LENGTH * 2) {
            chatHistory = chatHistory.slice(-MAX_HISTORY_LENGTH * 2);
        }
    }
}

async function sendMessage(userMessage = null) {
    if (isProcessing) {
        console.log("Already processing a message, please wait...");
        return;
    }

    try {
        const message = userMessage || userInput.value.trim();
        if (!message) return;

        isProcessing = true;
        if (!userMessage) {
            addMessage("user", message);
            userInput.value = "";
        }
        
        userInput.disabled = true;
        sendButton.disabled = true;

        const creditCost = audioEnabled ? 15 : 10;

        // Ensure system prompt is included
        let messages = chatHistory;
        if (!chatHistory.some(msg => msg.role === "system")) {
            messages = [
                {
                    role: "system",
                    content: character.systemPrompt
                },
                ...chatHistory
            ];
        }

        const response = await fetch('/v1/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: "koboldcpp",
                messages: messages,
                temperature: character.ai_parameters?.temperature || 0.7,
                max_tokens: character.ai_parameters?.max_tokens || 150,
                top_p: character.ai_parameters?.top_p || 0.9,
                presence_penalty: character.ai_parameters?.presence_penalty || 0.6,
                frequency_penalty: character.ai_parameters?.frequency_penalty || 0.6
            })
        });

        if (response.status === 402) {
            addMessage("bot", "Insufficient credits. Please purchase more credits to continue chatting.");
            return;
        }

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const responseData = await response.json();
        const botMessage = responseData.choices[0].message.content.trim();
        addMessage("bot", botMessage);

        if (currentUser) {
            currentUser.user.credits -= creditCost;
            updateCreditDisplay();
        }

        if (audioEnabled) {
            const ttsText = filterTextForTTS(botMessage);
            if (ttsText) {
                messageQueue.push(ttsText);
                if (messageQueue.length === 1) {
                    processNextInQueue();
                }
            }
        }

    } catch (error) {
        console.error("Error details:", error);
        addMessage("bot", "I apologize, there was an error. Please try again.");
    } finally {
        isProcessing = false;
        userInput.disabled = false;
        sendButton.disabled = false;
        userInput.focus();
    }
}

async function processNextInQueue() {
    if (messageQueue.length === 0) {
        console.log("Message queue is empty");
        return;
    }

    try {
        const text = messageQueue[0];
        console.log("Processing TTS for text:", text);
        console.log("Current character:", character);
        console.log("Audio enabled:", audioEnabled);
        
        const requestBody = {
            text: text,
            edge_voice: character.ttsVoice,
            rvc_model: character.id,
            tts_rate: character.tts_rate || 0,
            rvc_pitch: character.rvc_pitch || 0
        };

        console.log("Sending TTS request:", requestBody);

        const ttsResponse = await fetch('/v1/tts', {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        if (!ttsResponse.ok) {
            throw new Error(`TTS API error: ${ttsResponse.status}`);
        }

        const ttsData = await ttsResponse.json();
        console.log("TTS response:", ttsData);
        
        if (!ttsData.audio_url) {
            throw new Error("No audio URL received from TTS service");
        }

        const audioUrl = ttsData.audio_url;
        
        if (audioUrl) {
            await playAudio(audioUrl);
        }

    } catch (error) {
        console.error("TTS error:", error);
        messageQueue.shift();
    } finally {
        messageQueue.shift();
        if (messageQueue.length > 0) {
            processNextInQueue();
        }
    }
}

async function playAudio(audioUrl) {
    if (!audioEnabled) return;

    try {
        if (currentAudioUrl === audioUrl) {
            console.log("Audio already playing:", audioUrl);
            return;
        }

        if (currentAudioPlayer) {
            currentAudioPlayer.pause();
            currentAudioPlayer = null;
        }

        const audioPlayer = new Audio(audioUrl);
        currentAudioPlayer = audioPlayer;
        currentAudioUrl = audioUrl;

        try {
            await audioPlayer.play();
        } catch (error) {
            console.error("Audio autoplay error:", error);
        }

        audioPlayer.onended = () => {
            currentAudioUrl = null;
        };

        audioPlayer.onerror = (e) => {
            console.error("Audio playback error:", e);
            currentAudioPlayer = null;
            currentAudioUrl = null;
        };

    } catch (error) {
        console.error("Error in playAudio:", error);
    }
}

function showInitializationError(error) {
    const header = document.querySelector('header');
    if (header) {
        const errorMessage = document.createElement('div');
        errorMessage.className = 'error-message';
        errorMessage.textContent = 'Error initializing chat. Please refresh the page.';
        header.appendChild(errorMessage);
    }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    try {
        initializeUI();
        
        if (sendButton && userInput) {
            sendButton.addEventListener("click", () => sendMessage());
            userInput.addEventListener("keypress", (event) => {
                if (event.key === "Enter" && !event.shiftKey) {
                    event.preventDefault();
                    sendMessage();
                }
            });
            
            userInput.focus();
        }
    } catch (error) {
        console.error('Error initializing chat:', error);
        showInitializationError(error);
    }
});
```

Contents of chat/.ipynb_checkpoints/chat-checkpoint.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./chat-styles.css">
    <title>Chat</title>
</head>
<body>
    <div class="chat-container">
        <img class="chat-background" alt="background" src="" /> <!-- Set by JS -->
        
        <header>
            <button class="home-button" onclick="window.location.href='../'">
                <span>🏠</span> Home
            </button>
            <div class="chat-header-avatar">
                <!-- Avatar will be inserted here by JavaScript -->
            </div>
            <div class="header-text">
                <h1 id="character-name">Character Name</h1>
                <p id="character-description">Character Description</p>
            </div>
            <button class="clear-chat">Clear Chat</button>
            <button class="audio-toggle">🔊</button>
        </header>

        <div id="chat-log" class="chat-log"></div>

        <div id="start-chat-overlay" class="start-chat-overlay">
    <button id="start-chat-button" class="start-chat-button">
        <span>👋</span> Start Chatting
    </button>
</div>
        
        <div class="chat-input">
            <input id="user-input" type="text" placeholder="Type your message here..." />
            <button id="send-button">Send</button>
        </div>
    </div>
    <script src="./chat.js" type="module"></script>
</body>
</html>
```

Contents of chat/.ipynb_checkpoints/chat-checkpoint.js:
```
// Configuration and state management
let currentUser = null;
const character = JSON.parse(sessionStorage.getItem("selectedCharacter"));
const chatLog = document.getElementById("chat-log");
const userInput = document.getElementById("user-input");
const sendButton = document.getElementById("send-button");

// Chat state
let chatHistory = [];
const MAX_HISTORY_LENGTH = 10;
let messageQueue = [];
const MAX_QUEUE_SIZE = 5;
let isProcessing = false;

// Audio state
let audioEnabled = true;
let autoplayEnabled = true;
let currentAudioPlayer = null;
let currentAudioUrl = null;

// Helper Functions
function filterTextForTTS(text) {
    return text.replace(/\*[^*]*\*/g, '').trim();
}

// Authentication check
async function checkAuth() {
    try {
        const response = await fetch('/auth/user');
        if (!response.ok) {
            window.location.href = '/login.html';
            return false;
        }
        currentUser = await response.json();
        updateCreditDisplay();
        return true;
    } catch (error) {
        console.error('Auth check failed:', error);
        window.location.href = '/login.html';
        return false;
    }
}

function updateCreditDisplay() {
    const headerText = document.querySelector('.header-text');
    let creditDisplay = document.querySelector('.credit-display');
    if (!creditDisplay) {
        creditDisplay = document.createElement('div');
        creditDisplay.className = 'credit-display';
        headerText.appendChild(creditDisplay);
    }
    creditDisplay.innerHTML = `Credits: ${currentUser.user.credits}`;
}

async function initializeUI() {
    try {
        // Check authentication first
        if (!await checkAuth()) return;

        // Set character info
        document.getElementById("character-name").textContent = character.name;
        document.getElementById("character-description").textContent = character.description;

        // Add character avatar
        const avatarContainer = document.createElement("div");
        avatarContainer.className = "chat-header-avatar";
        const avatarImg = document.createElement("img");
        avatarImg.src = "../" + character.avatar;
        avatarImg.alt = character.name;
        avatarContainer.appendChild(avatarImg);
        document.querySelector("header").appendChild(avatarContainer);

        // Add background image
        const backgroundImg = document.querySelector(".chat-background");
        const backgroundPath = `../characters/${character.id}/background.jpg`;
        
        try {
            const response = await fetch(backgroundPath);
            if (response.ok) {
                backgroundImg.src = backgroundPath;
            } else {
                backgroundImg.src = "../assets/images/default-background.jpg";
            }
        } catch {
            backgroundImg.src = "../assets/images/default-background.jpg";
        }

        // Setup start chat button
        const startChatOverlay = document.getElementById('start-chat-overlay');
        const startChatButton = document.getElementById('start-chat-button');
        const chatInput = document.querySelector('.chat-input');

        if (startChatButton && chatInput) {
            chatInput.style.display = 'none'; // Hide chat input initially
            startChatButton.addEventListener('click', () => {
                console.log("Start chat clicked, message queue:", messageQueue);
                startChatOverlay.style.display = 'none';
                chatInput.style.display = 'flex';
                userInput.focus();
                
                // Only process queue if audio is enabled
                if (audioEnabled && messageQueue.length > 0) {
                    console.log("Processing initial greeting audio");
                    processNextInQueue();
                }
            });
        }

        // Add audio toggle
        const audioToggle = document.querySelector('.audio-toggle');
        if (audioToggle) {
            audioToggle.onclick = toggleAudio;
            audioToggle.title = `Credits per message: ${audioEnabled ? "15" : "10"}`;
        }

        // Add clear chat button
        const clearButton = document.querySelector('.clear-chat');
        if (clearButton) {
            clearButton.onclick = clearChatState;
        }

        // Initialize greeting
        setTimeout(sendInitialGreeting, 1000);

    } catch (error) {
        console.error("Error initializing UI:", error);
        showInitializationError(error);
    }
}

function sendInitialGreeting() {
    const hour = new Date().getHours();
    let timeGreeting = hour < 12 ? 'Good morning' : hour < 18 ? 'Good afternoon' : 'Good evening';

    console.log("Sending initial greeting...");
    
    let characterGreeting = character.greetings ? 
        character.greetings[Math.floor(Math.random() * character.greetings.length)] :
        "Hello! How can I help you today?";

    // Add initial greeting to chat history
    const systemMessage = {
        role: "system",
        content: character.systemPrompt
    };
    
    const assistantMessage = {
        role: "assistant",
        content: characterGreeting
    };
    
    chatHistory.push(systemMessage, assistantMessage);
    
    const fullGreeting = `${timeGreeting}! ${characterGreeting}`;
    addMessage("bot", fullGreeting);

    if (audioEnabled) {
        const ttsText = filterTextForTTS(fullGreeting);
        if (ttsText) {
            console.log("Adding greeting to message queue:", ttsText);
            messageQueue = [ttsText]; // Reset queue and add greeting
            console.log("Current message queue:", messageQueue);
        }
    }
}

function toggleAudio() {
    audioEnabled = !audioEnabled;
    console.log("Audio enabled:", audioEnabled);
    const audioToggle = document.querySelector('.audio-toggle');
    if (audioToggle) {
        audioToggle.innerHTML = audioEnabled ? "🔊" : "🔇";
        const creditsPerMessage = audioEnabled ? "15" : "10";
        audioToggle.title = `Credits per message: ${creditsPerMessage}`;
    }
    if (!audioEnabled && currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
}

function clearChatState() {
    chatHistory = [];
    messageQueue = [];
    isProcessing = false;
    
    if (currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
        currentAudioUrl = null;
    }
    
    if (chatLog) {
        chatLog.innerHTML = '';
    }

    setTimeout(sendInitialGreeting, 500);
}

function addMessage(sender, text) {
    const messageContainer = document.createElement("div");
    messageContainer.classList.add("message-container", sender);

    const avatarDiv = document.createElement("div");
    avatarDiv.classList.add("message-avatar");
    const avatarImg = document.createElement("img");
    avatarImg.src = sender === "user" ? "../avatars/default-user.png" : "../" + character.avatar;
    avatarImg.alt = sender === "user" ? "You" : character.name;
    avatarDiv.appendChild(avatarImg);

    const textBubble = document.createElement("div");
    textBubble.classList.add("text-bubble");
    textBubble.innerHTML = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

    if (sender === "user") {
        messageContainer.appendChild(textBubble);
        messageContainer.appendChild(avatarDiv);
    } else {
        messageContainer.appendChild(avatarDiv);
        messageContainer.appendChild(textBubble);
    }

    chatLog.appendChild(messageContainer);
    chatLog.scrollTop = chatLog.scrollHeight;

    // Only add to chat history if it's not already from initialization
    if (sender === "user" || chatHistory.length === 0) {
        chatHistory.push({ 
            role: sender === "user" ? "user" : "assistant", 
            content: text 
        });

        if (chatHistory.length > MAX_HISTORY_LENGTH * 2) {
            chatHistory = chatHistory.slice(-MAX_HISTORY_LENGTH * 2);
        }
    }
}

async function sendMessage(userMessage = null) {
    if (isProcessing) {
        console.log("Already processing a message, please wait...");
        return;
    }

    try {
        const message = userMessage || userInput.value.trim();
        if (!message) return;

        isProcessing = true;
        if (!userMessage) {
            addMessage("user", message);
            userInput.value = "";
        }
        
        userInput.disabled = true;
        sendButton.disabled = true;

        const creditCost = audioEnabled ? 15 : 10;

        // Ensure system prompt is included
        let messages = chatHistory;
        if (!chatHistory.some(msg => msg.role === "system")) {
            messages = [
                {
                    role: "system",
                    content: character.systemPrompt
                },
                ...chatHistory
            ];
        }

        const response = await fetch('/v1/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: "koboldcpp",
                messages: messages,
                temperature: character.ai_parameters?.temperature || 0.7,
                max_tokens: character.ai_parameters?.max_tokens || 150,
                top_p: character.ai_parameters?.top_p || 0.9,
                presence_penalty: character.ai_parameters?.presence_penalty || 0.6,
                frequency_penalty: character.ai_parameters?.frequency_penalty || 0.6
            })
        });

        if (response.status === 402) {
            addMessage("bot", "Insufficient credits. Please purchase more credits to continue chatting.");
            return;
        }

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const responseData = await response.json();
        const botMessage = responseData.choices[0].message.content.trim();
        addMessage("bot", botMessage);

        if (currentUser) {
            currentUser.user.credits -= creditCost;
            updateCreditDisplay();
        }

        if (audioEnabled) {
            const ttsText = filterTextForTTS(botMessage);
            if (ttsText) {
                messageQueue.push(ttsText);
                if (messageQueue.length === 1) {
                    processNextInQueue();
                }
            }
        }

    } catch (error) {
        console.error("Error details:", error);
        addMessage("bot", "I apologize, there was an error. Please try again.");
    } finally {
        isProcessing = false;
        userInput.disabled = false;
        sendButton.disabled = false;
        userInput.focus();
    }
}

async function processNextInQueue() {
    if (messageQueue.length === 0) {
        console.log("Message queue is empty");
        return;
    }

    try {
        const text = messageQueue[0];
        console.log("Processing TTS for text:", text);
        console.log("Current character:", character);
        console.log("Audio enabled:", audioEnabled);
        
        const requestBody = {
            text: text,
            edge_voice: character.ttsVoice,
            rvc_model: character.id,
            tts_rate: character.tts_rate || 0,
            rvc_pitch: character.rvc_pitch || 0
        };

        console.log("Sending TTS request:", requestBody);

        const ttsResponse = await fetch('/v1/tts', {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        if (!ttsResponse.ok) {
            throw new Error(`TTS API error: ${ttsResponse.status}`);
        }

        const ttsData = await ttsResponse.json();
        console.log("TTS response:", ttsData);
        
        if (!ttsData.audio_url) {
            throw new Error("No audio URL received from TTS service");
        }

        const audioUrl = ttsData.audio_url;
        
        if (audioUrl) {
            await playAudio(audioUrl);
        }

    } catch (error) {
        console.error("TTS error:", error);
        messageQueue.shift();
    } finally {
        messageQueue.shift();
        if (messageQueue.length > 0) {
            processNextInQueue();
        }
    }
}

async function playAudio(audioUrl) {
    if (!audioEnabled) return;

    try {
        if (currentAudioUrl === audioUrl) {
            console.log("Audio already playing:", audioUrl);
            return;
        }

        if (currentAudioPlayer) {
            currentAudioPlayer.pause();
            currentAudioPlayer = null;
        }

        const audioPlayer = new Audio(audioUrl);
        currentAudioPlayer = audioPlayer;
        currentAudioUrl = audioUrl;

        try {
            await audioPlayer.play();
        } catch (error) {
            console.error("Audio autoplay error:", error);
        }

        audioPlayer.onended = () => {
            currentAudioUrl = null;
        };

        audioPlayer.onerror = (e) => {
            console.error("Audio playback error:", e);
            currentAudioPlayer = null;
            currentAudioUrl = null;
        };

    } catch (error) {
        console.error("Error in playAudio:", error);
    }
}

function showInitializationError(error) {
    const header = document.querySelector('header');
    if (header) {
        const errorMessage = document.createElement('div');
        errorMessage.className = 'error-message';
        errorMessage.textContent = 'Error initializing chat. Please refresh the page.';
        header.appendChild(errorMessage);
    }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    try {
        initializeUI();
        
        if (sendButton && userInput) {
            sendButton.addEventListener("click", () => sendMessage());
            userInput.addEventListener("keypress", (event) => {
                if (event.key === "Enter" && !event.shiftKey) {
                    event.preventDefault();
                    sendMessage();
                }
            });
            
            userInput.focus();
        }
    } catch (error) {
        console.error('Error initializing chat:', error);
        showInitializationError(error);
    }
});
```

Contents of chat/.ipynb_checkpoints/chat-styles-checkpoint.css:
```
/* Chat Interface Theme Variables */
:root {
  --primary: #BB86FC;
  --surface: #1E1E1E;
  --surface-2: #2D2D2D;
  --on-surface: #FFFFFF;
}

/* Reset for chat interface */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Base structure */
html, body {
  height: 100%;
  overflow: hidden;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: #121212;
  color: var(--on-surface);
}

/* Chat container */
.chat-container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

/* Background image */
.chat-background {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0.5; /* Slightly more visible background */
  z-index: 0;
}

/* Header - made more compact */
header {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 12px 20px; /* Reduced vertical padding */
  backdrop-filter: blur(10px);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
}

.chat-header-avatar {
  width: 50px; /* Reduced size */
  height: 50px; /* Reduced size */
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid var(--primary);
  flex-shrink: 0;
}

.chat-header-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.header-text {
  text-align: left;
}

.header-text h1 {
  font-size: 1.2rem; /* Smaller text */
  margin-bottom: 4px;
}

.header-text p {
  font-size: 0.9rem;
  opacity: 0.8;
}

/* Chat messages area */
.chat-log {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* This anchors content to bottom */
}

/* Message styling */
.message-container {
  display: flex;
  gap: 8px;
  align-items: flex-start;
  margin-bottom: 15px;
  max-width: 85%;
  position: relative;
  z-index: 2;
}

.message-container.user {
  flex-direction: row-reverse;
  margin-left: auto;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  overflow: hidden;
  flex-shrink: 0;
  border: 2px solid var(--primary);
}

.message-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.text-bubble {
  padding: 12px 16px;
  border-radius: 18px;
  background-color: rgba(46, 46, 46, 0.7);
  backdrop-filter: blur(5px);
  color: var(--on-surface);
  word-wrap: break-word;
}

.message-container.user .text-bubble {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Input area */
.chat-input {
  position: relative;
  z-index: 2;
  background-color: rgba(30, 30, 30, 0.7);
  padding: 15px;
  backdrop-filter: blur(10px);
  display: flex;
  gap: 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.chat-input input {
  flex: 1;
  padding: 12px;
  border-radius: 24px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(45, 45, 45, 0.7);
  color: var(--on-surface);
  font-size: 14px;
}

.chat-input input:focus {
  outline: none;
  border-color: var(--primary);
}

.chat-input button {
  padding: 12px 24px;
  border: none;
  background-color: var(--primary);
  color: black;
  border-radius: 24px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.start-chat-overlay {
    position: absolute;
    bottom: 80px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    background: linear-gradient(to top, rgba(18, 18, 18, 0.9), rgba(18, 18, 18, 0));
    z-index: 10;
}

.start-chat-button {
    padding: 12px 24px;
    background-color: var(--primary);
    color: black;
    border: none;
    border-radius: 24px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: transform 0.2s ease;
}

.start-chat-button:hover {
    transform: scale(1.05);
}

/* Navigation buttons */
.home-button {
  position: absolute;
  top: 12px;
  left: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.home-button:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.clear-chat {
  position: absolute;
  top: 12px;
  right: 80px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
}

.clear-chat:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

.audio-toggle {
  position: absolute;
  top: 12px;
  right: 20px;
  z-index: 3;
  background: none;
  border: 2px solid var(--primary);
  color: var(--primary);
  width: 38px;
  height: 38px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.audio-toggle:hover {
  background-color: rgba(187, 134, 252, 0.2);
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .message-container {
    max-width: 95%;
  }

  .chat-input {
    padding: 10px;
  }

  .header-text h1 {
    font-size: 1rem;
  }

  .header-text p {
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .chat-input {
    flex-direction: column;
    gap: 8px;
  }

  .chat-input button {
    width: 100%;
  }
}
```

Contents of assets/sounds/phone-ring.mp3:
```
[Could not decode file contents]

```

Contents of assets/images/default-background.jpg:
```
[Could not decode file contents]

```

Contents of css/create-character.css:
```
:root {
    --primary-blue: #00b4ff;
    --primary-purple: #a64dff;
    --dark-bg: #1a1a2e;
    --card-bg: #252542;
    --text-color: #ffffff;
    --input-bg: #2f2f4f;
}

body {
    background: var(--dark-bg);
    color: var(--text-color);
    font-family: 'Arial', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 0;
}

.container {
    max-width: 900px;
    margin: 2rem auto;
    padding: 2rem;
}

h1 {
    text-align: center;
    color: var(--primary-blue);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.5);
    margin-bottom: 2rem;
}

.form-section {
    background: var(--card-bg);
    border-radius: 10px;
    padding: 2rem;
    margin-bottom: 2.5rem;
    box-shadow: 0 0 20px rgba(166, 77, 255, 0.1);
    border: 1px solid rgba(166, 77, 255, 0.2);
}

h3 {
    color: var(--primary-purple);
    margin-top: 0;
    border-bottom: 2px solid var(--primary-purple);
    padding-bottom: 0.5rem;
}

.form-group {
    margin-bottom: 2rem;
}

label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--primary-blue);
}

input[type="text"],
input[type="file"],
select,
textarea {
    width: 100%;
    padding: 0.8rem;
    border-radius: 5px;
    border: 1px solid rgba(166, 77, 255, 0.3);
    background: var(--input-bg);
    color: var(--text-color);
    transition: all 0.3s ease;
}

input[type="text"]:focus,
select:focus,
textarea:focus {
    outline: none;
    border-color: var(--primary-purple);
    box-shadow: 0 0 10px rgba(166, 77, 255, 0.3);
}

textarea {
    min-height: 120px;
    resize: vertical;
}

.helper-text {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 0.5rem;
}

button {
    background: linear-gradient(45deg, var(--primary-blue), var(--primary-purple));
    color: white;
    padding: 1rem 2rem;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    width: 100%;
    margin-top: 1rem;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(166, 77, 255, 0.3);
}

.image-upload {
    text-align: center;
    margin: 2rem 0;
}

#avatarPreview,
#backgroundPreview {
    max-width: 200px;
    height: 200px;
    object-fit: cover;
    border-radius: 10px;
    margin: 1rem 0;
    border: 2px solid var(--primary-purple);
}

.model-info-box {
    background: rgba(0, 180, 255, 0.1);
    padding: 1.5rem;
    border-radius: 5px;
    margin-bottom: 2rem;
}

.model-info-box h4 {
    color: var(--primary-blue);
    margin-top: 0;
}

.model-info-box a {
    color: var(--primary-purple);
    text-decoration: none;
}

.model-info-box ul {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.model-upload {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin-top: 1.5rem;
}

.upload-group {
    padding: 1rem;
}

.slider-control {
    margin: 1rem 0;
}

input[type="range"] {
    width: 100%;
    margin: 0.5rem 0;
}

.value-display {
    color: var(--primary-blue);
    font-weight: bold;
    margin-left: 0.5rem;
}

input[type="checkbox"] {
    accent-color: var(--primary-purple);
    margin-right: 0.5rem;
}

.required-field::after {
    content: '*';
    color: var(--primary-purple);
    margin-left: 0.25rem;
}

```

Contents of css/.ipynb_checkpoints/create-character-checkpoint.css:
```
:root {
    --primary-blue: #00b4ff;
    --primary-purple: #a64dff;
    --dark-bg: #1a1a2e;
    --card-bg: #252542;
    --text-color: #ffffff;
    --input-bg: #2f2f4f;
}

body {
    background: var(--dark-bg);
    color: var(--text-color);
    font-family: 'Arial', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 0;
}

.container {
    max-width: 900px;
    margin: 2rem auto;
    padding: 2rem;
}

h1 {
    text-align: center;
    color: var(--primary-blue);
    text-shadow: 0 0 10px rgba(0, 180, 255, 0.5);
    margin-bottom: 2rem;
}

.form-section {
    background: var(--card-bg);
    border-radius: 10px;
    padding: 2rem;
    margin-bottom: 2.5rem;
    box-shadow: 0 0 20px rgba(166, 77, 255, 0.1);
    border: 1px solid rgba(166, 77, 255, 0.2);
}

h3 {
    color: var(--primary-purple);
    margin-top: 0;
    border-bottom: 2px solid var(--primary-purple);
    padding-bottom: 0.5rem;
}

.form-group {
    margin-bottom: 2rem;
}

label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--primary-blue);
}

input[type="text"],
input[type="file"],
select,
textarea {
    width: 100%;
    padding: 0.8rem;
    border-radius: 5px;
    border: 1px solid rgba(166, 77, 255, 0.3);
    background: var(--input-bg);
    color: var(--text-color);
    transition: all 0.3s ease;
}

input[type="text"]:focus,
select:focus,
textarea:focus {
    outline: none;
    border-color: var(--primary-purple);
    box-shadow: 0 0 10px rgba(166, 77, 255, 0.3);
}

textarea {
    min-height: 120px;
    resize: vertical;
}

.helper-text {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 0.5rem;
}

button {
    background: linear-gradient(45deg, var(--primary-blue), var(--primary-purple));
    color: white;
    padding: 1rem 2rem;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    width: 100%;
    margin-top: 1rem;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(166, 77, 255, 0.3);
}

.image-upload {
    text-align: center;
    margin: 2rem 0;
}

#avatarPreview,
#backgroundPreview {
    max-width: 200px;
    height: 200px;
    object-fit: cover;
    border-radius: 10px;
    margin: 1rem 0;
    border: 2px solid var(--primary-purple);
}

.model-info-box {
    background: rgba(0, 180, 255, 0.1);
    padding: 1.5rem;
    border-radius: 5px;
    margin-bottom: 2rem;
}

.model-info-box h4 {
    color: var(--primary-blue);
    margin-top: 0;
}

.model-info-box a {
    color: var(--primary-purple);
    text-decoration: none;
}

.model-info-box ul {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.model-upload {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin-top: 1.5rem;
}

.upload-group {
    padding: 1rem;
}

.slider-control {
    margin: 1rem 0;
}

input[type="range"] {
    width: 100%;
    margin: 0.5rem 0;
}

.value-display {
    color: var(--primary-blue);
    font-weight: bold;
    margin-left: 0.5rem;
}

input[type="checkbox"] {
    accent-color: var(--primary-purple);
    margin-right: 0.5rem;
}

.required-field::after {
    content: '*';
    color: var(--primary-purple);
    margin-left: 0.25rem;
}

```

Contents of js/characterCreation.js:
```
class CharacterCreator {
    constructor() {
        this.form = document.getElementById('characterForm');
        console.log('CharacterCreator initialized');
        this.initializeForm();
        console.log('Loading available voices...');
        this.loadAvailableVoices();
        this.setupEventListeners();
    }

    initializeForm() {
        this.form.addEventListener('submit', (e) => this.handleSubmit(e));
        
        // Setup image preview
        document.querySelector('input[name="avatar"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'avatarPreview'));
        document.querySelector('input[name="background"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'backgroundPreview'));

        // Setup voice preview
        const previewBtn = document.getElementById('previewVoiceBtn');
        if (previewBtn) {
            previewBtn.addEventListener('click', () => this.handleVoicePreview());
        }
    }

    setupEventListeners() {
        // Update value displays for sliders
        document.querySelectorAll('.slider-control input[type="range"]').forEach(slider => {
            const display = slider.nextElementSibling;
            slider.addEventListener('input', () => {
                display.textContent = slider.value;
            });
        });
    }

    async loadAvailableVoices() {
        const edge_voices = [
            "en-GB-LibbyNeural",
            "en-GB-MaisieNeural", 
            "en-GB-RyanNeural",
            "en-GB-SoniaNeural", 
            "en-GB-ThomasNeural",
            "en-US-AvaMultilingualNeural",
            "en-US-AndrewMultilingualNeural",
            "en-US-EmmaMultilingualNeural", 
            "en-US-BrianMultilingualNeural",
            "en-US-AvaNeural",
            "en-US-AndrewNeural",
            "en-US-EmmaNeural",
            "en-US-BrianNeural",
            "en-US-AnaNeural",
            "en-US-AriaNeural",
            "en-US-ChristopherNeural",
            "en-US-EricNeural",
            "en-US-GuyNeural",
            "en-US-JennyNeural",
            "en-US-MichelleNeural",
            "en-US-RogerNeural",
            "en-US-SteffanNeural"
        ];

        try {
            const select = document.querySelector('select[name="ttsVoice"]');
            if (!select) {
                throw new Error('Voice select element not found');
            }

            // Clear existing options
            select.innerHTML = '<option value="">Select TTS Voice</option>';
            
            // Add each voice as an option
            edge_voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice;
                option.textContent = voice;
                select.appendChild(option);
            });
                
        } catch (error) {
            console.error('Error loading voices:', error);
            const select = document.querySelector('select[name="ttsVoice"]');
            if (select) {
                select.innerHTML = '<option value="">Error loading voices</option>';
            }
        }
    }

    async handleVoicePreview() {
        const voiceSelect = document.querySelector('select[name="ttsVoice"]');
        const selectedVoice = voiceSelect.value;
        const previewBtn = document.getElementById('previewVoiceBtn');
        const loadingSpinner = previewBtn.querySelector('.loading');

        if (!selectedVoice) {
            alert('Please select a voice first');
            return;
        }

        try {
            // Show loading state
            previewBtn.disabled = true;
            loadingSpinner.style.display = 'inline-block';

            // Get current rate and pitch values
            const ttsRate = parseInt(document.querySelector('input[name="ttsRate"]').value) || 0;
            const rvcPitch = parseInt(document.querySelector('input[name="rvcPitch"]').value) || 0;

            const response = await fetch('/v1/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: "Hello! This is a preview of my voice.",
                    edge_voice: selectedVoice,
                    tts_rate: ttsRate,
                    rvc_pitch: rvcPitch
                })
            });

            if (!response.ok) {
                throw new Error('Failed to generate voice preview');
            }

            const data = await response.json();
            
            // Create and play audio
            const audio = new Audio(data.audio_url);
            await audio.play();

        } catch (error) {
            console.error('Error previewing voice:', error);
            alert('Failed to preview voice: ' + error.message);
        } finally {
            // Reset loading state
            previewBtn.disabled = false;
            loadingSpinner.style.display = 'none';
        }
    }

    async resizeImage(file, targetWidth = 256, targetHeight = 256, isBackground = false) {
        return new Promise((resolve) => {
            const img = new Image();
            const reader = new FileReader();

            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    // For backgrounds, preserve original dimensions and don't resize
                    if (isBackground) {
                        // If it's a GIF, just return the original file
                        if (file.type === 'image/gif') {
                            resolve(file);
                            return;
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        
                        canvas.toBlob((blob) => {
                            resolve(blob);
                        }, file.type, 0.95);
                        return;
                    }

                    // For avatars, keep the existing square resize logic
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');

                    // Fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Calculate scaling and position to maintain aspect ratio
                    let scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                    let x = (targetWidth - img.width * scale) / 2;
                    let y = (targetHeight - img.height * scale) / 2;

                    // Draw image centered
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                    // Convert to blob
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 0.95);
                };
            };
            reader.readAsDataURL(file);
        });
    }

    async handleImagePreview(event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const isBackground = previewId === 'backgroundPreview';
            const resizedBlob = await this.resizeImage(file, 256, 256, isBackground);
            const previewUrl = URL.createObjectURL(resizedBlob);
            
            const img = document.createElement('img');
            img.src = previewUrl;
            img.className = 'preview-image';
            if (isBackground) {
                img.style.width = '100%';
                img.style.height = 'auto';
            }
            
            const previewDiv = document.getElementById(previewId);
            previewDiv.innerHTML = '';
            previewDiv.appendChild(img);

            // Store the blob for later upload
            event.target.resizedBlob = resizedBlob;
        } catch (error) {
            console.error('Error handling image preview:', error);
        }
    }

    async uploadImage(inputElement, type) {
    if (!inputElement?.files[0] && !inputElement?.resizedBlob) return null;

    const formData = new FormData();
    formData.append(type, inputElement.resizedBlob || inputElement.files[0]);
    
    let endpoint;
    if (type === 'avatar') {
        endpoint = '/upload/avatar';
    } else if (type === 'background') {
        endpoint = '/upload/character-background';
    }

    try {
        console.log(`Uploading ${type} to ${endpoint}`);
        const response = await fetch(endpoint, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Failed to upload ${type}`);
        }
        
        const result = await response.json();
        console.log('Upload response:', result);
        
        if (result.avatarPath || result.backgroundPath) {
            return result.avatarPath || result.backgroundPath;
        }
        
        throw new Error(`No path returned for ${type}`);

    } catch (error) {
        console.error(`Error uploading ${type}:`, error);
        throw error;
    }
}
    async uploadModel(characterId) {
        const modelFile = document.querySelector('input[name="modelFile"]').files[0];
        const indexFile = document.querySelector('input[name="indexFile"]').files[0];

        if (!modelFile || !indexFile) {
            return null;
        }

        const formData = new FormData();
        formData.append('modelFile', modelFile);
        formData.append('indexFile', indexFile);
        formData.append('characterId', characterId);

        try {
            const response = await fetch('/characters/upload-model', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Failed to upload model');
            }

            return await response.json();

        } catch (error) {
            console.error('Error uploading model:', error);
            throw error;
        }
    }

    validateParameters(params) {
        const validated = {};
        
        if (params.temperature !== undefined) {
            validated.temperature = Math.min(Math.max(0.1, params.temperature), 2.0);
        }
        if (params.top_p !== undefined) {
            validated.top_p = Math.min(Math.max(0.1, params.top_p), 1.0);
        }
        if (params.top_k !== undefined) {
            validated.top_k = Math.min(Math.max(1, params.top_k), 100);
        }
        
        validated.name = params.name;
        validated.description = params.description;
        validated.systemPrompt = params.systemPrompt;
        validated.ttsVoice = params.ttsVoice;
        validated.avatar = params.avatar;
        
        if (params.background) validated.background = params.background;
        if (params.category) validated.category = params.category;
        if (params.tags) validated.tags = params.tags;
        if (params.is_private !== undefined) validated.is_private = params.is_private;
        if (params.tts_rate !== undefined) validated.tts_rate = params.tts_rate;
        if (params.rvc_pitch !== undefined) validated.rvc_pitch = params.rvc_pitch;
        
        return validated;
    }

    async handleSubmit(event) {
        event.preventDefault();
        
        try {
            const avatarInput = document.querySelector('input[name="avatar"]');
            const backgroundInput = document.querySelector('input[name="background"]');

            // Upload images first
            const avatarPath = await this.uploadImage(avatarInput, 'avatar');
            const backgroundPath = await this.uploadImage(backgroundInput, 'background');

            const formData = new FormData(event.target);
            const data = {
                name: formData.get('name'),
                description: formData.get('description'),
                systemPrompt: formData.get('systemPrompt'),
                ttsVoice: formData.get('ttsVoice'),
                category: formData.get('category'),
                tags: formData.get('tags')?.split(',').map(tag => tag.trim()) || [],
                is_private: formData.get('isPrivate') === 'true',
                tts_rate: parseInt(formData.get('ttsRate')) || 0,
                rvc_pitch: parseInt(formData.get('rvcPitch')) || 0,
                temperature: parseFloat(formData.get('temperature')) || 0.7,
                top_p: parseFloat(formData.get('topP')) || 0.9,
                top_k: parseInt(formData.get('topK')) || 40,
                avatar: avatarPath,
                background: backgroundPath
            };

            const validatedData = this.validateParameters(data);

            const response = await fetch('/characters/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(validatedData)
            });

            if (!response.ok) {
                throw new Error('Failed to create character');
            }

            const result = await response.json();
            const characterId = result.character_id;

            if (document.querySelector('input[name="modelFile"]').files.length > 0) {
                await this.uploadModel(characterId);
            }

            alert('Character created successfully!');
            window.location.href = '/characters';

        } catch (error) {
            console.error('Error:', error);
            alert('Error: ' + error.message);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CharacterCreator();
});
```

Contents of js/.ipynb_checkpoints/characterCreation-checkpoint.js:
```
class CharacterCreator {
    constructor() {
        this.form = document.getElementById('characterForm');
        console.log('CharacterCreator initialized');
        this.initializeForm();
        console.log('Loading available voices...');
        this.loadAvailableVoices();
        this.setupEventListeners();
    }

    initializeForm() {
        this.form.addEventListener('submit', (e) => this.handleSubmit(e));
        
        // Setup image preview
        document.querySelector('input[name="avatar"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'avatarPreview'));
        document.querySelector('input[name="background"]').addEventListener('change', (e) => 
            this.handleImagePreview(e, 'backgroundPreview'));

        // Setup voice preview
        const previewBtn = document.getElementById('previewVoiceBtn');
        if (previewBtn) {
            previewBtn.addEventListener('click', () => this.handleVoicePreview());
        }
    }

    setupEventListeners() {
        // Update value displays for sliders
        document.querySelectorAll('.slider-control input[type="range"]').forEach(slider => {
            const display = slider.nextElementSibling;
            slider.addEventListener('input', () => {
                display.textContent = slider.value;
            });
        });
    }

    async loadAvailableVoices() {
        const edge_voices = [
            "en-GB-LibbyNeural",
            "en-GB-MaisieNeural", 
            "en-GB-RyanNeural",
            "en-GB-SoniaNeural", 
            "en-GB-ThomasNeural",
            "en-US-AvaMultilingualNeural",
            "en-US-AndrewMultilingualNeural",
            "en-US-EmmaMultilingualNeural", 
            "en-US-BrianMultilingualNeural",
            "en-US-AvaNeural",
            "en-US-AndrewNeural",
            "en-US-EmmaNeural",
            "en-US-BrianNeural",
            "en-US-AnaNeural",
            "en-US-AriaNeural",
            "en-US-ChristopherNeural",
            "en-US-EricNeural",
            "en-US-GuyNeural",
            "en-US-JennyNeural",
            "en-US-MichelleNeural",
            "en-US-RogerNeural",
            "en-US-SteffanNeural"
        ];

        try {
            const select = document.querySelector('select[name="ttsVoice"]');
            if (!select) {
                throw new Error('Voice select element not found');
            }

            // Clear existing options
            select.innerHTML = '<option value="">Select TTS Voice</option>';
            
            // Add each voice as an option
            edge_voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice;
                option.textContent = voice;
                select.appendChild(option);
            });
                
        } catch (error) {
            console.error('Error loading voices:', error);
            const select = document.querySelector('select[name="ttsVoice"]');
            if (select) {
                select.innerHTML = '<option value="">Error loading voices</option>';
            }
        }
    }

    async handleVoicePreview() {
        const voiceSelect = document.querySelector('select[name="ttsVoice"]');
        const selectedVoice = voiceSelect.value;
        const previewBtn = document.getElementById('previewVoiceBtn');
        const loadingSpinner = previewBtn.querySelector('.loading');

        if (!selectedVoice) {
            alert('Please select a voice first');
            return;
        }

        try {
            // Show loading state
            previewBtn.disabled = true;
            loadingSpinner.style.display = 'inline-block';

            // Get current rate and pitch values
            const ttsRate = parseInt(document.querySelector('input[name="ttsRate"]').value) || 0;
            const rvcPitch = parseInt(document.querySelector('input[name="rvcPitch"]').value) || 0;

            const response = await fetch('/v1/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: "Hello! This is a preview of my voice.",
                    edge_voice: selectedVoice,
                    tts_rate: ttsRate,
                    rvc_pitch: rvcPitch
                })
            });

            if (!response.ok) {
                throw new Error('Failed to generate voice preview');
            }

            const data = await response.json();
            
            // Create and play audio
            const audio = new Audio(data.audio_url);
            await audio.play();

        } catch (error) {
            console.error('Error previewing voice:', error);
            alert('Failed to preview voice: ' + error.message);
        } finally {
            // Reset loading state
            previewBtn.disabled = false;
            loadingSpinner.style.display = 'none';
        }
    }

    async resizeImage(file, targetWidth = 256, targetHeight = 256, isBackground = false) {
        return new Promise((resolve) => {
            const img = new Image();
            const reader = new FileReader();

            reader.onload = function(e) {
                img.src = e.target.result;
                img.onload = function() {
                    // For backgrounds, preserve original dimensions and don't resize
                    if (isBackground) {
                        // If it's a GIF, just return the original file
                        if (file.type === 'image/gif') {
                            resolve(file);
                            return;
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        
                        canvas.toBlob((blob) => {
                            resolve(blob);
                        }, file.type, 0.95);
                        return;
                    }

                    // For avatars, keep the existing square resize logic
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');

                    // Fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Calculate scaling and position to maintain aspect ratio
                    let scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                    let x = (targetWidth - img.width * scale) / 2;
                    let y = (targetHeight - img.height * scale) / 2;

                    // Draw image centered
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                    // Convert to blob
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 0.95);
                };
            };
            reader.readAsDataURL(file);
        });
    }

    async handleImagePreview(event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const isBackground = previewId === 'backgroundPreview';
            const resizedBlob = await this.resizeImage(file, 256, 256, isBackground);
            const previewUrl = URL.createObjectURL(resizedBlob);
            
            const img = document.createElement('img');
            img.src = previewUrl;
            img.className = 'preview-image';
            if (isBackground) {
                img.style.width = '100%';
                img.style.height = 'auto';
            }
            
            const previewDiv = document.getElementById(previewId);
            previewDiv.innerHTML = '';
            previewDiv.appendChild(img);

            // Store the blob for later upload
            event.target.resizedBlob = resizedBlob;
        } catch (error) {
            console.error('Error handling image preview:', error);
        }
    }

    async uploadImage(inputElement, type) {
    if (!inputElement?.files[0] && !inputElement?.resizedBlob) return null;

    const formData = new FormData();
    formData.append(type, inputElement.resizedBlob || inputElement.files[0]);
    
    let endpoint;
    if (type === 'avatar') {
        endpoint = '/upload/avatar';
    } else if (type === 'background') {
        endpoint = '/upload/character-background';
    }

    try {
        console.log(`Uploading ${type} to ${endpoint}`);
        const response = await fetch(endpoint, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Failed to upload ${type}`);
        }
        
        const result = await response.json();
        console.log('Upload response:', result);
        
        if (result.avatarPath || result.backgroundPath) {
            return result.avatarPath || result.backgroundPath;
        }
        
        throw new Error(`No path returned for ${type}`);

    } catch (error) {
        console.error(`Error uploading ${type}:`, error);
        throw error;
    }
}
    async uploadModel(characterId) {
        const modelFile = document.querySelector('input[name="modelFile"]').files[0];
        const indexFile = document.querySelector('input[name="indexFile"]').files[0];

        if (!modelFile || !indexFile) {
            return null;
        }

        const formData = new FormData();
        formData.append('modelFile', modelFile);
        formData.append('indexFile', indexFile);
        formData.append('characterId', characterId);

        try {
            const response = await fetch('/characters/upload-model', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Failed to upload model');
            }

            return await response.json();

        } catch (error) {
            console.error('Error uploading model:', error);
            throw error;
        }
    }

    validateParameters(params) {
        const validated = {};
        
        if (params.temperature !== undefined) {
            validated.temperature = Math.min(Math.max(0.1, params.temperature), 2.0);
        }
        if (params.top_p !== undefined) {
            validated.top_p = Math.min(Math.max(0.1, params.top_p), 1.0);
        }
        if (params.top_k !== undefined) {
            validated.top_k = Math.min(Math.max(1, params.top_k), 100);
        }
        
        validated.name = params.name;
        validated.description = params.description;
        validated.systemPrompt = params.systemPrompt;
        validated.ttsVoice = params.ttsVoice;
        validated.avatar = params.avatar;
        
        if (params.background) validated.background = params.background;
        if (params.category) validated.category = params.category;
        if (params.tags) validated.tags = params.tags;
        if (params.is_private !== undefined) validated.is_private = params.is_private;
        if (params.tts_rate !== undefined) validated.tts_rate = params.tts_rate;
        if (params.rvc_pitch !== undefined) validated.rvc_pitch = params.rvc_pitch;
        
        return validated;
    }

    async handleSubmit(event) {
        event.preventDefault();
        
        try {
            const avatarInput = document.querySelector('input[name="avatar"]');
            const backgroundInput = document.querySelector('input[name="background"]');

            // Upload images first
            const avatarPath = await this.uploadImage(avatarInput, 'avatar');
            const backgroundPath = await this.uploadImage(backgroundInput, 'background');

            const formData = new FormData(event.target);
            const data = {
                name: formData.get('name'),
                description: formData.get('description'),
                systemPrompt: formData.get('systemPrompt'),
                ttsVoice: formData.get('ttsVoice'),
                category: formData.get('category'),
                tags: formData.get('tags')?.split(',').map(tag => tag.trim()) || [],
                is_private: formData.get('isPrivate') === 'true',
                tts_rate: parseInt(formData.get('ttsRate')) || 0,
                rvc_pitch: parseInt(formData.get('rvcPitch')) || 0,
                temperature: parseFloat(formData.get('temperature')) || 0.7,
                top_p: parseFloat(formData.get('topP')) || 0.9,
                top_k: parseInt(formData.get('topK')) || 40,
                avatar: avatarPath,
                background: backgroundPath
            };

            const validatedData = this.validateParameters(data);

            const response = await fetch('/characters/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(validatedData)
            });

            if (!response.ok) {
                throw new Error('Failed to create character');
            }

            const result = await response.json();
            const characterId = result.character_id;

            if (document.querySelector('input[name="modelFile"]').files.length > 0) {
                await this.uploadModel(characterId);
            }

            alert('Character created successfully!');
            window.location.href = '/characters';

        } catch (error) {
            console.error('Error:', error);
            alert('Error: ' + error.message);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CharacterCreator();
});
```

